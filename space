#!/usr/bin/env bash
###############################################################################
###          |                       !                                 |    ###
##           |                       .                                 |     ##
#            !                       _                                 !      #
#            .               S P A C E `..                             .      #
#            .         IoT automation - By.Blockie                     .      #
#                                         .                                   #
##           .                            .                                 .##
###                                                                        !###
##           .                                                             . ##
#            .                                                                #
#          __áˆ´__                                                              #
###############################################################################

#
# Copyright:
#   Blockie AB 2016-2017 (blockie.org)
#
# Authors:
#   Thomas Backlund (blund@blockie.org).
#   Maicon Filippsen (filippsen@blockie.org).
#
# Copying:
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation version 3 of the License.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Hacker's Guide:
#   See the man page and https://space.sh for more details.
#
# WHAT IS SpaceGal:
#   SpaceGal is a suite of tools and services for automating the Internet of Things (IoT),
#   aimed to provide small footprint automation for IoT devices,
#   servers and life in general.
#
#   The SpaceGal shell is this Bash script, referred to as "Space" below.
#   The SpaceGal shell's site is found at https://space.sh.
#
# Bash compatibility:
#   Space is made to work with Bash version 3.2 and upwards.
#   It has been tested using Bash 3.2.57 and several Bash 4 versions.
#
# EXTERNAL programs:
#   Space uses some external programs for certain tasks,
#   mostly coupled to tasks that involve disk and/or network access.
#   These external programs are not all POSIX 1003.1 compliant but have been
#   tested to work with GNU/Linux, BusyBox and OSX.
#   Search for the word EXTERNAL to see where and how they are used.
#

# Exit when trying to access undeclared variables.
set -o nounset

#==========
# GLOBALS
#==========


#
# Program
#

# Version
readonly _VERSION="0.10.0"
# Full path the space script it self.
readonly _SPACEBIN=$0
# Absolute path to the directory where space is located.
readonly _BASEDIR=$( cd "${_SPACEBIN%/*}" 2>/dev/null && pwd )
# Usage help string
readonly _USAGE="Usage:
    space [-f|m namespace [-M modules] [-ep key=value] [-c cmd] [node] [-a]] [-vkKCBX value] [-dlShg] [-- args]
    space [-hV]
    space -U [module]"

#
# Output configuration
#

# Set log level in interval [0,5]
_LOG_LEVEL=${SPACE_LOG_LEVEL:-4}

# Enable colored message output
_LOG_ENABLE_COLORS=${SPACE_LOG_ENABLE_COLORS:-1}

# The verbosity level: 0-4 [none-everything]
_VERBOSITY=3
# Set to 1 to output the preprocessed YAML result.
_DEBUG_OUTPUT_PREPROCESSED=0
# Set to 1 to output the parsed YAML to Bash
_DEBUG_OUTPUT_PARSED=0
# Set to 1 to output the re-transformed YAML, back from Bash
_DEBUG_OUTPUT_TRANSFORMED_YAML=0
# Set to 1 to output all _loadnode eval code.
_DEBUG_OUTPUT_ENV=0


#
# Modules settings
#

# Shared directory for cloning modules into.
_MODULES_SHARED=${SPACE_MODULES_SHARED:-~/.space/space_modules}

#
# Modules parsing and processing
#

# This must always be underscore prefixed.
# Should not be changed during runtime.
_YAML_PREFIX="_sg"
# This should be changed when loading and working on different YAML documents.
_YAML_NAMESPACE=1
# Tag we use for here documents.
readonly _SPACEGAL_EOF_TAG="_SPACEGAL_SAYS_END_OF_FINITY_"
# Use caching. 0 = no, 1 = yes (default), 2 = regenerate cache.
_CACHE_LEVEL=1
# Internal identifier of the cache files current format.
readonly _CACHE_FORMAT="2.1"

# Array of files that will get sourced before executing.
# Added using _source function.
_SOURCE_FILES=()
# A complete and unique list of all sh/bash files sourced using _source,
# including space itself.
_SOURCE_FILES_TOTAL=("${0}")
# Internal variable automatically set when Bash completion is performed.
_BASH_COMPLETION=0
readonly _COLOR_DEFAULT="\033[0m"
readonly _COLOR_FG_RED="\033[31m"
readonly _COLOR_FG_GREEN="\033[32m"
readonly _COLOR_FG_YELLOW="\033[33m"
readonly _COLOR_FG_MAGENTA="\033[35m"
readonly _COLOR_FG_CYAN="\033[36m"
readonly _COLOR_FG_WHITE="\033[37m"

# Override column position for print function
_PRINT_COLUMN_POSITION="0"

# These are environment variables to be overwritten in the YAML or by Space functions.
# They are intentionally not inherited from the Bash environment.
unset CMDARGS
unset ALIAS
unset RUN
unset CMDEXIT
unset CMDSILENT
unset CMDOUTER
unset CMDREDIR
unset CMDWRAP # CMDWRAP is the only environment variable allowed to be inherited downwards in node structures.

# Figure out if there's a shasum executable in the OS.
# We use this for caching purposes, so not required.
# EXTERNAL: sha256sum, sha1sum, shasum.
if command -v sha256sum >/dev/null; then
    readonly _SHASUMBIN=sha256sum
elif command -v sha1sum >/dev/null; then
    readonly _SHASUMBIN=sha1sum
elif command -v shasum >/dev/null; then
    readonly _SHASUMBIN="shasum -a 256"
else
    readonly _SHASUMBIN=
fi

# Figure out if curl or wget is installed in the OS.
# We use this for checking modules against banlists
# and also as fallback for downloading modules if Git
# is not installed.
# EXTERNAL: curl, wget
if command -v curl >/dev/null; then
    readonly _HTTPBIN=curl
elif command -v wget >/dev/null; then
    readonly _HTTPBIN=wget
else
    readonly _HTTPBIN=
fi

# Find out if uname is available
# EXTERNAL: uname
if command -v uname >/dev/null; then
    readonly _UNAMEBIN="uname"
    readonly _UNAME="$_UNAMEBIN -srvm"
else
    readonly _UNAMEBIN=""
    readonly _UNAME=""
fi

# The server we consult to check if a module is banned.
readonly _SECURITY_BAN_SERVER="https://get.space.sh/verify_module"

# Check the Git url to clone or update against the banlist.
#  0=do not check at all
#  1=check and accept "unknown" and "non banned" modules.
#  2=check and require "trusted" status for module.
_SECURITY_CHECK_BANNED=1

# Verify the modules Git commit signature against web-of-trust.
#  0=do not very signature at all.
#  1=accept marginal trust.
#  2=only accept full trust.
_SECURITY_GPG_VERIFY_SIGNATURE=0

# If Git is not installed try to download tarball using curl/wget.
_SECURITY_ALLOW_HTTPS_FALLBACK=0

# Stack current pointer
_STACK_POINTER=0

# Stack name prefix
_STACK_PREFIX="_stack_"

# Set to "1" to force to run export in Bash.
# Will autoamtically be set to "1" if any module
# loaded with a .bash file.
_FORCE_BASH="0"

# Set to "1" to enable GUI
_ENABLE_GUI="0"

# Set to "1" to allow Space to use
# external OS tools to speed things up.
# Like awk, sore, etc.
_ALLOW_EXTERNAL="1"

#==========
# _helpusage
#
# Outputs help and usage text
#==========
_helpusage()
{
    local _s=
    IFS= read -d '' -r _s << _EOF
Space. (C) Blockie AB 2016-2017, blockie.org. GPL version 3 licensed.

See man pages and https://space.sh for more info.

$_USAGE

          -f  YAML file to load, relative or absolute path, defaults to: ./Spacefile.yaml.
              -f and -m options define namespaces in where to look for nodes, for a given dimension of nodes.
              There can be maximum three namespaces and three dimensions. One namespace can have more than one dimension.
              Dimension two and three could be found from namespace one below the node in dimension 1.
              If only one dimension is given Space looks below "node/_friends/second" for a space separated set of lists that makes up the second dimension.
              The second dimension then uses second namespace if defined else first namespace.
              If two dimensions are given Space looks below "node/_friends/third" for a space separated list, each list object's "match" node is matched
              against the node in the second dimension, if match then the list below "nodes" makes up the third dimension.
              The third dimension then uses third namespace if defined else first namespace.
          -m  [giturl/][username]/reponame module to run.
              Direct access to run nodes in a module.
              Only the Space specific user gitlab.com/space-sh could be denoted using
              only reponame, then username is defaulted to space-sh and giturl is
              defaulted to https://gitlab.com/.
              All other users must specify domainname/username/reponame, for example
              ssh://gitlab.com/filippsen/somemodule.
              The protocol defaults to https.
          -M  [giturl/][username]/reponame module to load. (e.g. \"gitlab.com/blockie-org/amodule\")
              Clone and load modules. Separate multiple by space within quotes,
              or use multiple -M switches, one for each module.
              Usually used together with '-m' option to load a needed module for use
              with CMDWRAP environment variable.
              Example: space -m dropalot -M ssh -e CMDWRAP=SSH_WRAP -e sshhost=1.2.3.4
          -e  environment variable to forcefully apply/overwrite before parsing the YAML.
              -e var1="value1".
              Use one -e for each variable.
              To unset a variable use -evar1='!unset'
          -p  preprocess variable to set before preprocessing.
              -p inventory=staging.
              Use one -p for each variable.
          -v  verbosity level, 0 = off, 1 = error, 2 = warning, 3 = info, 4 = debug.
              Default is 2. Outputs to stderr.
          -d  dry run. Will echo the Bash command line computed instead of running it.
          -l  list nodes. Do not run anything, only output the nodes matched.
          -k  Check modules against the ban list. 0 = off, 1 = accept unknown modules
              but not banned modules, 2 = require module to be known and not banned.
              Default = 1.
          -K  Verify module Git HEAD signature using GPG. 0 = off,
              1 = accept moderate trust, 2 = only accept full trust signatures.
              Default = 1.
          -S  Allow HTTPS fallback for downloading modules using curl or wget when git is not available.
          -h  help, show Space usage or help on specific node.
          node(s) Pattern of one or many nodes to run.
              If no node path is given the root node "/" is implied.
              If node path(s) are given but none matches then Space aborts.
              A node pattern is defined after a namespace (-f/-m) and then belongs to that namespace.
              Nodes support regular expressions to run multiple nodes in sequence.
              Ex: "/west/.*" will match all nodes below /west/,
                  "/we.*/ will match /west/ and /web/ nodes.
                  When using asterisk make sure you use quotes so that
                  Bash will not expand that before passing it to Space as arguments.
                  /we{st,b}/ without quotes will get expanded by Bash as two arguments
                  /west/ and /web/ that are passed to Space, which is cool of that is what you meant.
          -V  show Space version information
          -a  All. Adds a ".*" to the node it suffixes, to match all it's nodes below.
          -C  caching level, 0 = off, 1 = on (default), 2 = regenerate cache.
          -B  Set to force to run modules in Bash. Normally Bash dependency depends
              on module script files ending in .bash instead of .sh.
          -U  Update module(s). Performs a Git pull on matched module(s) then quit.
              Space will update repositories both in local space_modules and also in shared space_modules directories.
              -U ""    means update all modules.
              -U "ssh" means update gitlab.com/space-sh/ssh.
              -U "gitlab.com/blockie-org/ssh" means update gitlab.com/blockie-org/ssh repository.
              -U "space-sh/.*" means update every module for the space-sh user on gitlab.com.
          -X  Outputs debug information.
              1 = preprocessed YAML result, 2 = YAML parsed to Bash, 3 = YAML loaded from Bash (retransformed), 4 = eval code
          -g  Enable graphical user interface. Defaults to 0, disabled.

Examples:

# Load a module named "os" from the official Space repositories and run the node named "info"
space -m "os" /info/

# Load and run a local module and show description for its root node
space -f Spacefile.yaml / -h

_EOF
    printf "%s" "$_s" >&2
}

#==========
# _helpversion
#
# Outputs version information
#
# Expects:
#   _VERSION
#
#==========
_helpversion()
{
    local _s=
    IFS= read -d '' -r _s << _EOF
Space $_VERSION
_EOF
    printf "%s" "$_s" >&2
}

#==========
# _helpnode
#
# Outputs help on a node.
#
# Parameters:
#   $1: slash-separated path of node to show help for. The path must end with a slash. E.g. "/parent_node/node1/node2/"
#
# Expects:
#   nodes must be loaded prior to calling this function because copy and list operations rely on node variables already being defined
#
#==========
_helpnode()
{
    local _path=$1
    shift

    _print "$_path"

    local _str=
    _copy "_str" "${_path}_info/title"
    _print $'\t'"${_str//$'\n'/$'\n'$'\t'}"$'\n'
    _copy "_str" "${_path}_info/desc"
    if [ -n "$_str" ]; then
        _print $'\t'"${_str//$'\n'/$'\n'$'\t'}"$'\n'
    fi

    local _listItems=()
    _list "_listItems" "${_path}"
    local _item=
    if [ "${#_listItems[@]}" -gt 0 ]; then
        for _item in "${_listItems[@]}"; do
            _print "+ $_item"
        done
    fi
}

#========
# _transform_to_yaml
#
# Go thru the whole parsed and evaluated YAML structure and output it in YAML format.
#
# Parameters:
#   $1: slash-separated path to start at. Does NOT end with a slash.
#   $2: last node of given path
#   $3: indent spaces
#
# Expects:
#   nodes must be loaded prior to calling this function because copy and list operations rely on node variables already being defined
#
#========
_transform_to_yaml()
{
    local _path=${1-}
    shift || :
    local _node=${1-}
    shift || :
    local _indent=${1-}
    shift || :

    local _value=
    _copy "_value" "$_path"
    if [ -z "$_value" ]; then
        # No leaf, recurse it.
        if [ -n "$_node" ]; then
            printf "%s%s%s\n" "$_indent" "$_node" ":"
        fi
        local _keys=()
        _path="$_path/"
        _list "_keys" "$_path" "1" "1"
        local _key=
        if [ "${#_keys[@]}" -gt 0 ]; then
            for _key in "${_keys[@]}"; do
                if [ "$_path" = "/" ]; then
                    local _indent2=$_indent
                else
                    local _indent2="$_indent    "
                fi
                _transform_to_yaml "$_path$_key" "$_key" "$_indent2"
            done
        fi
    else
        # Is leaf.
        printf "%s%s%s%s\n" "$_indent" "$_node" ": " "${_value//$'\n'/\\n}"
    fi
}

#========
# _list
#
# List all nodes below a given node.
#
# Parameters:
#   $1: name of output array to append to
#   $2: slash-separated path, starts and ends with slash.
#   $3: include_hidden, set to "1" to include leaf nodes beginning with underscore.
#   $4: include leaf node, set to "1" to include leaf nodes.
#
# Expects:
#   _parsedyamlnodelist*
#   _YAML_NAMESPACE
#   _YAML_PREFIX
#
#========
_list()
{
    local _output=$1
    shift

    local _path=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    if [[ ! $_path =~ (^/.+/$)|(^/$) ]]; then
        _error "Malformed path ($_path) as argument to _list. Must start and end with a slash. Lonesome cowboy slashes are OK dough."
        return 1
    fi

    local _nodes=()
    _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}" "${_path}.*/" "${_includehidden}" "1" "${_includeleafs}"
    if [ "${#_nodes[@]}" -eq 0 ]; then
        eval "${_output}=()"
    else
        eval "${_output}=(\"\${_nodes[@]}\")"
    fi
}


#==========
# _copy
#
# Copy a YAML variable (leaf) to another variable by assignment.
#
# Parameters:
#   $1: the name of the variable to copy to.
#   $2: the slash-separated _path of the variable to copy. Does NOT end with slash.
#
# Expects:
#   _YAML_PREFIX
#   _YAML_NAMESPACE
#
#==========
_copy()
{
    local _var=$1
    shift

    local _path=$1
    shift

    _path=${_path//_/0a95}
    _path="${_YAML_PREFIX}${_YAML_NAMESPACE}${_path//\//_}"
    eval "$_var=\${$_path-}"
}

#==========
# _quicksort
#
# Quick sort an array of string and return output
#
# Integral parts of each line will be padded with zeroes
# for 10 digits. This is so that integral comparison
# makes sense in an ASCII comparable way. Otherwise
# "2 is greater than "10", etc, which is not what we want.
# However "0000000002" < "10", which gives us what we expect.
#
# Parameters:
#   $1: name of array of strings to sort
#   _quicksort_output: array where results are stored. This is expected to be defined by the caller
#
#==========
_quicksort()
{
    _quicksort_output=()

    # Early return and stop condition
    if [ $# -eq 0 ]; then
        return 0
    fi

    local str=''
    local _line1padded=''

    if [ "${_ALLOW_EXTERNAL}" = "1" ]; then
        local _arr=()
        for str in "$@"; do
            _sort_pad "_line1padded" "$str"
            _arr+=("$_line1padded $str")
        done
        while IFS=$'\n' read -r _line; do
            _quicksort_output+=("$_line")
        done < <(printf "%s\n" "${_arr[@]}" | sort | awk '{print $3" "$4}')
        return
    fi

    local _partition_a=()
    local _partition_b=()
    local _line2padded=''
    local _pivot=$1
    shift

    # A/B split
    for str in "$@"; do
        _sort_pad "_line1padded" "$str"
        _sort_pad "_line2padded" "$_pivot"

        if [[ "$_line1padded" > "$_line2padded" ]]; then
            _partition_b+=("$str")
        else
            _partition_a+=("$str")
        fi
    done

    # Recursion on A side
    if [ "${#_partition_a[@]}" -gt 0 ]; then
        _quicksort "${_partition_a[@]}"
        _partition_a=("${_quicksort_output[@]}")
    fi

    # Recursion on B side
    if [ "${#_partition_b[@]}" -gt 0 ]; then
        _quicksort "${_partition_b[@]}"
        _partition_b=("${_quicksort_output[@]}")
    fi

    # Merge results
    _quicksort_output=()
    if [ "${#_partition_a[@]}" -gt 0 ]; then
        _quicksort_output+=("${_partition_a[@]}")
    fi
    _quicksort_output+=("$_pivot")
    if [ "${#_partition_b[@]}" -gt 0 ]; then
        _quicksort_output+=("${_partition_b[@]}")
    fi
}


#==========
# _sort_pad
#
# Helper function for comparison routines to pad number parts of string to 10 digits.
# Example: "1" padded turns into "0000000001"
#
# Parameters:
#   $1: name of variable to store result in.
#   $2: string to zero pad to 10 digits.
#
#==========
_sort_pad()
{
    local _output=$1
    shift

    local _s=$1
    shift

    local _s2="" _tmp=""
    while [[ $_s =~ ([^0-9.]*)([0-9]+)(.*) ]]; do
        _tmp=$(printf "%010d" "${BASH_REMATCH[2]}")
        _s2=$_s2${BASH_REMATCH[1]}$_tmp
        _s=${BASH_REMATCH[3]}
    done
    _s2=$_s2$_s
    eval "$_output=\$_s2"
}

#=============
# _source_added
#
# Source all sh/bash files added so far with _source and then resets the list.
#
# Expects:
#   _SOURCE_FILES
#
#=============
_source_added()
{
    local _file=''
    local _i=0
    while [ "$_i" -lt "${#_SOURCE_FILES[@]}" ]; do
        _file=${_SOURCE_FILES[$_i]}
        _source_file "${_file}"
        [ "$?" -gt 0 ] && return 1
        _i=$(( _i + 1 ))
    done
    unset _file _i
    _SOURCE_FILES=()    # Reset the list.
}

#=============
# _source
#
# Add a file to be sourced later, before execution.
#
# Parameters:
#   $1: file name
#
# Expects:
#   _SOURCE_FILES
#
#=============
_source()
{
    local _filename=$1
    shift

    if [ "${_filename##*.}" = "bash" ]; then
        _FORCE_BASH="1"
    fi

    _SOURCE_FILES+=("$_filename")
}

#==========
# _source_file
#
# Source a file
#
# Parameters:
#   $1: file path(s), relative or absolute.
#
# Expects:
#   _SOURCE_FILES_TOTAL
#
#==========
_source_file()
{
    local _filepaths=$1
    shift

    local _filepath=''
    for _filepath in $_filepaths; do
        if [ ! -f "$_filepath" ]; then
            _error "Could not source file \"$_filepath\". Try to run space using -C0 flag to invalidate the cache and have modules cloned again if they were removed."
            return 1
        fi
        local _i=
        for ((_i=0; _i<${#_SOURCE_FILES_TOTAL[@]}; _i+=1 )); do
            if [[ $_filepath == "${_SOURCE_FILES_TOTAL[$_i]}" ]]; then
                continue 2
            fi
        done
        unset _i
        _debug "Source file \"$_filepath\""
        local _status=0
        trap '_status=$?; trap - ERR;' ERR
        # DIR is a "global" variable which could be used to get the directory
        # for the current file being sourced.
        # shellcheck disable=2034
        local DIR=${_filepath%/*}
        # shellcheck disable=1090
        . "$_filepath"
        unset DIR
        trap - ERR
        [ "$_status" -gt 0 ] && { _error "Could not source script ${_filepath}. Syntax error?"; return 1; }
        _SOURCE_FILES_TOTAL+=("${_filepath}")
    done
}

#==========
# _parse_yaml
#
# Parse well formatted YAML document into Bash variables.
#
# Parameters:
#   $1: name of variable to read YAML from.
#   $2: name of array variable to append to.
#   $3: name of array to use as completion array.
#
# Expects:
#   _SPACEGAL_EOF_TAG
#   array items must be indented at least one space from its parents
#
#==========
_parse_yaml()
{
    local _invarname=$1
    shift
    local _outvarname=$1
    shift
    local _outcompletionvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${${_invarname}[@]}\")"

    local _numrows=${#_allrows[@]}
    local _rowindex=0
    local _lastindent=0 _nodes=("/") _lastkey="" _prefix="/"
    local _indent=0 _rowtype='' _key='' _readahead=() _nextindent=0
    local _arrayextraindent=0
    local _output=''

    while _yaml_get_next 0;
    do
        # Set node prefix for changed indentation level.
        if [ "$_indent" -gt "$_lastindent" ]; then
            # Increasing indentation level, add to prefix.
            _prefix="$_prefix$_lastkey/"
            _nodes[$_indent]=$_prefix
        elif [ "$_indent" -lt "$_lastindent" ]; then
            # Decreasing indentation level, fallback to earlier prefix.
            _prefix=${_nodes[$_indent]}
        fi
        _lastindent=$_indent
        case "${_rowtype}" in
            leaf) # A regular key value row.
                local _varname=$_prefix$_key

                # Add to node name completion list.
                local _completionname="${_varname}/"
                local _item=
                # Break down the path and add each sub path as completion name, early quit when
                # a path is found since we are guaranteed all the remaining sub paths are already added.
                while :; do
                    eval '
                    for _item in "${'$_outcompletionvarname'[@]-}"; do
                        if [[ $_item == "${_completionname} 0" || $_item == "${_completionname} 1" ]]; then
                            break 2
                        fi
                    done
                    '
                    if [ "$_completionname" = "${_varname}/" ]; then
                        # The leaf node
                        eval "$_outcompletionvarname+=(\"${_completionname} 1\")"
                    else
                        eval "$_outcompletionvarname+=(\"${_completionname} 0\")"
                    fi
                    if [ $_completionname = "/" ]; then
                        break
                    fi
                    _completionname=${_completionname%/*/}/
                done
                unset _item
                unset _completionname

                _varname=${_varname//_/0a95}
                _varname=${_varname//\//_}
                if ((${#_readahead[@]} == 0)); then
                    # Simulate multiline value for the single line
                    if [[ ${value//\ } != "" ]]; then
                        _readahead[0]="$value"
                    else
                        _readahead[0]=""
                    fi
                else
                    # Check if to collapse new lines.
                    if [[ ${value:0:1} == ">" ]]; then
                        local _s=${_readahead[@]}
                        _readahead=("$_s")
                    fi
                fi
                eval "$_outvarname+=(\"\$_varname\")"
                local _line=
                for _line in "${_readahead[@]}"; do
                    _output=$(printf "%s" "$_line")
                    eval "$_outvarname+=(\"\$_output\")"
                done
                eval "$_outvarname+=(\"\$_SPACEGAL_EOF_TAG\")"
                _lastkey=$_key
                ;;
            object) # Start of new object
                _lastkey=$_key
                ;;
            arrayobject)
                # New array object begins
                # Output key index at given indent
                local _i=$(($_indent+$_arrayextraindent))
                local _varname="_index_count${_prefix//\//_}"
                local _count=${!_varname-0}
                eval "local $_varname=$(($_count+1))"
                local _subrows=()
                # Reinsert the key value of first line to have it handled as a normal leaf.
                if [ -z "$_key" ]; then
                    _output=$(printf "%*s%s" $_i "" "$_count: $value")
                else
                    _output=$(printf "%*s%s" $_i "" "$_key: $value")
                fi
                _subrows+=("$_output")
                if ((${#_readahead[@]} > 0)); then
                    _i=$(( _i + 4 ))
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        _output=$(printf "%*s%s" $_i "" "$_line")
                        _subrows+=("$_output")
                    done
                fi
                _allrows=("${_allrows[@]:0:$_rowindex}" "${_subrows[@]}" \
                    "${_allrows[@]:$_rowindex:$_numrows-$_rowindex}")
                ((_numrows+=${#_subrows[@]}))
                _lastkey=$_count
                ;;
        esac
    done
}

#==========
# _pp_yaml
#
# Preprocess YAML
#
# Parameters:
#   $1: name of variable to store result in.
#   $2: filepath to read YAML from.
#   $3: filter
#   $4: subdoc
#   $5-x: preprocess variable value assigned to @1, etc.
#
# Expects:
#   _yamlfilelist
#   _SPACEGAL_EOF_TAG
#   _CACHE_LEVEL
#
# Returns:
#   1 if YAML file not found.
#   2 if recursion error occurred.
#   3 if failed to clone modules 
#   4 if assertion failure was triggered.
#
#==========
_pp_yaml()
{
    local _varname=$1
    shift
    local _filepath=$1
    shift
    local _filter=${1:-/}
    shift || :
    local _inheritedindent=${1:-0}
    shift || :
    local _inheritedprefix=${1-/}
    shift || :
    # Read preprocess variables
    local _count=1
    while [ ${#@} -gt 0 ]; do
        eval "local _PP_$_count=\$1"
        shift
        _count=$(( _count + 1 ))
    done
    if [[ ${_filter:0:1} != "/" ]]; then
        _filter="/$_filter"
    fi
    if [[ ${_filter: -1} != "/" ]]; then
        _filter="$_filter/"
    fi
    local _subdoc=()
    if [[ -n ${_readahead[@]-} && (( ${#_readahead[@]} > 0 )) ]]; then
        _subdoc=("${_readahead[@]}")  # Inherited from recursive parent.
    fi

    # Look at the filepath if it's relative
    # and search through paths to find the file.
    if [[ ${_filepath:0:1} != "/" ]]; then
        local _dir=
        while :; do
            # Check path relative to current YAML file's dir _PP_DIR.
            if [ -f "$_PP_DIR/$_filepath" ]; then
                _filepath=$_PP_DIR/$_filepath
                break
            fi
            for _dir in ${_INCLUDEPATH[@]}; do
                if [ -f "$_dir/$_filepath" ]; then
                    _filepath=$_dir/$_filepath
                    break
                fi
            done
            break
        done
    fi

    # Check so that the YAML file exists.
    if [ ! -e "$_filepath" ]; then
        return 1
    fi

    # Preprocess variable that points to the dir of the YAML file being processed.
    local _PP_DIR=${_filepath%/*}

    local _allrows=() _rowindex=0
    IFS=$'\n' read -d '' -r -a _allrows < "$_filepath"
    local _numrows=${#_allrows[@]}

    if [[ ! $_yamlfilelist =~ "$_filepath " ]]; then
        _yamlfilelist="${_yamlfilelist}$_filepath "
    fi

    local _lastindent=0 _filterindent=-1 _nodes=("/") _lastkey="" _prefix="/"
    local _indent=0 _rowtype='' _key='' _readahead=() _nextindent=0
    local _includefile='' _includefilter='' _includevariables=''
    local _arrayextraindent=0 _output=''
    while _yaml_get_next 1;
    do
        if [ "$_rowtype" = "" ]; then
            continue;
        fi

        # Set node prefix for changed indentation level.
        if [ "$_indent" -gt "$_lastindent" ]; then
            # Increasing indentation level, add to prefix.
            _prefix=$_prefix$_lastkey\/
            _nodes[$_indent]=$_prefix
        elif [ "$_indent" -lt "$_lastindent" ]; then
            # Decreasing indentation level, fallback to earlier prefix.
            _prefix=${_nodes[$_indent]}
        fi
        _lastkey=$_key
        _lastindent=$_indent

        # We use this to recognize @includes as immediate child nodes to get the
        # subdoc insertion correctly done for multiple includes.
        local _immediatechild=0

        # Check if filtering wants this.
        if [[ "$_prefix$_key" =~ ^$_filter ]]; then
            # Filter matched, if first time save indent as the base level indent.
            if [ "$_filterindent" -eq -1 ]; then
                _filterindent=$_indent
            fi
            if [[ $_rowtype != "assign" && $_rowtype != "debug" && $_rowtype != "clone" && ${_key:0:1} != "_" && "$_prefix$_key/" =~ ^${_filter}([a-zA-Z0-9_])+/$ ]]; then
                _immediatechild=1
            fi
            if [[ $_rowtype == "include" && "$_prefix$_key/" =~ ^${_filter}/$ ]]; then
                _immediatechild=2

            fi
            # Check if we are on an immediate child to the filtered match and
            # that it is an object node, if so inject subdoc if given.
            if [[ $_immediatechild == 1 && ${#_subdoc[@]} -gt 0 ]]; then
                local _subrow= _subrows=()
                for _subrow in "${_subdoc[@]}"; do
                    local _i=$(($_indent+$_nextindent))
                    _subrow=$(printf "%*s%s" $_i "" "$_subrow")
                    _subrows+=("$_subrow")
                done
                _allrows=("${_allrows[@]:0:$_rowindex}" "${_subrows[@]}" \
                    "${_allrows[@]:$_rowindex:$_numrows-$_rowindex}")
                ((_numrows+=${#_subrows[@]}))
            fi
        else
            _filterindent=-1
            continue
        fi

        local _actualindent=$(($_indent-$_filterindent+$_inheritedindent))
        # Here we need to do the postponed preprocess variable substitution of @{parent}.
        local _parentpath=
        _parentpath=$_inheritedprefix${_prefix#$_filter}
        _key=${_key//_PP_PARENTPATH/$_parentpath}
        value=${value//_PP_PARENTPATH/$_parentpath}

        local _s=${_parents[$_actualindent]-}  # Get preprocess variable "parent".
        _key=${_key//_PP_PARENT/$_s}
        value=${value//_PP_PARENT/$_s}
        unset _s

        case "${_rowtype}" in
            assign) # Assign a preprocess variable
                local _ppkey=_PP_$_key
                local _s="local ${_ppkey} ; read -d '' -r ${_ppkey} << $_SPACEGAL_EOF_TAG"$'\n'"${value}"$'\n'"$_SPACEGAL_EOF_TAG"$'\n'":"$'\n'
                eval "$_s"
                unset _s _ppkey
                ;;
            prompt) # Prompt a value for a pp variable.
                local _ppkey=_PP_$_key
                local _s=$(prompt "$value")
                eval "$_ppkey=\$_s"
                unset _s _ppkey
                ;;
            include) # Do an include of a file
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                if [[ $_immediatechild == 2 && ${#_readahead[@]} == 0 ]]; then
                    if (( ${#_subdoc[@]} > 0 )); then
                        _readahead=("${_subdoc[@]}")
                    fi
                fi
                _pp_yaml "$_varname" "${_includefile:-$_filepath}" "$_includefilter" $_i "${_parentpath}" $_includevariables
                local _status=$?
                if [ $_status -eq 1 ]; then
                    _error "[$_filepath: $(($_rowindex))] Could not find file \"$_includefile\"."
                    return 2
                elif [ $_status -gt 1 ]; then
                    return $_status
                fi
                ;;
            clone) # Clone module(s)
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                # _retrepo variable is populated by _module_clone
                local _retrepo='' _repos="" _v=
                for _v in $value; do
                    _module_clone "_retrepo" "$_v"
                    local _status=$?
                    if [ $_status -gt 0 ]; then
                        _error "[$_filepath: $(($_rowindex))] Could not clone module repository \"$value\"."
                        return 3
                    fi
                    if [ -n "$_retrepo" ]; then
                        _repos="$_repos $_retrepo"
                    fi
                done
                if [ -n "$_repos" ]; then
                    _output=$(printf "%*s%s" $_i "" "_source: $_repos")
                    eval "$_varname+=(\"\$_output\")"
                fi
                ;;
            debug) # Output debug info
                _debug "@debug: $value"
                ;;
            assert) # Do assertion
                _debug "@assert: $value"
                if [[ $value =~ (.*)\ (.*) ]]; then
                    local _fn=${BASH_REMATCH[1]}
                    local _val=${BASH_REMATCH[2]}
                    if [[ ${_val:0:1} == "@" ]]; then
                        eval "_val=\${_PP_${_val:1}-}"
                    elif [[ ${_val:0:1} == "$" ]]; then
                        eval "_val=\${${_val:1}-}"
                    fi
                    if [ "$_fn" = "nonempty" ] && [ -z "$_val" ]; then
                        _error "Assertion failed: $value: $_filepath:$_rowindex"
                        return 4
                    fi
                fi
                ;;
            cache) # Change cache behaviour
                _debug "@cache: $value"
                _CACHE_LEVEL=$value
                ;;
            leaf) # A regular key value row.
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                if [ "${#value}" -eq 0 ]; then
                    _output=$(printf "%*s%s" $_i "" "$_key:")
                else
                    _output=$(printf "%*s%s" $_i "" "$_key: $value")
                fi
                eval "$_varname+=(\"\$_output\")"
                if ((${#_readahead[@]} > 0)); then
                    _i=$(( _i + 4 ))
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        _output=$(printf "%*s%s" $_i "" "$_line")
                        eval "$_varname+=(\"\$_output\")"
                    done
                fi
                ;;
            object) # Start of new object
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                local _i2=$(($_i+$_nextindent))
                _output=$(printf "%*s%s" $_i "" "$_key:")
                eval "$_varname+=(\"\$_output\")"
                # Set the parent node for the sub nodes following
                _parents[$_i2]=$_key
                ;;
            arrayobject) # Array item object start
                # Output key index at given indent, also readahead.
                local _i2=$(($_indent-$_filterindent+$_inheritedindent))
                local _i3=$(($_arrayextraindent-1))
                local _i4=$(($_i2+$_i3+4))
                if [ -z "$_key" ]; then
                    # index item
                    _output=$(printf "%*s-%*s%s" $_i2 "" $_i3 "" "$value")
                elif [ -n "$value" ]; then
                    _output=$(printf "%*s-%*s%s" $_i2 "" $_i3 "" "$_key: $value")
                else
                    _output=$(printf "%*s-%*s%s" $_i2 "" $_i3 "" "$_key:")
                fi
                eval "$_varname+=(\"\$_output\")"
                if ((${#_readahead[@]} > 0)); then
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        _output=$(printf "%*s%s" $_i4 "" "$_line")
                        eval "$_varname+=(\"\$_output\")"
                    done
                fi
                ;;
        esac
        unset _parentpath
    done
}

#==========
# _yaml_get_row
#
# MACRO helper to get a single row from the feed
# and substitute preprocess variables in that row.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: row index
#   $2: preprocessing switch
#
# Expects:
#   _allrows
#   _PP_${value}
#
#==========
_yaml_get_row()
{
    local _index=$1
    shift
    local _dopreprocess=$1
    shift

    _row=${_allrows[$_index]}
    while [[ $_dopreprocess == "1" && $_row =~ ^(.*)\@\{([\ @a-zA-Z0-9_:-]+)\}(.*)$ ]]; do
        # Substitute preprocessed variable
        local _left=${BASH_REMATCH[1]}
        local _s=${BASH_REMATCH[2]}
        local _right=${BASH_REMATCH[3]}
        if [[ $_s =~ ([a-zA-Z0-9_]+)(:?\-)(.+) ]]; then
            local _substvar=_PP_${BASH_REMATCH[1]}
            local _op=${BASH_REMATCH[2]}
            local _substvar2=${BASH_REMATCH[3]}
            if [[ ${_substvar2:0:1} == "@" ]]; then
                _substvar2=_PP_${_substvar2:1}
                local _substvalue2=${!_substvar2-}
            else
                local _substvalue2=$_substvar2
            fi
            local _substvalue=
            if [ "$_op" = "-" ]; then
                _substvalue=${!_substvar-$_substvalue2}
            else
                _substvalue=${!_substvar:-$_substvalue2}
            fi
        else
            local _substvar=_PP_$_s
            local _substvalue=${!_substvar-}
        fi

        _row=${_left}${_substvalue}${_right}
    done
}

#==========
# _yaml_get_next
#
# MACRO helper to _pp_yaml and _parse_yaml.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: preprocessing switch
#
# Expects:
#   _rowindex
#   _numrows
#
# Returns:
#   0: if there are more rows to process
#   1: no more rows to process
#
#==========
_yaml_get_next()
{
    if [ "$_rowindex" -ge "$_numrows" ]; then
        return 1
    fi

    local _dopreprocess=${1}
    shift

    # This particular preprocess value will have its substitution postponed because
    # we do not know the correct parent node already.
    local _PP_PARENT=_PP_PARENT
    local _PP_PARENTPATH=_PP_PARENTPATH

    local _row=
    _yaml_get_row "$_rowindex" "$_dopreprocess"
    _rowindex=$(( _rowindex + 1 ))

    _key=""
    value=""
    _rowtype=""
    _readahead=()

    if [[ $_row =~ ^([\ ]*)(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        local _op=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _includevariables=
        if [[ $value =~ ^(.*)[\ ]*\|[\ ]*(.*) ]]; then
            _includefile=${BASH_REMATCH[1]}
            local _s=${BASH_REMATCH[2]}
            if [[ $_s =~ (.*)\((.*)\)$ ]]; then
                _includefilter=${BASH_REMATCH[1]}
                _includevariables=${BASH_REMATCH[2]}
            else
                _includefilter=$_s
            fi
        else
            _includefile=$value
            _includefilter=""
        fi
        _yaml_get_multiline 0
        # Check if $_includefile is a module
        if [[ -n $_includefile && ! $_includefile =~ \.yaml$ ]]; then
            _module_find_yaml "$_includefile" "_includefile"
        fi
        if [ "$_op" = "-" ] && [ ! -f "$_includefile" ]; then
             # Ignore missing yaml file.
            _rowtype=""
        else
            _rowtype="include"
        fi
    elif [[ $_row =~ ^([\ ]*)(\@clone)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="clone"
    elif [[ $_row =~ ^([\ ]*)(\@debug)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="debug"
    elif [[ $_row =~ ^([\ ]*)(\@assert)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="assert"
    elif [[ $_row =~ ^([\ ]*)(\@cache)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="cache"
    elif [[ $_row =~ ^([\ ]*)(\@prompt)[\ ]*:(-?)[\ ]+([^\ ]+)[\ ](.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        local _op=${BASH_REMATCH[3]}
        _key=${BASH_REMATCH[4]}
        value=${BASH_REMATCH[5]}
        if [ "$_op" = "-" ]; then
            # @prompt:- means only prompt on variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        fi
        _rowtype="prompt"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)\ (.*) ]]; then
        # Assign preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [ "$_op" = ":-" ]; then
            # @var:- means only assign variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":+" ]; then
            # @var:+ means only assign variable if it already has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":" ]; then
            # @var: means always assign to variable.
            # Fall through.
            :
        fi
        value=${BASH_REMATCH[4]}
        _rowtype="assign"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)$ ]]; then
        # Unset a preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [ "$_op" = ":-" ]; then
            # @var:- means only unset variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":+" ]; then
            # @var:+ means only unset variable if it has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":" ]; then
            # @var: means always unset variable.
            # Fall through.
            :
        fi
        eval "unset _PP_$_key"
    elif [[ $_row =~ ^([\ ]*)([a-zA-Z0-9_]+)[\ ]*:[\ ]?(.*) ]]; then
        # Key value or new object/array row
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        value=${BASH_REMATCH[3]}
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            _rowtype="leaf"
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        else
            value=""
            # This node has no value, we must figure out if it's
            # an empty leaf or an object.

            # Find out the nextindent level for an object row.
            local _yamlindent=0
            _yaml_find_nextindent
            if [ "$_yamlindent" -gt "$_indent" ]; then
                _rowtype="object"
            else
                _rowtype="leaf"
            fi
            unset _yamlindent
        fi
    elif [[ $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:[\ ]+(.*) ||
             $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:($) ]]; then
        # Array item with child object.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=$((${#BASH_REMATCH[2]}+1))
        _key=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        fi
    elif [[ $_row =~ ^([\ ]*)\-[\ ]+(.*) || $_row =~ ^([\ ]*)\-($) ]]; then
        # Array index item with only value.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=0
        _key=
        value=${BASH_REMATCH[2]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        fi
    else
        # Unknown row
        :
    fi
    return 0
}

#==========
# _yaml_find_nextindent
#
# Peek into object for the given indentation level.
# It relies on caller-defined local variables.
#
# Expects:
#   _allrows
#   _indent
#   _numrows
#   _rowindex
#
#==========
_yaml_find_nextindent()
{
    local _i=$_rowindex
    _nextindent=4  # Default value
    _yamlindent=0

    while :; do
        if [ "$_i" -ge "$_numrows" ]; then
            return
        fi
        local _peekrow=${_allrows[$_i]}
        #_error PEEK $_peekrow
        _i=$(( _i + 1 ))
        if [[ $_peekrow =~ ^([\ ]*)\-([\ ]+)[a-zA-Z0-9_]+[\ ]*:[\ ]*.* ]]; then
            _yamlindent=$((${#BASH_REMATCH[1]}+${#BASH_REMATCH[2]}+1))
            break
        elif [[ $_peekrow =~ ^([\ ]*)([a-zA-Z0-9_@]+)[\ ]*:[\ ]*(.*) ]]; then
            _yamlindent=${#BASH_REMATCH[1]}
            break
        elif [[ $_peekrow =~ ^([\ ]*)\-[\ ]*$ ]]; then
            _yamlindent=$((${#BASH_REMATCH[1]}))
            break
        fi
    done
    if [ "$_yamlindent" -gt "$_indent" ]; then
        _nextindent=$(($_yamlindent-$_indent))
    fi
}

#==========
# _yaml_get_multiline
#
# MACRO helper function.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: preprocessing switch
#
# Expects:
#   _indent
#   _numrows
#   _rowindex
#
#==========
_yaml_get_multiline()
{
    local _dopreprocess=$1
    shift

    if [ "$_rowindex" -ge "$_numrows" ]; then
        return
    fi
    local _row=
    _yaml_get_row "$_rowindex" "$_dopreprocess"
    if [[ $_row =~ ^([\ ]+)([^\ ].*) ]]; then
        local _subindent=${#BASH_REMATCH[1]}
        local _subvalue=${BASH_REMATCH[2]}
        if [ "$_subindent" -gt "$_indent" ]; then
            _readahead+=("$_subvalue")
            while :; do
                _rowindex=$(( _rowindex + 1 ))
                if [ "$_rowindex" -ge "$_numrows" ]; then
                    break
                fi
                _yaml_get_row "$_rowindex" "$_dopreprocess"
                if [[ $_row =~ ^([\ ]+)([^\ ].*) || $_row =~ ^([\ ]{$_subindent})(.*) ]]; then
                    local _subindent2=${#BASH_REMATCH[1]}
                    if [ "$_subindent2" -lt "$_subindent" ]; then
                        break
                    fi
                    _subvalue=$(printf "%*s%s" $(($_subindent2-$_subindent)) "" \
                        "${BASH_REMATCH[2]}")
                    _readahead+=("$_subvalue")
                else
                    break
                fi
            done
        fi
    fi
}

#==================
# clone
#
# Clone modules repositories,
# and add the sh/bash file for sourcing.
#
# Parameters:
#   $@: module name(s) to clone
#
# Expects:
#   CWD
#   _MODULES_SHARED
#
# Returns:
#   0: success
#   1: failure
#
#==================
clone()
{
    local _modules="${@}"
    shift

    # Cloning will always be to $_INCLUDEPATH[1],
    # so here we set that to be in the shared area.
    local _INCLUDEPATH=($CWD/space_modules $_MODULES_SHARED $CWD)
    local _loadmod=
    for _loadmod in ${_modules}; do
        local _sourcefile= _rf=
        _module_clone "_sourcefile" "$_loadmod"
        local _status=$?
        if [ $_status -gt 0 ]; then
            _error "Could not clone module repository \"$_loadmod\"."
            return 1
        fi
        unset _status
        if [[ -n $_sourcefile ]]; then
            _source "$_sourcefile"
        else
            _debug "No sh/bash file found when loading module $_loadmod"
        fi
        unset _sourcefile
    done
    return 0
}

#==========
# _module_clone
#
# Clone a module Git repository.
#
# Parameters:
#   $1: variable name to put the module name which is to be "_sourced".
#   $2: modulename inclusive optional Git commit: [https://[gitlab.com/]][username/]repo[:v1.1]
#
# Returns:
#   0 on success, non-zero otherwise
#
#==========
_module_clone()
{
    local _repo=$1
    shift

    local _mod=$1
    shift

    local _protocol=
    local _domain=
    local _domainuser=
    local _username=
    local _reponame=""
    local _commit=
    local _str_commit=
    local _repofullname=
    _extract_repo_parts "${_mod}"
    (( $? > 0 )) && return 1

    local _repodir=$_domain/$_username/$_reponame$_str_commit

    # Check to see of the repo is already existing.
    local _dir=
    for _dir in ${_INCLUDEPATH[@]}; do
        if [[ -d $_dir/$_repodir ]]; then
            break
        fi
        _dir=
    done

    if [[ -z $_dir ]]; then
        # Directory does not exist

        # Check so that we are not bash auto completing
        if [[ $_BASH_COMPLETION != "0" ]]; then
            return 1
        fi

        _dir=${_INCLUDEPATH[1]}/$_repodir
        if [[ ! -z $_domainuser ]]; then
            _domainuser="$_domainuser@"
        elif [[ $(_to_lower $_protocol) == "ssh" ]]; then
            _domainuser="git@"
        fi
        local _giturl=$_protocol://$_domainuser$_domain/$_username/$_reponame

        # Check the module banlist.
        _module_check_banlist "${_giturl}:${_commit}"
        (( $? > 0 )) && return 1

        if ! command -v git >/dev/null; then
            # Git is not installed, check if we could use fallback.
            local _d=$(_to_lower $_domain)
            local _p=$(_to_lower $_protocol)
            if [[ $_p != "https" ]]; then
                _error "Could not clone module since Git is not installed."
                return 1
            fi
            if [[ $_HTTPBIN == "" ]]; then
                _error "Could not clone module since Git is not installed. Nor curl or wget is available as fallback."
                return 1
            fi
            if [[ $_d == "github.com" || $_d == "gitlab.com" || $_d == "bitbucket.org" ]]; then
                if [[ $_SECURITY_ALLOW_HTTPS_FALLBACK != "1" ]]; then
                    _error "Git is not installed. We could however try to download the module Git repository over HTTPS if you provide the -S switch."$'\n'"Note that this module will not then be possible to update, so only use this for special cases when you cannot install and use Git."
                    return 1
                else
                    # Fetch tarball from Git host into /tmp, unpack it and move it to the right place.
                    _info "Downloading tarball \"$_giturl\" over HTTPS using: $_HTTPBIN."
                    # EXTERNAL: mktemp, tar, curl/wget
                    local _tmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')
                    (( $? > 0 )) && { _error "Could not mktemp."; return 1; }
                    local _status_code=0
                    local _versionurl="$_giturl/raw/master/stable.txt"
                    if [ "$_HTTPBIN" = "curl" ]; then
                        _status_code=$($_HTTPBIN -sL --write-out %{http_code} --silent --output "$_tmpdir/stable.txt" $_versionurl)
                        if [ "$_status_code" -eq 200 ]; then
                            # EXTERNAL: cat
                            _commit=$(cat "$_tmpdir/stable.txt")
                        else
                            _commit="master"
                        fi
                        rm "$_tmpdir/stable.txt"
                    elif [ "$_HTTPBIN" = "wget" ]; then
                        _status_code=$($_HTTPBIN -O "$_tmpdir/stable.txt" $_versionurl)
                        if [ "$_status_code" -eq 0 ]; then
                            # EXTERNAL: cat
                            _commit=$(cat "$_tmpdir/stable.txt")
                        else
                            _commit="master"
                        fi
                        rm "$_tmpdir/stable.txt"
                    fi
                    if [[ $_d == "github.com" ]]; then
                        local _durl="$_giturl/archive/${_commit}.tar.gz"
                    elif [[ $_d == "gitlab.com" ]]; then
                        local _durl="$_giturl/repository/archive.tar.gz?ref=${_commit}"
                    elif [[ $_d == "bitbucket.org" ]]; then
                        local _durl="$_giturl/get/${_commit}.tar.gz"
                    fi
                    {
                        if [[ $_HTTPBIN == "curl" ]]; then
                            $_HTTPBIN -sL $_durl
                        elif [[ $_HTTPBIN == "wget" ]]; then
                            $_HTTPBIN -q -O- $_durl
                        fi
                    } | tar -xvzf - -C $_tmpdir
                    (( $? > 0 )) && { _error "Could not fetch and unpack tarball for $_giturl."; return 1; }
                    # EXTERNAL: find
                    local _tmpdir2=$(find $_tmpdir -maxdepth 1 -mindepth 1)
                    # EXTERNAL: mkdir
                    mkdir -p ${_dir%/*}
                    # EXTERNAL: mv
                    mv $_tmpdir2 $_dir
                fi
            else
                _error "Could not clone module since Git is not installed. Only gitlab.com/github.com/bitbucket.org work with curl/wget fallback."
                return  1
            fi
        else
            # EXTERNAL: git, rm

            # Expect url NOT to have the .git extension at this point. Append it now.
            # Some host providers do support git cloning without .git at the end. Don't count on it.
            # See also: "GIT URLS" in 'man git-clone'
            _giturl="$_giturl".git

            _info "Git clone $_giturl into $_dir"
            git clone -q "$_giturl" "$_dir" 2>&1
            if [[ $? != "0" ]]; then
                _error "Could not Git clone $_giturl."
                return 1
            fi
            cd "$_dir"
            if [ "$?" != "0" ]; then
                _error "Could not enter directory: $_dir"
                return 1
            fi
            if [ "$_commit" = "" ]; then
                if [ -f "./stable.txt" ]; then
                    # EXTERNAL: cat
                    _commit=$(cat "./stable.txt")
                    _info "Set to latest stable version: $_commit"
                else
                    _commit="master"
                    _info "Set to current version: $_commit"
                fi
            else
                _info "Set to version: $_commit"
            fi
            git checkout "$_commit" > /dev/null 2>&1
            if [[ $? != "0" ]]; then
                _error "Could not Git checkout $_commit of $_repofullname. Will delete directory."
                ( rm -rf "$_dir" >&2 )
                return 1
            fi
            if [[ -f ${_dir}/.gitmodules ]]; then
                ( cd "$_dir" && git submodule init >&2 && git submodule update >&2 )
                if [[ $? != "0" ]]; then
                    _error "Could not perform Git submodule init && update. Is Perl installed?"
                    ( rm -rf "$_dir" >&2 )
                    return 1
                fi
            fi
            # Check the signature of the commit, if applicable.
            # TODO How should we actually do this?
            if [[ $_SECURITY_GPG_VERIFY_SIGNATURE != "0" ]]; then
                ( cd "$_dir" && git verify-commit HEAD >&2 )
                if [[ $? != "0" ]]; then
                    _security "Could not verify signature of Git repository: $_giturl."
                    ( rm -rf "$_dir" >&2 )
                    return 1
                fi
            fi
        fi
    else
        _dir=${_dir}/$_repodir
    fi

    # Check if sh/bash file to source does exist.
    local _f=""
    eval "$_repo="
    for _f in "$_dir/Spacefile.yaml"; do
        if [[ -f $_f ]]; then
            _f=${_f%.yaml}
            if [[ -f "${_f}.sh" ]]; then
                eval "$_repo=\${_f}.sh"
            elif [[ -f "${_f}.bash" ]]; then
                eval "$_repo=\${_f}.bash"
            fi
            break
        fi
    done

    return 0
}

#=============
# _extract_repo_parts
#
# Populate env variables
#
# Parameters:
#   $1: the module name
#
# Expects:
#   _domain
#   _domainuser
#   _username
#   _reponame
#   _commit
#   _str_commit
#   _repofullname
#
#=============
_extract_repo_parts()
{
    local _mod="${1}"
    shift

    _protocol="https"
    # Domain is only defaulted for the "space-sh" user.
    _domain=
    _domainuser=
    _username="space-sh"
    _reponame=""
    _commit=""
    _str_commit=
    _repofullname=

    # Extract protocol if given.
    if [[ $_mod =~ (.+)://(.*) ]]; then
        _protocol=${BASH_REMATCH[1]}

        #
        # Further check if the 'domain' part appears to be an IP address
        # Otherwise, try to capture the domain name into two parts:
        # [1] before and [2] after the expected dot, in order to provide meaningful error messages
        #
        local _domain_part=${BASH_REMATCH[2]}
        if [[ $_domain_part =~ ([0-9]{1,3}[\.]){3}[0-9]{1,3} ]]; then
            _debug "_extract_repo_parts: $_domain_part accepted"
        elif [[ $_domain_part =~ ^([-@:A-Za-z0-9]+)(\.)?([a-z]{2,3}(\.[a-z]{2,3})?)? ]]; then
            # Check if punctuation was provided then requires the extension
            if [[ -n ${BASH_REMATCH[2]} && -z ${BASH_REMATCH[3]} ]]; then
                _error "Expected domain extension: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
                return 1
            fi
        else
            _error "Malformed import name: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
            return 1
        fi
    fi

    # Extract "user@domain", if given, and the repo name.
    if [[ $_mod =~ (.+://)?([-@:A-Za-z0-9.]+)/ ]]; then
        # Domain provided
        _domain=${BASH_REMATCH[2]}

        # In case it is a name, not an IP, check if punctuation was provided
        # Require name extension for implicit protocol settings
        if [[ ! $_domain =~ ([0-9]{1,3}[\.]){3}[0-9]{1,3} ]] && \
           [[ $_domain =~ ^([-@:A-Za-z0-9]+)(\.)?([a-z]{2,3}(\.[a-z]{2,3})?)? ]]; then

            if [[ -n ${BASH_REMATCH[2]} && -z ${BASH_REMATCH[3]} ]]; then
                _error "Expected domain extension: $_domain Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
                return 1
            fi
        fi

        # Extract domainuser, if provided
        if [[ $_domain =~ (.+)[@](.+) ]]; then
            _domainuser=${BASH_REMATCH[1]}
            _domain=${BASH_REMATCH[2]}
        fi

        # Expect both username and reponame to have been provided
        if [[ $_mod =~ (.*://)?([-@:A-Za-z0-9.?]+)/([-A-Za-z0-9_]+)/([-A-Za-z0-9_:.]+) ]]; then
            _username=${BASH_REMATCH[3]}
            _reponame=${BASH_REMATCH[4]}
            # Remove .git extension if exists
            _reponame=${_reponame%.git}
        else
            _error "Expected username and reponame: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/$_mod\" \"space -m https://gitlab.com/$_mod\""
            return 1
        fi
    else
        # Domain not provided, expect username and/or reponame[:commit]
        if [[ $_mod =~ ([-A-Za-z0-9_]+)/([-A-Za-z0-9_:.]+) ]]; then
            _username=${BASH_REMATCH[1]}
            _reponame=${BASH_REMATCH[2]}
        elif [[ $_mod =~ ^([-A-Za-z0-9_:.]*) ]]; then
            _reponame=${BASH_REMATCH[1]}
        fi

        # Remove .git extension if exists
        _reponame=${_reponame%.git}

        if [[ $_username == "space-sh" ]]; then
            _domain="gitlab.com"
        else
            _error "Expected domain name for git url with explicit protocol set: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/$_mod\" \"space -m https://gitlab.com/$_mod\""
            return 1
        fi
    fi

    # Extract :commit from reponame
    if [[ $_reponame =~ (.+)[:](.+) ]]; then
        _reponame=${BASH_REMATCH[1]}
        _commit=${BASH_REMATCH[2]}
    fi
    if [[ $_protocol == "" || $_domain == "" || $_username == "" || $_reponame == "" ]]; then
        _error "Malformed import name: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
        return 1
    fi
    if [ -z "$_commit" ]; then
        # We skip commit name if it is empty
        _str_commit=""
    else
        _str_commit=":$_commit"
    fi
    _repofullname=$_username/$_reponame$_str_commit
}

#=============
# _module_check_banlist
#
#=============
_module_check_banlist()
{
    local _giturl=$1
    shift

    if [[ $_SECURITY_CHECK_BANNED != "0" ]]; then
        local _response=
        # We want the Bash version and OS info to check if the module is broken
        # for some specific combination.
        _debug "Ban server check against: $_giturl"
        if [[ $_HTTPBIN == "curl" ]]; then
            _response=$($_HTTPBIN $_SECURITY_BAN_SERVER -s -X POST --data-urlencode "git_url=${_giturl}" --data-urlencode "bash=${BASH_VERSION}" --data-urlencode "os=$(${_UNAME})")
            _debug "Ban server response, curl: ${_response}."
        elif [[ $_HTTPBIN == "wget" ]]; then
            _response=$($_HTTPBIN $_SECURITY_BAN_SERVER -q -O- --post-data="git_url=${_giturl}&bash=${BASH_VERSION}&os=$(${_UNAME})")
            _debug "Ban server response, wget: ${_response}."
        else
            _error "No curl/wget found in OS. Cannot check module banlist."
            return 1
        fi

        if [[ $_SECURITY_CHECK_BANNED == "1" ]]; then
            if [[ $_response == '{"status":"banned"}' ]]; then
                _security "The module $_giturl IS BANNED!"
                return 1
            elif [[ $_response == '{"status":"broken"}' ]]; then
                _debug "The module $_giturl is BROKEN!"
                return 1
            elif [[ $_response == '{"status":"unknown"}' ]]; then
                _debug "The module $_giturl is unknown, but is allowed by user."
                return 0
            elif [[ $_response == '{"status":"trusted"}' ]]; then
                _debug "The module $_giturl is trusted."
                return 0
            else
                _security "Could not communicate with banserver."
                return 1
            fi
        elif [[ $_SECURITY_CHECK_BANNED == "2" ]]; then
            if [[ $_response == '{"status":"banned"}' ]]; then
                _security "The module $_giturl IS BANNED!"
                return 1
            elif [[ $_response == '{"status":"broken"}' ]]; then
                _debug "The module $_giturl is BROKEN!"
                return 1
            elif [[ $_response == '{"status":"unknown"}' ]]; then
                _security "The module $_giturl is unknown!"
                return 1
            elif [[ $_response == '{"status":"trusted"}' ]]; then
                _debug "The module $_giturl is trusted."
                return 0
            else
                _security "Could not communicate with the security server."
                return 1
            fi
        else
            _error "Bad SECURITY model."
            return 1
        fi
    fi

    return 0
}


#=============
# _module_find_yaml
#
# Search for a modules YAML file using defaults and
# trying all the different YAML file name variants.
#
# Parameters:
#   $1: module name: [username/]reponame
#   $2: variable name to assign found YAML file path to.
#
#=============
_module_find_yaml()
{
    local _module=$1
    shift

    local _outvarname=$1
    shift

    local _domainname=""
    local _username="space-sh"
    local _reponame=$_module
    if [[ $_module =~ (.+)/(.+)/(.+) ]]; then
        _domainname=${BASH_REMATCH[1]}
        _username=${BASH_REMATCH[2]}
        _reponame=${BASH_REMATCH[3]}
    elif [[ $_module =~ (.+)/(.+) ]]; then
        _username=${BASH_REMATCH[1]}
        _reponame=${BASH_REMATCH[2]}
    fi
    #[[ $_reponame =~ ([^:]+) ]]
    #local _reponameclean=${BASH_REMATCH[1]}
    unset _module

    if [ "${_domainname}" = "" ]; then
        if [ "${_username}" = "space-sh" ]; then
            _domainname="gitlab.com"
        fi
    fi

    local _dir= _f=
    for _dir in ${_INCLUDEPATH[@]}; do
        for _f in "$_dir/$_domainname/$_username/$_reponame/Spacefile.yaml"; do
            if [[ -f $_f ]]; then
                _debug "Found module $_f"
                eval "$_outvarname=\$_f"
                return
            fi
        done
    done
}

#================
# _enter_gui_mode
#
# Enters graphical user interface mode
#
#================
_enter_gui_mode()
{
    _debug "Entering GUI mode"
    source "./gui/sg.sh"
    _sg_entrypoint
    return 0
}

#=====
# PRINT
#
# Redirects a message to a file descriptor.
# In the occasion _SPACE_NAME is set, its value gets prefixed to the final message output.
# This function is meant to be exported.
#
# Parameters:
#   $1: output message
#   $2: level type (error, warning, debug, ...). Defaults to "info"
#   $3: file descriptor where the message will be redirected to. Defaults to "2"
#
# Expects:
#   _LOG_ENABLE_COLORS
#   _LOG_LEVEL
#   _SPACE_NAME
#
#=====
PRINT()
{
    SPACE_ENV="_LOG_ENABLE_COLORS _LOG_LEVEL _PRINT_COLUMN_POSITION"
    local color="\033[0m"
    local header=''
    [ "${2-info}" = "error" ] && [ "${_LOG_LEVEL:-4}" -gt 0 ] && header="[ERROR] " && color="\033[31m"
    [ "${2-info}" = "security" ] && [ "${_LOG_LEVEL:-4}" -gt 0 ] && header="[SEC]   " && color="\033[35m"
    [ "${2-info}" = "warning" ] && [ "${_LOG_LEVEL:-4}" -gt 1 ] && header="[WARN]  " && color="\033[33m"
    [ "${2-info}" = "ok" ] && [ "${_LOG_LEVEL:-4}" -gt 2 ] && header="[OK]    " && color="\033[32m"
    [ "${2-info}" = "info" ] && [ "${_LOG_LEVEL:-4}" -gt 3 ] && header="[INFO]  " && color="\033[37m"
    [ "${2-info}" = "debug" ] && [ "${_LOG_LEVEL:-4}" -gt 4 ] && header="[DEBUG] " && color=""
    [ -z "${header}" ] && return 0
    [ "${_SPACE_NAME-}" != "" ] && ( [ "${_LOG_ENABLE_COLORS}" = "1" ] && printf "\033[${_PRINT_COLUMN_POSITION}G${color}%s%s: %s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&${3-2}) || ( [ "${_LOG_ENABLE_COLORS}" = "1" ] && printf "\033[${_PRINT_COLUMN_POSITION}G${color}%s%s\033[0m\n" "${header}" "${1}" >&${3-2} )
    [ "${_SPACE_NAME-}" != "" ] && ( [ "${_LOG_ENABLE_COLORS}" != "1" ] && printf "%s%s: %s\n" "${header}" "${_SPACE_NAME}" "${1}" >&${3-2}) || ( [ "${_LOG_ENABLE_COLORS}" != "1" ] && printf "%s%s\n" "${header}" "${1}" >&${3-2} )
    :
}

_print()
{
    printf "%s\n" "$*" >&2
}

_security()
{
    local _msg=
    IFS= read -d '' -r _msg << _EOF
    $@
               *****************************************************************
               *  Do not take too lightly on this security error.              *
               *  Before disabling any security checks, please head over       *
               *  to the Space.sh site to see that everything else is OK.      *
               *****************************************************************
_EOF
    [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_MAGENTA}"
    _print "[SEC]   $_msg"
    [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}"
}

_error()
{
    if (( $_VERBOSITY >= 1 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_RED}"
        _print "[ERROR] $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}"
    fi
}

_warning()
{
    if (( $_VERBOSITY >= 2 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_YELLOW}"
        _print "[WARN]  $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}"
    fi
}

_info()
{
    if (( $_VERBOSITY >= 3 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_WHITE}"
        _print "[INFO]  $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}"
    fi
}

_runinfo()
{
    if (( $_VERBOSITY >= 3 )); then
        local _msg=$1
        shift
        local _color=${1-$_COLOR_DEFAULT}
        shift || :
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_color}"
        _print "[RUN]   $_msg"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}"
    fi
}

_debug()
{
    if (( $_VERBOSITY >= 4 )); then
        _print "[DEBUG] $@"
    fi
}

#==========
# prompt
#
# Use this in YAML _env variable values to prompt the user for input.
#
# Example:
# node:
#   _env:
#       - name: $(prompt 'what is your name? ')
#
# Parameters:
#   $1: string to echo as prompt
#
# Returns:
#   echoes on stdout the answer, so your capture the output to a variable.
#
#==========
prompt()
{
    _print "$1"
    local _s
    read -r _s
    printf "%s\n" "$_s"
}

#==========
# _main
#
# Space program entrypoint
#
#==========
_main()
{
    # First thing we do is to try to figure out if
    # space was invoked as an interpretor using a shebang.
    # If that's so then the following code will modify the positional parameters
    # to fit space normal invocation.
    #
    # Note: Shebang behaviour might vary on different platforms:
    #   This is tested only on Linux so far.
    #   What could differ is that $1 would be many args instead of one,
    #   and that the chaining of shebang's might not work.
    #   ref: http://www.in-ulm.de/~mascheck/various/shebang/

    # New note: Here we try to detect wether if's a FreeBSD/OSX type of shebang
    # and modify the parameters to look like a Linux shebang.
    if [ "$#" -gt 0 ]; then
        if [ "${1}" = "!" ]; then
            # This is shebang where all args are seperated.
            # We want to remove the first and last arg containing "!" which
            # denotes the start and end of shebang arguments.
            # First one is easy.
            shift
            local _args=()
            while [ $? -eq 0 ]; do
                local _arg="${1}"
                if [ "${_arg}" = "!" ]; then
                    shift
                    break
                fi
                _args=("${_args[@]}" "${_arg}")
                shift
            done
            # Re-set all args now, but shebang args as big one arg this time.
            set -- "${_args[*]}" "$@"
            unset _args _arg
        elif [ "${1:0:2}" = "! " ]; then
            # This is shebang where all args are one, but we expected them to be separated.
            # We'll just cut away "! " and " !" from start and end of $1 and send it along.
            local _arg1="${1:2:$((${#1} - 4))}"
            # Repopulate the positional arguments.
            shift
            set -- "${_arg1}" "$@"
            unset _arg1
        fi
    fi

    local _isshebang=0
    if [ "$#" -gt 0 ]; then
        if [ -f "${1}" ]; then
            # First argument is a file, inject "-f" switch as $1, and continue
            set -- "-f" "$@"
            _isshebang=1
        elif [ "$#" -gt 1 ] && [ -f "${2}" ]; then
            # Second argument is a file, now check if first argument is more than
            # a -f switch, and if so, we have things to figure out.
            if [ "${1}" != "-f" ]; then
                _isshebang=1
                # Break $1 into parts.
                local _args_shebang=()
                _split_quoted "_args_shebang" "${1}"
                local _filename="${2}"
                shift 2
                local _args=("$@")
                local _newargs=()

                # Go through all _args_shebang up til any "--".
                local _shebang__=-1
                local _rowindex=
                for ((_rowindex=0; _rowindex<${#_args_shebang[@]}; _rowindex+=1 )); do
                    if [[ ${_args_shebang[$_rowindex]} == "--" ]]; then
                        _shebang__=$_rowindex
                        break
                    else
                        _newargs=("${_newargs[@]}" "${_args_shebang[$_rowindex]}")
                    fi
                done

                # Go through all _args up til any "--".
                local _hadargs=0
                for ((_rowindex=0; _rowindex<${#_args[@]}; _rowindex+=1 )); do
                    if [[ ${_args[$_rowindex]} == "--" ]]; then
                        # We have -- args.
                        # Add filename as first -- args
                        _hadargs=1
                        _newargs=("${_newargs[@]}" "--" "${_filename}")
                        # Keep on adding args.
                    else
                        _newargs=("${_newargs[@]}" "${_args[$_rowindex]}")
                    fi
                done

                # If -- args not added, see if we have from shebang args.
                if [ "${_hadargs}" = 0 ]; then
                    _newargs=("${_newargs[@]}" "--" "${_filename}")
                   if [ "${_shebang__}" -gt "-1" ]; then
                       _newargs=("${_newargs[@]}" "${_args_shebang[@]:$((_shebang__+1))}")
                   fi
                fi
                while shift; do :; done
                set -- "${_newargs[@]}"
                unset _args_shebang _filename _args _newargs _shebang__ _rowindex _hadargs
            fi
        fi
    fi

    local _loadmodules="" # -M
    local _envE=()        # -e
    local _envP=()        # -p
    local _dry=""         # -d
    local _help=""        # -h
    local _listnodes=0    # -l
    local _updatemodules=  #-U
    local _bash_completion_current= # -L

    local _o=

    local _namespaces=()
    local _dimensions=()
    local _strip_args=0

    # Parse nodes and switches in any order.
    while (( $# > 0 )); do
        if [[ ${1} == '--' ]]; then
            # End of options
            shift
            # Save the remaining of "$@" as is, because we will use Bash's special treatment of "$@" when forwarding the arguments.
            _strip_args="1" # This will strip of the -- args from RUN in YAML.
            break
        elif [[ ${1:0:1} == '-' ]]; then
            # A normal switch, let getopts handle it.
            OPTIND=1
            getopts ":f:m:aM:e:dp:v:k:K:ShVlC:BU:X:13:g" "_o"
            case "${_o}" in
                f)
                    if (( ${#_namespaces[@]} == 3 )); then
                        _error "Too many namespaces defined using (-f/-m). Maximum three allowed."
                        return 1
                    fi
                    _namespaces+=("file=${OPTARG}")
                    (return 1)
                    ;;
                m)
                    if (( ${#_namespaces[@]} == 3 )); then
                        _error "Too many namespaces defined using (-f/-m). Maximum three allowed."
                        return 1
                    fi
                    _namespaces+=("module=${OPTARG}")
                    (return 1)
                    ;;
                a)
                    if (( ${#_dimensions[@]} == 0 )); then
                        _error "-a flag must come after node."
                        return 1
                    fi
                    local _s=${_dimensions[$((${#_dimensions[@]}-1))]}
                    _s="${_s}.*/"
                    _dimensions[$((${#_dimensions[@]}-1))]=$_s
                    (return 1)
                    ;;
                M)
                    _loadmodules="$_loadmodules ${OPTARG}"
                    (return 1)
                    ;;
                e)
                    if [[ ! $OPTARG =~ ^[a-zA-Z0-9_]+\=.*$ ]]; then
                        _error "Malformed -e switch not on format [a-ZA-Z0-9_]+=.*: $OPTARG"
                        return 1
                    fi
                    _envE+=("${OPTARG}")
                    (return 1)
                    ;;
                d)
                    _dry=1
                    (return 1)
                    ;;
                p)
                    if [[ ! $OPTARG =~ ^[a-zA-Z0-9_]+\=[.a-zA-Z0-9_-]*$ ]]; then
                        #if [[ $_BASH_COMPLETION != "2" ]]; then
                            #_error "Malformed -p switch not on format [a-ZA-Z0-9_]+=[a-ZA-Z0-9_-.]*: $OPTARG"
                            #return 1
                        #fi
                        :
                    else
                        _envP+=("${OPTARG}")
                    fi
                    (return 1)
                    ;;
                v)
                    case "${OPTARG}" in
                        0)
                            _VERBOSITY=0
                            (return 1)
                            ;;
                        1)
                            _VERBOSITY=1
                            (return 1)
                            ;;
                        2)
                            _VERBOSITY=2
                            (return 1)
                            ;;
                        3)
                            _VERBOSITY=3
                            (return 1)
                            ;;
                        4)
                            _VERBOSITY=4
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -v argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                k)
                    case "${OPTARG}" in
                        0)
                            _SECURITY_CHECK_BANNED=0
                            (return 1)
                            ;;
                        1)
                            _SECURITY_CHECK_BANNED=1
                            (return 1)
                            ;;
                        2)
                            _SECURITY_CHECK_BANNED=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -k argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                K)
                    case "${OPTARG}" in
                        0)
                            _SECURITY_GPG_VERIFY_SIGNATURE=0
                            (return 1)
                            ;;
                        1)
                            _SECURITY_GPG_VERIFY_SIGNATURE=1
                            (return 1)
                            ;;
                        2)
                            _SECURITY_GPG_VERIFY_SIGNATURE=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -K argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                S)
                    _SECURITY_ALLOW_HTTPS_FALLBACK=1
                    (return 1)
                    ;;
                h)
                    _help="general"
                    (return 1)
                    ;;
                V)
                    _help="version"
                    (return 1)
                    ;;
                l)
                    _listnodes=1
                    (return 1)
                    ;;
                C)
                    case "${OPTARG}" in
                        0)
                            _CACHE_LEVEL=0
                            (return 1)
                            ;;
                        1)
                            _CACHE_LEVEL=1
                            (return 1)
                            ;;
                        2)
                            _CACHE_LEVEL=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -C argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                B)
                    _FORCE_BASH="1"
                    (return 1)
                    ;;
                U)
                    _updatemodules=${OPTARG:-*}
                    (return 1)
                    ;;
                X)
                    case "${OPTARG}" in
                        1)
                            _DEBUG_OUTPUT_PREPROCESSED=1
                            (return 2)
                            ;;
                        2)
                            _DEBUG_OUTPUT_PARSED=1
                            (return 1)
                            ;;
                        3)
                            _DEBUG_OUTPUT_TRANSFORMED_YAML=1
                            (return 1)
                            ;;
                        4)
                            _DEBUG_OUTPUT_ENV=1
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -X argument ${OPTARG-}."
                        return 1
                    fi
                    (return 1)
                    ;;
                1)
                    # Bash completion on nodes.
                    _BASH_COMPLETION=1
                    _bash_completion_current=${#_dimensions[@]}
                    (return 1)
                    ;;
                2)
                    # Bash completion on preprocess variable names
                    #_bash_completion_current=${OPTARG}
                    #_BASH_COMPLETION=2
                    _error "Not implemented."
                    (return 1)
                    ;;
                3)
                    # Bash completion on installed modules
                    _bash_completion_current=${OPTARG}
                    _BASH_COMPLETION=3
                    (return 1)
                    ;;
                g)
                    _ENABLE_GUI="1"
                    (return 1)
                    ;;
                \?)
                    _error "Unknown option -${OPTARG-}."
                    _print "$_USAGE"
                    return 1
                    ;;
                :)
                    if [[ $_BASH_COMPLETION == "0" ]]; then
                        _error "Option -${OPTARG-} requires an argument."
                        _print "$_USAGE"
                        return 1
                    fi
                    (return 1)
                    ;;
            esac
            if (($? == 0)); then
                _error "Unknown option $1."
                _print "$_USAGE"
                return 1
            elif (($OPTIND == 1)); then
                # This happens when doing for example: -al
                _error "Unknown option $1."
                _print "$_USAGE"
                return 1
            fi
            shift $((OPTIND-1))
        else
            # A node name
            local _node=${1}
            # We strip these because they are no longer wanted,
            # they can come here with the auto completion script.
            local _node=${_node//\"}
            local _node=${_node//\\}
            if [[ ${_node:0:1} != "/" ]]; then
                if [ "${_isshebang}" = 1 ]; then
                    _error "Cannot understand the argument '${_node}'. Did you mean: -- ${_node}?"
                else
                    _error "Node name '${_node}' must begin and end with slash. Cowboy slash (lonesome single slash) is OK."
                fi
                return 1
            fi
            if [[ $_node =~ [\ ] ]]; then
                _error "Invalid node name: $_node"
                return 1
            fi
            _dimensions+=("$_node")
            unset _node
            if (( ${#_dimensions[@]} > 3 )); then
                _error "Dimensions (node collections) cannot exceed three in total."
                return 1
            fi
            shift
        fi
    done
    unset _o
    unset _isshebang

    if [[ $_BASH_COMPLETION != "0" ]]; then
        # Reset some switches that will get in our way when auto completing.
        _help=""
        _DEBUG_OUTPUT_PREPROCESSED=0
        _DEBUG_OUTPUT_PARSED=0
        _DEBUG_OUTPUT_TRANSFORMED_YAML=0
        _DEBUG_OUTPUT_ENV=0
        _updatemodules=
        _CACHE_LEVEL=1
        _listnodes=0
        _VERBOSITY=0
        _dry=0
        _loadmodules=
        _envE=()
    fi

    local CWD=$(pwd)  # Set as global environment variable.

    if [[ $_help == "version" ]]; then
        _helpversion
        return 0
    fi

    if [[ $_help == "general" ]]; then
        if (( ${#_dimensions[@]} == 0 )); then
            _helpusage
            return 0
        else
            _help="node"
        fi
    fi

    if [[ -n ${_updatemodules-} ]]; then
        _update_modules "$_updatemodules"
        return
    fi

    if [[ $_BASH_COMPLETION == "3" ]]; then
        _completion_modules "$_bash_completion_current"
        return
    fi

    # Check so that at least one namespace exists.
    if (( ${#_namespaces[@]} == 0 )); then
        # This means look for default file names for the first namespace.
        _namespaces+=("file=")
    fi

    # Check so that at least one dimension exists.
    if (( ${#_dimensions[@]} == 0 )); then
        _dimensions+=("/")
    fi

    # Set command line -e envs, if provided.
    eval $(_apply_cmd_env)
    if [ "$?" != "0" ]; then
        _error "Problem when evaluating -e environment variables. Look for unbound variable or syntax error."
        return 1
    fi

    # Set any preprocess variables given on command line.
    local _envPs=""
    local _ev=
    for _ev in "${_envP[@]-}"; do
        _envPs=${_envPs}$_ev" "
        if [[ $_ev =~ ([_a-zA-Z0-9]+)=(.*) ]]; then
            eval "_PP_${BASH_REMATCH[1]}=\${BASH_REMATCH[2]}"
        fi
    done
    unset _ev

    if [[ -n $_loadmodules ]]; then
        _debug "Load modules $_loadmodules"
        clone "${_loadmodules}"
        (( $? > 0 )) && return 1
    fi

    # Load all YAML files into respective namespace.
    local _counter=0
    while (( _counter < ${#_namespaces[@]} )); do
        local _namespace=${_namespaces[$_counter]}
        (( _counter+=1 ))
        _debug "Loading namespace ${_counter}:${_namespace}."
        [[ $_namespace =~ (.+)=(.*) ]]
        local _t=${BASH_REMATCH[1]}
        local _path=${BASH_REMATCH[2]}
        local _yamlfile=
        local _cachefile=
        local _INCLUDEPATH=
        if [[ $_t == "file" ]]; then
            # Load file.
            if [[ -z $_path ]]; then
                # No -f give, try the defaults.
                local _cwddir=${CWD##*/}
                local _f=
                for _f in "./Spacefile.yaml"; do
                    if [[ -f $_f ]]; then
                        _path=$_f
                        break
                    fi
                done
                unset _f _cwddir

                if [[ -z $_path ]]; then
                    _error "No Spacefile.yaml file found."
                    return 1
                fi
                _debug "Found file $_path."
            elif [[ ! -f $_path ]]; then
                _error "YAML file $_path does not exist."
                return 1
            fi

            # Figure out the absolute path of $_path
            # to load the accompanying sh/bash file, if present.
            local _dir=${_path%/*}
            local _file=${_path##*/}
            if [[ -z $_dir || $_dir == "$_path" ]]; then
                _path=$CWD/$_path
                _dir=${_path%/*}
            else
                # Convert relative path to absolute.
                _dir=$( cd "$_dir" && pwd )
            fi
            _path="$_dir/$_file"
            _yamlfile=$_path
            # Try to load the accompanying sh/bash file
            # clone and source will always be to $_INCLUDEPATH[1],
            # so here we set that to be in $CWD.
            _INCLUDEPATH=($CWD $CWD/space_modules $_MODULES_SHARED)
            _debug "Includepath: ${_INCLUDEPATH[@]}"
            local _sourcefile="${_path%.*}"
            if [[ -f "${_sourcefile}.sh" ]]; then
                _source "${_sourcefile}.sh"
            elif [[ -f "${_sourcefile}.bash" ]]; then
                _source "${_sourcefile}.bash"
            fi
            unset _sourcefile _dir _file
            # Disabling cachefile to be put in $CWD.
            #_cachefile=$CWD"/."${_yamlfile##*/}".cache"
            # Put cache file along side yaml file.
            _cachefile=${_yamlfile%/*}
            _cachefile=$_cachefile"/."${_yamlfile##*/}".cache"
        else
            # Load module.
            local _module=$_path
            _debug "Include module $_module"
            clone "${_module}"
            (( $? > 0 )) && return 1

            local _protocol= _domain= _domainuser= _username= _reponame="" _commit= _str_commit= _repofullname=
            _extract_repo_parts "${_module}"
            (( $? > 0 )) && return 1

            _INCLUDEPATH=($CWD/space_modules $_MODULES_SHARED $CWD)
            _debug "Includepath: ${_INCLUDEPATH[@]}"
            _module_find_yaml "$_domain/$_repofullname" "_yamlfile"
            if [[ -z $_yamlfile ]]; then
                _error "Could not find YAML file in module ${_module}."
                return 1
            fi
            # Disabling cachefile to be put in $CWD.
            #_cachefile=$CWD"/."${_yamlfile##*/}".${_repofullname//\//.}.cache"
            # Put cache file along side yaml file.
            _cachefile=${_yamlfile%/*}
            _cachefile=$_cachefile"/."${_yamlfile##*/}".cache"
            unset _module _protocol _domain _domainuser _username _reponame _commit _str_commit _repofullname
        fi

        ## Parse and load YAML file(s).
        _YAML_NAMESPACE=${_counter}
        local _parsedyaml=()
        local _parsedyamlcompletion=()

        _load_yaml
        local _status=$?
        if (( _status > 0 )); then
            return $_status
        fi
        unset _status

        eval "local _parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}=(\"\${_parsedyamlcompletion[@]}\")"

        if (( ${#_parsedyaml[@]} > 0 )); then
            # Translate all parsed into Bash variables
            local _evals=() _line= _status=0
            _parsed_yaml_to_bash "_parsedyaml" "_evals"
            if (( ${#_evals[@]} == 0 )); then
                _warning "There are no lines parsed, is the cache old? Try -C0."
            fi
            for _line in "${_evals[@]-}"; do
                eval "$_line" || _status=$?
                if (($_status != 0)); then
                    [[ $_line =~ local\ ([^\=]+) ]]
                    local _varname=${BASH_REMATCH[1]}
                    _error "Could not evaluate YAML Bash translation for variable: $_varname. Likely some syntax error in the yaml."
                    unset _varname
                    return 1
                fi
                if [[ $_DEBUG_OUTPUT_PARSED == "1" ]]; then
                    [[ $_line =~ local\ ([^\=]+) ]]
                    local _varname=${BASH_REMATCH[1]}
                    eval "printf \"%s=%s\n\" $_varname \"\$$_varname\""
                    unset _varname
                fi

            done
            unset _status _line _evals

        fi
        unset _parsedyaml
        unset _yamlrows
        unset _parsedyamlcompletion

        if [[ $_DEBUG_OUTPUT_TRANSFORMED_YAML == "1" ]]; then
            _transform_to_yaml
        fi

        # NOTE: The preprocessing variable auto completion is disabled
        # since it's use case is questioned.
        #if [[ $_BASH_COMPLETION == "2" ]]; then
            ## Look in yaml file for defined preprocess variables.
            #if [[ -e $_yamlfile ]]; then
                #printf "%s\n" "${_bash_completion_current//./.}"
                #local _r=
                #while IFS= read -r _r; do
                    #if [[ $_r =~ ^@(${_bash_completion_current}[a-zA-Z0-9_]*):- ]]; then
                        #local _var=${BASH_REMATCH[1]}
                        #printf "%s\n" "${_var}="
                    #fi
                #done < $_yamlfile
                #unset _r
                #return 0
            #fi
            #return 1
        #fi

        # Check if we now should add more namespaces to be loaded.
        if (( _counter == 1 )); then
            _YAML_NAMESPACE=1
            if (( ${#_namespaces[@]} == 1 )); then
                # We only have one ns so far, see if to add the second.
                local _file=
                _copy "_file" "/_namespaces/0/file"
                local _module=
                _copy "_module" "/_namespaces/0/module"
                if [[ -n $_file ]]; then
                    _namespaces+=("file=$_file")
                    _debug "Friends auto added namespace 2: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                elif [[ -n $_module ]]; then
                    _namespaces+=("module=$_module")
                    _debug "Friends auto added namespace 2: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                fi
                unset _file _module
            fi
            if (( ${#_namespaces[@]} == 2 )); then
                # We only have two ns's so far, see if to add the third.
                local _file=
                _copy "_file" "/_namespaces/1/file"
                local _module=
                _copy "_module" "/_namespaces/1/module"
                if [[ -n $_file ]]; then
                    _namespaces+=("file=$_file")
                    _debug "Friends auto added namespace 3: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                elif [[ -n $_module ]]; then
                    _namespaces+=("module=$_module")
                    _debug "Friends auto added namespace 3: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                fi
                unset _file _module
            fi
        fi

    done
    unset _t _path _namespace _counter _yamlfile _envPs

    if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
        return 0
    fi

    if [[ $_DEBUG_OUTPUT_PARSED == "1" ]]; then
        return 0
    fi

    if [[ $_DEBUG_OUTPUT_TRANSFORMED_YAML == "1" ]]; then
        return 0
    fi

    # Source all sh/bash files added so far.
    _source_added
    (( $? > 0 )) && return 1

    # Figure out the dimension to namespace affinity.
    local _dim1ns=1 _dim2ns=1 _dim3ns=1
    if (( ${#_namespaces[@]} >= 2 )); then
        _dim2ns=2
    fi
    if (( ${#_namespaces[@]} >= 3 )); then
        _dim3ns=3
    fi

    if [[ $_BASH_COMPLETION == "1" ]]; then
        local _dim=$_bash_completion_current
        if [[ $_dim == "0" ]]; then
            return 1
        fi
        eval "local _ns=\$_dim${_dim}ns"

        if [[ $_dim == "1" ]]; then
            local _pattern=${_dimensions[0]}
            local _node=$_pattern
            if [[ ${_node: -1} != "/" ]]; then
                _node=$_node".*/"
            fi
            _debug "Bash completion dimension 1 for pattern: $_node in namespace ${_ns}."
            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_node"
            if (( ${#_nodes[@]} == 1 )); then
                if [[ ${_nodes[0]} == $_pattern ]]; then
                    _node=$_node".*/"
                    _nodes=()
                    _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_node"
                    if (( ${#_nodes[@]} > 0 )); then
                        printf "%s\n" "$_pattern"
                        printf "%s\n" "${_nodes[@]}"
                    else
                        printf "%s\n" "$_pattern"
                        printf "%s\n" "$_pattern"
                    fi
                else
                    printf "%s\n" "${_nodes[0]}"
                    printf "%s\n" "${_nodes[0]}"
                fi
                return 0
            elif (( ${#_nodes[@]} > 1 )); then
                printf "%s\n" "$_pattern"
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _dim _pattern _node _nodes _ns
            return 1
        elif [[ $_dim == "2" ]]; then
            local _first=${_dimensions[0]}
            local _pattern=${_dimensions[1]}
            if [[ ${_first: -1} != "/" ]]; then
                _first=$_first"/"
            fi
            _debug "Bash completion dimension 2 for pattern: $_pattern in namespace ${_dim2ns}."

            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}1" "$_first"
            if (( ${#_nodes[@]} == 0 )); then
                return 1
            fi

            # Roll out second dimension filter on second ns.
            local _dim2=()
            local _node=
            for _node in "${_nodes[@]}"; do
                _get_second_dimension "$_node" "$_dim2ns"
            done
            # Filter second dimension on pattern
            local _nodes=()
            if (( ${#_dim2[@]} > 0 )); then
                for _node in "${_dim2[@]}"; do
                    if [[ $_node =~ ${_pattern}.* ]]; then
                        local _node2=
                        for _node2 in "${_nodes[@]-}"; do
                            [[ $_node2 == $_node ]] && continue 2
                        done
                        _nodes+=("$_node")
                        unset _node2
                    fi
                done
            else
                _debug "No dim2 nodes found."
            fi

            if (( ${#_nodes[@]} == 0 )); then
                return 1
            elif (( ${#_nodes[@]} > 0 )); then
                printf "%s\n" "$_pattern"
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _first _pattern _nodes _node
        elif [[ $_dim == "3" ]]; then
            local _first=${_dimensions[0]}
            local _second=${_dimensions[1]}
            local _pattern=${_dimensions[2]}
            if [[ ${_first: -1} != "/" ]]; then
                _first=$_first"/"
            fi
            if [[ ${_second: -1} != "/" ]]; then
                _second=$_second"/"
            fi

            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}1" "$_first"
            if (( ${#_nodes[@]} == 0 )); then
                return 1
            fi

            local _dim3=()
            local _node=
            for _node in "${_nodes[@]}"; do
                _get_third_dimension "$_node" "$_second" "$_dim3ns"
            done

            # Filter third dimension on pattern
            local _nodes=()
            if (( ${#_dim3[@]} > 0 )); then
                for _node in "${_dim3[@]}"; do
                    if [[ $_node =~ ${_pattern}.* ]]; then
                        local _node2=
                        for _node2 in "${_nodes[@]-}"; do
                            [[ $_node2 == $_node ]] && continue 2
                        done
                        _nodes+=("$_node")
                        unset _node2
                    fi
                done
            fi

            if (( ${#_nodes[@]} == 0 )); then
                return 1
            elif (( ${#_nodes[@]} > 0 )); then
                printf "%s\n" "$_pattern"
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _first _second _pattern _nodes _node
        fi
    fi

    # Match the dimension node pattern to a nodelist from the dimension associated namespace.
    local _dim1=() _dim2=() _dim3=()
    local _pattern=
    local _dimcounter=0
    for _pattern in "${_dimensions[@]}"; do
        if [[ ${_pattern: -1} != "/" ]]; then
            _node="$_pattern/"
        fi
        if [[ ! $_pattern =~ (^/.+/$)|(^/$) ]]; then
            _error "Malformed node path ($_pattern). Node path must begin and end with a slash."
            return 1
        fi
        (( _dimcounter+=1 ))
        eval "local _ns=\$_dim${_dimcounter}ns"
        local _nodes=()
        # If $_pattern begins with underscore we'll match nodes
        # for underscore, otherwise we ignore underscore nodes.
        local _includehidden=0
        [[ ${_pattern:0:2} == "/_" ]] && _includehidden=1
        _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_pattern" "$_includehidden"
        if (( ${#_nodes[@]} > 0 )); then
            eval "_dim${_dimcounter}=(\"\${_nodes[@]}\")"
        else
            _error "No nodes matched for: $_pattern in namespace ${_ns}."
            return 1
        fi
    done
    unset _ns _pattern _dimcounter _nodes

    # Show some debug info about namespaces.
    local _nsload= _s="" _counter=0
    for _nsload in "${_namespaces[@]}"; do
        ((_counter+=1))
        _s="$_s ${_counter}:${_nsload}"
    done
    _debug "Namespaces loaded:${_s}."
    unset _s _nsload _counter

    # Start executing on the dimensions.
    local _first= _second= _third=

    if [[ $_help == "node" ]]; then
        _YAML_NAMESPACE=1
        for _first in "${_dim1[@]}"; do
            _helpnode "$_first"
        done
        return 0
    fi

    #
    # GUI mode
    if [ "$_ENABLE_GUI" -eq "1" ]; then
        _enter_gui_mode
        return 0
    fi

    local _status=0
    local _nodecombo=
    for _first in "${_dim1[@]}"; do
    _context()
    {
        printf -v _nodecombo "%s:%s" "$_dim1ns" "$_first"
        if (( ${#_dim2[@]} == 0 )); then
            local _dim2=()
            _get_second_dimension "$_first" "$_dim2ns"
            _status=$?
            (( _status > 0 )) && return
            # We only keep the first node.
            #if (( ${#_dim2[@]} > 0 )); then
                #_dim2=("${_dim2[0]}")
            #fi
        fi
        if (( ${#_dim2[@]} > 0 )); then
            for _second in "${_dim2[@]}"; do
                _context2()
                {
                    printf -v _nodecombo "%s:%s %s:%s" "$_dim1ns" "$_first" "$_dim2ns" "$_second"
                    if (( ${#_dim3[@]} == 0 )); then
                        local _dim3=()
                        _get_third_dimension "$_first" "$_second" "$_dim3ns"
                        _status=$?
                        (( _status > 0 )) && return $_status
                    fi
                    if (( ${#_dim3[@]} > 0 )); then
                        for _third in "${_dim3[@]}"; do
                            printf -v _nodecombo "%s:%s %s:%s %s:%s" "$_dim1ns" "$_first" "$_dim2ns" "$_second" "$_dim3ns" "$_third"
                            _exec_dimensions "$_dim1ns" "$_first" "$_dim2ns" "$_second" "$_dim3ns" "$_third" "$@"
                            _status=$?
                            (( _status > 0 )) && break
                        done
                    else
                        _exec_dimensions "$_dim1ns" "$_first" "$_dim2ns" "$_second" "" "" "$@"
                        _status=$?
                    fi
                }
                _context2 "$@"
                (( _status > 0 )) && break
            done
        else
            _exec_dimensions "$_dim1ns" "$_first" "" "" "" "" "$@"
            _status=$?
        fi
    }
        _context "$@"
        if (( _status > 0 )); then
            _error "Node(s): $_nodecombo failed executing (status: $_status)."
            return $_status
        fi
    done


    return 0
}

#======================
# _get_second_dimension
#
# For a first dimension get the second
# dimension if defined.
#
# Parameters:
#   $1: node in first dimension.
#   $2: namespace for second dimension.
#
# Expects:
#   $_dim2: will get added to
#
#======================
_get_second_dimension()
{
    local _node1=$1
    shift

    local _ns=$1
    shift

    local _levels1=${_node1//[^\/]}
    _levels1=${#_levels1}

    _YAML_NAMESPACE=1
    local _l=()
    _list "_l" "/_friends/" "1"
    _debug "friends ${_l[@]-}"

    if (( ${#_l[@]} > 0 )); then
        local _i=
        for _i in ${_l[@]}; do
            local _firststr= _secondstr=
            _copy "_firststr" "/_friends/$_i/first"
            _copy "_secondstr" "/_friends/$_i/second"
            if [[ -z $_firststr || -z $_secondstr ]]; then
                continue
            fi
            local _firstarr=() _secondarr=()
            IFS=' ' read -r -a _firstarr <<< "$_firststr"
            IFS=' ' read -r -a _secondarr <<< "$_secondstr"
            local _first=
            for _first in "${_firstarr[@]}"; do
                if [[ ! $_first =~ (^/.+/$)|(^/$) ]]; then
                    _error "Malformed _friends/${_i}/first node path (${_first}). Node path must begin and end with a slash."
                    return 1
                fi
                local _levelsfirst=${_first//[^\/]}
                _levelsfirst=${#_levelsfirst}
                if [[ $_levels1 == $_levelsfirst && $_node1 =~ ^${_first}$ ]]; then
                    local _second=
                    for _second in "${_secondarr[@]}"; do
                        if [[ ! $_second =~ (^/.+/$)|(^/$) ]]; then
                            _error "Malformed _friends/${_i}/second node path (${_second}). Node path must begin and end with a slash."
                            return 1
                        fi
                        local _nodes=()
                        _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_second"
                        if (( ${#_nodes[@]} == 0 )); then
                            _error "Friend nodes defined for second dimension but then not found in namespace ${_ns}: ${_second}."
                            return 1
                        fi
                        _debug "Friends _friends/${_i}$_first+$_second matched ${#_nodes[@]} nodes for second dimension in namespace ${_ns}."
                        _dim2+=("${_nodes[@]}")
                    done
                    break # No point checking next first if current matched.
                fi
            done
        done
    fi
}

#=====================
# _get_third_dimension
#
# For a first and second dimension
# combo get the third dimension if defined.
#
# Parameters:
#   $1: node in first dimension.
#   $2: node in second dimension.
#   $3: namespace for third dimension.
#
# Expects:
#   $_dim3: will get added to
#
#=====================
_get_third_dimension()
{
    local _node1=$1
    shift

    local _node2=$1
    shift

    local _ns=$1
    shift

    local _levels1=${_node1//[^\/]}
    _levels1=${#_levels1}
    local _levels2=${_node2//[^\/]}
    _levels2=${#_levels2}

    _YAML_NAMESPACE=1
    local _l=()
    _list "_l" "/_friends/" "1"

    if (( ${#_l[@]} > 0 )); then
        local _i=
        for _i in ${_l[@]}; do
            local _firststr= _secondstr= _thirdstr=
            _copy "_firststr" "/_friends/$_i/first"
            _copy "_secondstr" "/_friends/$_i/second"
            _copy "_thirdstr" "/_friends/$_i/third"
            if [[ -z $_firststr || -z $_secondstr || -z $_thirdstr ]]; then
                continue
            fi
            local _firstarr=() _secondarr=() _thirdarr=()
            IFS=' ' read -r -a _firstarr <<< "$_firststr"
            IFS=' ' read -r -a _secondarr <<< "$_secondstr"
            IFS=' ' read -r -a _thirdarr <<< "$_thirdstr"
            local _first=
            for _first in "${_firstarr[@]}"; do
                if [[ ! $_first =~ (^/.+/$)|(^/$) ]]; then
                    _error "Malformed _friends/${_i}/first node path (${_first}). Node path must begin and end with a slash."
                    return 1
                fi
                local _levelsfirst=${_first//[^\/]}
                _levelsfirst=${#_levelsfirst}
                if [[ $_levels1 == $_levelsfirst && $_node1 =~ ^${_first}$ ]]; then
                    local _second=
                    for _second in "${_secondarr[@]}"; do
                        if [[ ! $_second =~ (^/.+/$)|(^/$) ]]; then
                            _error "Malformed _friends/${_i}/second node path (${_second}). Node path must begin and end with a slash."
                            return 1
                        fi
                        local _levelssecond=${_second//[^\/]}
                        _levelssecond=${#_levelssecond}
                        if [[ $_levels2 == $_levelssecond && $_node2 =~ ^${_second}$ ]]; then
                            local _third=
                            for _third in "${_thirdarr[@]}"; do
                                if [[ ! $_third =~ (^/.+/$)|(^/$) ]]; then
                                    _error "Malformed _friends/${_i}/third node path (${_third}). Node path must begin and end with a slash."
                                    return 1
                                fi
                                local _nodes=()
                                _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_third"
                                if (( ${#_nodes[@]} == 0 )); then
                                    _error "Friend nodes defined for third dimension but then not found in namespace ${_ns}: ${_third}."
                                    return 1
                                fi
                                _debug "Friends _friends/${_i}$_first+$_second+$_third matched ${#_nodes[@]} nodes for second dimension in namespace ${_ns}."
                                _dim3+=("${_nodes[@]}")
                            done
                            break # No point in checkin further.
                        fi
                    done
                    break # No point in checkin further.
                fi
            done
        done
    fi
}

#=================
# _exec_dimensions
#
# Merge nodes from one, two or three
# dimensions and execute.
#
#=================
_exec_dimensions()
{
    local _ns1=$1
    shift

    local _node1=$1
    shift

    local _ns2=$1
    shift

    local _node2=$1
    shift

    local _ns3=$1
    shift

    local _node3=$1
    shift

    local _nodecombo=
    printf -v _nodecombo "%s%s%s" "$_node1" "${_node2+ $_node2}" "${_node3+ $_node3}"

    if [[ ${_listnodes-} == "1" ]]; then
        printf "%s\n" "$_nodecombo"
        return 0
    fi

    # Set command line -e envs, if provided.
    eval $(_apply_cmd_env)

    local _nodes=("$_ns1 $_node1")
    [[ -n $_node2 ]] && _nodes+=("$_ns2 $_node2")
    [[ -n $_node3 ]] && _nodes+=("$_ns3 $_node3")

    # These will be populated by _loadnode.
    local _infotitle="" _infodesc=""


    local _status=0 _tuple= _node= _ns=
    for _tuple in "${_nodes[@]}"; do
        [[ $_tuple =~ ([^\ ]+)[\ ](.+) ]]
        _ns=${BASH_REMATCH[1]}
        _node=${BASH_REMATCH[2]}
        _YAML_NAMESPACE=${_ns}
        while :; do
            local _res=()
            _loadnode "_res" "$_node" "$_strip_args"
            _status=$?
            if (($_status != 0)); then
                _error "Could not evaluate node variables for node: $_node. There's probably some syntax error in the YAML."
                return 1
            fi

            # TODO: this trap thing is not very effective in catching the right errors.
            trap '_error "Problem when evaluating syntax for node: ${_node}. Look for unbound variable or other syntax error in the YAML."; trap - EXIT; return 1; ' EXIT
            if (( ${#_res[@]} > 0 )); then
                local _str=
                for _str in "${_res[@]}"; do
                    if [[ $_DEBUG_OUTPUT_ENV == "1" ]]; then
                        printf "%s" "$_str"
                    fi
                    _status=0
                    eval "$_str" || _status="$?" 
                    if (($_status != 0)); then
                        _error "Could not evaluate node variables for node: $_node. There's probably some syntax error in the YAML."
                        trap - EXIT
                        return 1
                    fi
                done
                unset _Str
            fi
            trap - EXIT

            if [[ -n ${ALIAS-} ]]; then
                # Rerun for the new node, same namespace.
                _debug "Alias $_node to $ALIAS, namespace $_ns."
                _node=$ALIAS
                unset ALIAS
                # will continue
            else
                break
            fi
        done
    done
    unset _ns

    if [[ $_DEBUG_OUTPUT_ENV == "1" ]]; then
        return 0
    fi

    if [[ -z ${RUN-} ]]; then
        _error "No RUN environment variable specified in YAML nodes nor on command line. Use -h to get help or -a -l to list all child nodes."
        return 1
    fi

    _debug "Execute on $_nodecombo."
    _execute "$@"
    return $?
}

#===========
# _load_yaml
#
# Helper "macro" to _main to
# load, preprocess, parse and cache YAML file.
#
#===========
_load_yaml()
{
    if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
        _CACHE_LEVEL=0
    fi
    if (( $_CACHE_LEVEL == 1 )); then
        # Use cache if exists and still valid
        if [[ -e $_cachefile ]]; then
            _debug "Found cache file: $_cachefile"
            local _allrows=() _r=
            while IFS= read -r _r; do
                _allrows+=("$_r")
            done < $_cachefile
            unset _r
            local _cache_format=${_allrows[0]}

            local _isvalid=0
            while :; do
                if [[ $_cache_format != "$_CACHE_FORMAT" ]]; then
                    _debug "Cached format changed, invalidating."
                    break
                fi

                local _filelist=${_allrows[1]}
                local _filesum=${_allrows[2]}
                local _fileenvps=${_allrows[3]}

                # Check so that the first file in the list corresponds to $_yamlfile
                if [[ ${_filelist%%\ *} != $_yamlfile ]]; then
                    break
                fi

                local _currentsum=
                # EXTERNAL: cat
                [[ -n $_SHASUMBIN ]] && _currentsum=$(cat $_filelist 2>/dev/null | ${_SHASUMBIN} 2>/dev/null)

                if [[ -z $_currentsum ]]; then
                    _warning "Caching could not be used since checksum could not be generated"
                elif [[ $_currentsum == "$_filesum" && (-z $_envPs || $_envPs == "$_fileenvps") ]]; then
                    # Timestamps work out
                    _debug "Reusing cache: $_cachefile"
                    if [[ $_envPs != $_fileenvps ]]; then
                        _warning "Using cached -p variables."
                        _debug "Cached -p variables: $_fileenvps"
                    fi
                    IFS=';' read -r -a _parsedyamlcompletion <<< "${_allrows[4]}"
                    _parsedyaml=("${_allrows[@]:5}")
                    _isvalid=1
                fi
                break
            done
            if [[ $_isvalid == "0" ]]; then
                _debug "Cached version not valid."
            fi
            unset _filelist _filesum _fileenvps

            unset _allrows
        else
            _debug "Cache file not found: $_cachefile"
        fi
    elif (( $_CACHE_LEVEL == 0 )); then
        # rm cache file, to avoid future confusions.
        _debug "Deleting cache file: $_cachefile"
        # EXTERNAL: rm
        rm -f $_cachefile
    fi

    if (( ${#_parsedyaml[@]} == 0 )); then
        # (re)generate yaml
        _debug "preprocess YAML file: $_yamlfile ..."
        local _yamlrows=() _parents=() _yamlfilelist=""
        # Preprocess variable that points to the directory of the YAML file being processed
        local _PP_DIR=${_yamlfile%/*}
        # Preprocess variable that points to current CWD where user invoked space.
        local _PP_CWD=$CWD
        if [[ $_PP_DIR != $_PP_CWD ]]; then
            # If CWD is different that initial YAML file dir, then add
            # YAML file dir to _INCLUDEPATH.
            _INCLUDEPATH+=("$_PP_DIR")
        fi
        _pp_yaml "_yamlrows" $_yamlfile
        local _status=$?
        if (($_status == 1)); then
            _error "Could not find file $_yamlfile"
            return 1
        elif (($_status > 1)); then
            _error "Preprocessing of YAML aborted with status code: $_status"
            return $_status
        fi
        _debug "...done preprocessing."
        unset _status

        if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
            local _line=
            for _line in "${_yamlrows[@]}"; do
                printf "%s\n" "$_line"
            done
            unset _line
        fi

        _debug "parse YAML ..."
        if (( ${#_yamlrows[@]} > 0 )); then
            _parse_yaml "_yamlrows" "_parsedyaml" "_parsedyamlcompletion"
            local _quicksort_output=()
            _quicksort "${_parsedyamlcompletion[@]}"
            _parsedyamlcompletion=("${_quicksort_output[@]}")
        fi
        unset _parents
        _debug "...done parsing"

        if (( $_CACHE_LEVEL > 0 )); then
            # (re)save cache file.
            _debug "Write to cache file: $_cachefile"

            local _currentsum=
            # EXTERNAL: cat
            [[ -n $_SHASUMBIN ]] && _currentsum=$(cat $_yamlfilelist 2>/dev/null | ${_SHASUMBIN} 2>/dev/null)

            if [[ -z $_currentsum ]]; then
                _warning "Cache could not be stored since checksum could not be generated"
            else
                printf "%s\n" "$_CACHE_FORMAT" > $_cachefile
                printf "%s\n" "$_yamlfilelist"  >> $_cachefile
                printf "%s\n" "$_currentsum" >> $_cachefile
                printf "%s\n" "$_envPs" >> $_cachefile
                local _s=$(IFS=';'; echo "${_parsedyamlcompletion[*]}")
                printf "%s\n" "$_s" >> $_cachefile
                unset _s
                if (( ${#_parsedyaml[@]} > 0 )); then
                    printf "%s\n" "${_parsedyaml[@]}" >> $_cachefile
                fi
            fi
        fi
        unset _yamlfilelist
    fi
}

#====================
# _completion_modules
#
# Perform Bash auto completion on modules.
#
#====================
_completion_modules()
{
    local _bash_completion_current=$1
    shift

    local _places=( "$CWD/space_modules" "$_MODULES_SHARED" )
    local _dir=
    local _f=$_bash_completion_current
    local _default=${_bash_completion_current}

    if [[ ${_f} == "." ]]; then
        _f=""
    fi

    local _items=() _i=
    for _i in 1 2; do
        for _dir in "${_places[@]}"; do
            # EXTERNAL: find
            local _modules=$(cd $_dir 2>/dev/null && find . -mindepth 3 -maxdepth 3 -wholename "./${_f}*" -type d)
            for _f in $_modules; do 
                _items+=("${_f:2}")
            done
        done
        if (( ${#_items[@]} > 0 )); then
            printf "%s\n" "$_default"
            printf "%s\n" "${_items[@]}"
            break
        else
            if [[ ! $_f =~ \/ ]]; then
                _default="gitlab.com/space-sh/"
                _f="gitlab.com/space-sh/$_f"
            elif [[ ! $_f =~ space-sh\/([^\/]*) ]]; then
                _default="gitlab.com/space-sh/"
                _f="gitlab.com/space-sh/$_f"
            else
                return 1
            fi
        fi
    done
    unset _f
}

#===============
# _update_modules
#
# Update all existing space modules
#
#===============
_update_modules()
{
    local _updatemodules=$1
    shift

    # EXTERNAL: git
    if ! command -v git >/dev/null; then
        _error "Git is not installed, cannot update modules."
        return 1
    fi

    local _pattern=".*"
    if [[ $_updatemodules != "*" ]]; then
        local _domainname="gitlab.com"
        local _username="space-sh"
        local _reponame=$_updatemodules 
        if [[ $_updatemodules  =~ (.+)/(.+)/(.+) ]]; then
            _domainname=${BASH_REMATCH[1]}
            _username=${BASH_REMATCH[2]}
            _reponame=${BASH_REMATCH[3]}
        elif [[ $_updatemodules  =~ (.+)/(.+) ]]; then
            _username=${BASH_REMATCH[1]}
            _reponame=${BASH_REMATCH[2]}
        fi
        if [[ $_username == "*" ]]; then
            _username=".*"
        fi
        if [[ $_reponame == "*" ]]; then
            _reponame=".*"
        fi
        _pattern="./$_domainname/$_username/$_reponame"
    fi
    _info "Updating space modules to pattern: $_pattern"
    local _places=( "$CWD/space_modules" "$_MODULES_SHARED" )
    local _dir=
    for _dir in "${_places[@]}"; do
        # EXTERNAL: find
        local _modules=$(cd $_dir 2>/dev/null && find . -mindepth 3 -maxdepth 3 -type d -regex "$_pattern")
        if [[ -n $_modules ]]; then
            _info "Modules found in $_dir: " $_modules
            (
                cd $_dir 2>/dev/null
                for d in $_modules; do
                    d=${d:2}
                    _info "Update module $_dir/$d"
                    cd $_dir/$d
                    # EXTERNAL: git
                    if [[ -d .git ]] ; then
                        # Check the module banlist.
                        local _giturl=$(git config --get remote.origin.url)
                        if [[ "$d" =~ .*[:]+(.*) ]]; then
                            _module_check_banlist "${_giturl}:${BASH_REMATCH[1]}"
                            (( $? > 0 )) && return 1

                            git symbolic-ref -q HEAD > /dev/null 2>&1
                            if [ "$?" -gt "0" ]; then
                                _info "Skipping update. Keeping revision ${BASH_REMATCH[1]}";
                                continue
                            fi
                        else
                            _module_check_banlist "$_giturl"
                            (( $? > 0 )) && return 1
                        fi
                        local _current_version=""
                        local _new_version="master"
                        if [ -f "./stable.txt" ]; then
                            # EXTERNAL: cat
                            _current_version=$(cat "./stable.txt")
                        fi
                        git checkout master > /dev/null 2>&1
                        if [ "$?" -gt 0 ]; then
                            _error "Failed to checkout master branch"
                            return 1
                        fi
                        local _git_pull_output=
                        _git_pull_output=$(git pull 2>&1)
                        if [ "$?" -gt 0 ]; then
                            _error "Failed to pull master branch"
                            return 1
                        fi
                        if [ -f "./stable.txt" ]; then
                            # EXTERNAL: cat
                            _new_version=$(cat "./stable.txt")
                            if [ "$_current_version" != "$_new_version" ]; then
                                _info "Updating to version: $_new_version"
                            else
                                _info "Keeping version: $_new_version"
                            fi
                            git checkout "$_new_version" > /dev/null 2>&1
                            if [ "$?" != "0" ]; then
                                _error "Could not Git checkout $_new_version of $_reponame."
                                return 1
                            fi
                        else
                            if [ "$_git_pull_output" = "Already up-to-date." ]; then
                                _info "Already up-to-date"
                            else
                                _info "Updated to latest master"
                            fi
                        fi
                        if [[ -f .gitmodules ]]; then
                            git submodule update >&2
                            if (( $? > 0 )); then
                                _error "Could not perform Git submodule update. Is Perl installed?"
                                return 1
                            fi
                        fi
                        # TODO Check the signature of the commit, if applicable.
                    else
                        _warning "Directory $_dir/$d is not a Git repository and cannot be updated."
                    fi
              done
            )
            if [ "$?" -gt 0 ]; then
                return 1
            fi
        else
            _info "No modules found in $_dir."
        fi
    done
}

#============
# _parsed_yaml_to_bash
#
# Translate parsed YAML into Bash variables.
#
# Parameters:
#   $1: variable name of input array.
#   $2: variable name of output array.
#
#============
_parsed_yaml_to_bash()
{
    local _invarname=$1
    shift

    local _outvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${"${_invarname}"[@]}\")"

    local _line= _str= _varname=
    for _line in "${_allrows[@]}"; do
        if [[ -z $_varname ]]; then
            _varname="${_YAML_PREFIX}${_YAML_NAMESPACE}${_line}"
            _str="local $_varname="$'\n'" read -d '' -r $_varname << \"$_SPACEGAL_EOF_TAG\""
        elif [[ $_line == "$_SPACEGAL_EOF_TAG" ]]; then
            _str=$_str$'\n'$_SPACEGAL_EOF_TAG$'\n'":"$'\n'
            eval "$_outvarname+=(\"\$_str\")"
            _str=""
            _varname=
        else
            _str=$_str$'\n'$_line
        fi
    done
}

#==========
# _match_node
#
# Matches a given pattern to a list of nodes
#
# Parameters:
# $1: name of array containing sorted list of nodes.
# $2: pattern to match against list of nodes, ex: "/sites/.*/".
# $3: include hidden nodes. set to 1 to include hidden leave nodes beginning with an underscore.
# $4: simple, set to 1 to only return the last node part.
# $5: includeleafs, set to 1 to include leaf nodes.
#
# Expects:
#   $_nodes: Array to add results to.
#
#==========
_match_node()
{
    local _inputname=$1
    shift

    local _nodepath=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _simple=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    local _item= _node= _isleaf=
    local _nodelist=()
    eval '
    for _item in "${'$_inputname'[@]-}"; do
        if [[ $_item =~ ([^ ]+)\ (.*) ]]; then
            _node=${BASH_REMATCH[1]}
            _isleaf=${BASH_REMATCH[2]}
            if [[ ($_isleaf == "1" && $_includeleafs == "1") || $_isleaf == "0" ]]; then
                _nodelist+=($_node)
            fi
        fi
    done
    '
    unset _item _node _isleaf

    if ((${#_nodelist[@]} == 0)); then
        return 0
    fi

    local _item= _levels=
    local _match= _matched=

    # Figure out how many levels we have by counting slashes.
    _levels=${_nodepath//[^\/]}
    _levels=${#_levels}
    ((_levels-=1))
    if (($_levels == 0)); then
        _nodes+=("/")
    else
        _match=""
        for ((i=0; i<$_levels; i++)); do
            if ((i < _levels-1)) || [[ $_includehidden == "1" ]]; then
                _match="${_match}/[a-zA-Z0-9_]+"
            else
                _match="${_match}/[a-zA-Z0-9][a-zA-Z0-9_]*"
            fi
        done
        _match="${_match}/"
        for _item in "${_nodelist[@]}"; do
            if [[ $_item =~ ^($_match)$ ]]; then
                _matched=${BASH_REMATCH[1]}
                if [[ $_matched =~ $_nodepath ]]; then
                    if [[ $_simple == "0" ]]; then
                        _nodes+=("$_matched")
                    else
                        local _arr=()
                        IFS='/' read -r -a _arr <<< "${_matched}"
                        _nodes+=("${_arr[$((${#_arr[@]}-1))]}")
                        unset _arr
                    fi
                fi
            fi
        done
    fi
    unset _item _levels
    unset _match _matched
    unset _nodepath
}

#==========
# _loadnode
#
# Load the environment variables for a particular node one part at a time.
#
# Parameters:
#   $1: name of the output array to append to.
#   $2: the node path to load.
#   $3: set to "1" to strip RUN variable of -- arguments. We do this when we have commands on command line that shall override.
#
#==========
_loadnode()
{
    local _output=$1
    shift

    local _fullnodepath=$1
    shift

    local _strip_args=${1:-0}
    shift || :

    if [[ ${_fullnodepath:0:1} != "/" ]]; then
        _error "Malformed node ($_fullnodepath), node must begin with slash."
        return 1
    fi

    _debug "Load node: ${_fullnodepath}"

    local _nodeparts=()
    IFS='/' read -r -a _nodeparts <<< "${_fullnodepath}"


    local _nodepath=""
    local _i=0
    local _nrparts=${#_nodeparts[@]}
    while (( _i < _nrparts )); do
        local _node=${_nodeparts[$_i]}
        _nodepath="${_nodepath}${_node}/"
        ((_i+=1))

        local _str=
        _copy "_str" "${_nodepath}_info/desc"
        [[ -n $_str ]] && _infodesc="$_str"
        _copy "_str" "${_nodepath}_info/title"
        [[ -n $_str ]] && _infotitle="$_str"

        local _src=
        _copy "_src" "${_nodepath}_source"
        if [[ -n $_src ]]; then
            local _s='_source "'$_src'"'$'\n'
            eval "$_output+=( \"\$_s\" )"
        fi
        local _envarrkeys=()
        _list "_envarrkeys" "${_nodepath}_env/" "1"
        if [[ -z ${_envarrkeys-} || ((${#_envarrkeys} == 0)) ]]; then
            continue
        fi
        local _arrindex= _key=
        for _arrindex in "${_envarrkeys[@]}"; do
            local _envs=()
            _list "_envs" "${_nodepath}_env/$_arrindex/" "1" "1"
            if (( ${#_envs[@]} > 0 )); then
                for _key in "${_envs[@]}"; do
                    # Check if it's a protected variable that's only
                    # allowed to be set on the last part of the node.
                    if (( _i < _nrparts )); then
                        case "${_key}" in
                            RUN|CMDREDIR|ALIAS|CMDOUTER|CMDARGS)
                                continue
                                ;;
                        esac
                    fi

                    if [[ $_key =~ ^[0-9]+$ ]]; then
                        _error "${_nodepath}_env/$_arrindex/$_key is malformed, array inside object?. Syntax error in YAML."
                        return 1
                    fi

                    if [[ ${_key:0:1} == "_" ]]; then
                        _error "Environment variable ${_nodepath}_env/$_arrindex/$_key is forbidden, variable cannot begin with underscore."
                        return 1
                    fi

                    local _value=
                    _copy "_value" "${_nodepath}_env/$_arrindex/$_key"

                    if [[ $_key == "RUN" && $_strip_args == "1" ]]; then
                        # If variable is RUN, we check if to trim away the arguments
                        # after "--" already here, to avoid variables not being declared.
                        # Use case is when overriding arguments from command line with the "--" switch.
                        # NOTE: There's a small probability that the first -- encountered is not
                        # a switch. We could use _split_quoted instead, but it feels a bit overkill.
                        if [[ $_value =~ (.+)[\ ]--[\ ] ]]; then
                            _value=${BASH_REMATCH[1]}
                        fi
                    fi

                    if [[ "$_value" == "!unset" ]]; then
                        local _s="unset ${_key}"$'\n'":"$'\n'
                        eval "$_output+=( \"\$_s\" )"
                    elif [[ "${_value:0:1}" == \' && "${_value: -1}" == \' ]]; then
                        local _s="[[ \${$_key-} == \"\" && \${$_key-unset} == \"unset\" ]] && local ${_key} || local ${_key}=\$${_key}; read -d '' -r ${_key} << \"$_SPACEGAL_EOF_TAG\""$'\n'"${_value:1:$((${#_value}-2))}"$'\n'"$_SPACEGAL_EOF_TAG"$'\n'":"$'\n'
                        eval "$_output+=( \"\$_s\" )"
                    else
                        if [[ "${_value:0:1}" == \" && "${_value: -1}" == \" ]]; then
                            _value="${_value:1:$((${#_value}-2))}"
                            _value=${_value//\\\"/\"}
                        fi

                        # Escape all quoted variables.
                        while :; do
                            local _left="${_value%%\"\$\{*}"
                            local _intermed=${_value:$((${#_left} + 1))}
                            local _middle="${_intermed%%\}\"*}"
                            if [ "${_left}" = "${_value}" -o "${_middle}" = "${_intermed}" ]; then
                                break
                            fi
                            _middle="${_middle}}"
                            local _right=${_value:$((${#_left} + 2 + ${#_middle}))}
                            _escape "_middle"
                            _value="${_left}\$(_escape_inline \"${_middle}\")${_right}"
                        done

                        local _s="[[ \${$_key-} == \"\" && \${$_key-unset} == \"unset\" ]] && local ${_key} || local ${_key}=\$${_key}; read -d '' -r ${_key} << $_SPACEGAL_EOF_TAG"$'\n'"${_value}"$'\n'"$_SPACEGAL_EOF_TAG"$'\n'":"$'\n'
                        eval "$_output+=( \"\$_s\" )"
                    fi
                done
            else
                _warning "_env item ${_nodepath}_env/$_arrindex has no children, are you sure _env is treated as an array?"
            fi
        done

    done
    return 0
}

#==========
# _execute
#
# Process a particular node path. Starts with root and evaluates every node.
# in path.
# Note: This function expects that the YAML has been loaded.
#
# Parameters:
#   $@: arguments given after '--' on command line.
#
# Returns:
#   Status code of the executed command
#
#==========
_execute()
{
    # Source all sh/bash files added.
    _source_added
    (( $? > 0 )) && return 1

    # Cut potential function arguments from $RUN into $_defaultargs.
    # NOTE: possibly make it possible to have RUN: "A=1 B=2 echo something"
    # in the sense that A=1 isn't treated as the command and the rest as arguments.
    local _defaultargs=
    if [[ $RUN =~ ([^ ]+)[\ ]+(.+) ]]; then
        RUN=${BASH_REMATCH[1]}
        _defaultargs=${BASH_REMATCH[2]}
        if [[ $RUN =~ \= ]]; then
            _error "Sorry, but the RUN (\"$RUN $_defaultargs\") seems to be prefixed by variable assignment(s), the RUN variable assigned from YAML cannot not take such a complex form. Please instead use a Bash function to set RUN."
            return 1
        fi
    fi

    # Split string into array of arguments.
    local _args=()
    _split_quoted "_args" "$_defaultargs"

    # Any arguments in RUN after -- (including) have already been cut away by now.
    # If it was not we now remove the -- token.
    local _rowindex=
    for ((_rowindex=0; _rowindex<${#_args[@]}; _rowindex+=1 )); do
        if [[ ${_args[$_rowindex]} == "--" ]]; then
            _args=("${_args[@]:0:$_rowindex}" "${_args[@]:(($_rowindex+1))}")
            break
        fi
    done
    unset _rowindex

    # Append CMDARGS arguments to RUN.
    local _arg=
    if [[ -n ${CMDARGS-} ]]; then
        for _arg in ${CMDARGS}; do
            _args+=("$_arg")
        done
    fi

    # Append command line arguments to RUN.
    for _arg in "$@"; do
        _args+=("$_arg")
    done

    local _cmd_args_count=${#_args[@]}
    local _rowindex= _cmd_args_str=""
    for ((_rowindex=0; _rowindex<_cmd_args_count; _rowindex+=1 )); do
        _arg="${_args[$_rowindex]}"
        _escape "_arg" '"'
        # Always quote arg for eval statement to avoid evaluating &&, >, etc
        _cmd_args_str="${_cmd_args_str:+${_cmd_args_str} }\""$_arg$'"'
    done
    unset _rowindex _arg _args _cmd_args_count


    # Now start looking at the RUN.
    # All these arrays will be the same size,
    # and populated by the _cmd_extract function.
    local _cmd_names=()
    local _cmd_bodies=()
    local _cmd_args=()
    local _cmd_redirs=()
    local _cmd_outers=()
    local _cmd_wraps=()
    local _cmd_deps=()
    local _cmd_envs=()
    local _cmd_outerenvs=()
    local _cmd_outerdeps=()

    # Check if $RUN is a function or just a snippet.
    declare -f -F $RUN &>/dev/null
    if (($? > 0)); then
        # $RUN is not a function, it's an external executable or a Bash snippet
        _debug "RUN is snippet or executable: $RUN"
        # We want to create an anonymous function containing $RUN,
        # so it then could be handled in the general way, just as any other function.
        # We create this variable, and it will be available for _get_fn to read from
        # when it ecnouters the name "_anonymous".
        local _anonymous="    $RUN \"\$@\""
        RUN="_anonymous"
    fi

    # $RUN is a function.
    _debug "RUN is function: $RUN"
    _debug "RUN args: $_cmd_args_str"
    _debug "RUN wrap: ${CMDWRAP-}"

    local SPACE_FN=$RUN                     # Inherited value from YAML.
    local SPACE_REDIR=${CMDREDIR-}          # Inherited value from YAML.
    local SPACE_OUTER=${CMDOUTER-}          # Inherited value from YAML.
    local SPACE_OUTERARGS=${CMDOUTERARGS-}  # Inherited value from YAML.
    local SPACE_WRAP=${CMDWRAP-}            # Inherited value from YAML.
    local SPACE_ENV=
    local SPACE_ARGS=${_cmd_args_str}
    local SPACE_DEP=${CMDDEP-}
    local SPACE_OUTERDEP=
    local SPACE_OUTERENV=
    _cmd_extract
    (( $? > 0 )) && return 1
    unset _cmd_args_str

    # Iterate over all cmds and their data to build up the export
    local _numcmds=${#_cmd_names[@]}
    if (( _numcmds == 0 )); then
        _error "No RUN's to run."
        return 1
    fi

    local _export_cmd=""
    local _cmd_options="set -u  # Will not allow for unset variables being used.
"
    local _index=0
    while (( _index < _numcmds )); do
        local _fn_name=${_cmd_names[$_index]}
        local _fn_def=${_cmd_bodies[$_index]}
        local _fn_args=${_cmd_args[$_index]}
        local _fn_redir=${_cmd_redirs[$_index]}
        local _fn_outer=${_cmd_outers[$_index]}
        local _fn_wrap=${_cmd_wraps[$_index]}
        local _fn_env="${_cmd_envs[$_index]}"
        local _fn_deps="${_cmd_deps[$_index]}"
        local _fn_cmdouterenv="${_cmd_outerenvs[$_index]}"
        local _fn_cmdouterdep="${_cmd_outerdeps[$_index]}"

        if [[ -z "${_fn_wrap}" ]]; then
            if [[ -n "${_fn_cmdouterenv}" ]]; then
                _fn_env="${_fn_cmdouterenv} ${_fn_env}"
            fi
            if [[ -n "${_fn_cmdouterdep}" ]]; then
                local _item=
                for _item in ${_fn_cmdouterdep}; do
                    if [[ ! ${_fn_deps} =~ (^|[\ ])${_item}($|[\ ]) ]]; then
                        _cmd_add_fn_dep "${_item}" "SPACE_OUTER"
                        (( $? > 0 )) && return 1
                    fi
                done
                unset _item
            fi
            _fn_cmdouterenv=
            _fn_cmdouterdep=
        fi

        if [[ -n ${CMDENV-} ]]; then
            _fn_env="${CMDENV} ${_fn_env}"
        fi

        local _fn_call="${_fn_name} ${_fn_args}"
        unset _fn_args

        local _wrapped_fn_def=""
        local _wrappers=0
        if [[ -n ${_fn_wrap} ]]; then
            _wrapped_fn_def=$'\n'   # An empty line before all the wrapping comes.
            local _fn_wrap_item= _fn_wrap_items= _i=
            IFS=' ' read -r -a _fn_wrap_items <<< "${_fn_wrap}"
            _wrappers=${#_fn_wrap_items[@]}
            # We evaluate all the wrappers beginning with the outermost one.
            # In this way wrappers can manipulate environment variables for
            # innermore wrappers and also for the final function.
            for ((_i=$((_wrappers-1)); _i>=0; _i-=1 )); do
                _fn_wrap_item="${_fn_wrap_items[${_i}]}"

                # Inner scope used to isolate some variables 
                _spacegal_context ()
                {
                    local _cmd_names=()
                    local _cmd_bodies=()
                    local _cmd_args=()
                    local _cmd_redirs=()
                    local _cmd_outers=()
                    local _cmd_wraps=()
                    local _cmd_deps=()
                    local _cmd_envs=()
                    local _cmd_outerenvs=()
                    local _cmd_outerdeps=()
                    local SPACE_FN="${_fn_wrap_item}"
                    local SPACE_REDIR=
                    local SPACE_OUTER=
                    local SPACE_OUTERARGS=
                    local SPACE_WRAP=
                    local SPACE_DEP=
                    local SPACE_ENV=
                    local SPACE_OUTERDEP=
                    local SPACE_OUTERENV=
                    # We do NOT pass the arguments
                    # into the wrapper function.
                    local SPACE_ARGS=

                    _cmd_extract
                    (( $? > 0 )) && return 1

                    local _fn_env="${_cmd_envs[0]}"
                    #if [[ -n ${CMDENV-} ]]; then
                        #_fn_env="${CMDENV} ${_fn_env}"
                    #fi

                    local _fn_name=${_cmd_names[0]}
                    local _fn_def=${_cmd_bodies[0]}
                    local _fn_args="${_cmd_args[0]}"
                    local _fn_call="${_fn_name} ${_fn_args}"
                    local _fn_deps="${_cmd_deps[$_index]}"

                    # Check if this is the outermost wrapper and
                    # if CMDOUTER has env and dep's to it, then
                    # we add those to this top most level.
                    if [[ "${_i}" == "$((_wrappers-1))" ]]; then
                        if [[ -n "${_fn_cmdouterenv}" ]]; then
                            _fn_env="${_fn_cmdouterenv} ${_fn_env}"
                        fi
                        if [[ -n "${_fn_cmdouterdep}" ]]; then
                            local _item=
                            for _item in ${_fn_cmdouterdep}; do
                                if [[ ! ${_fn_deps} =~ (^|[\ ])${_item}($|[\ ]) ]]; then
                                    _cmd_add_fn_dep "${_item}" "SPACE_OUTER"
                                    (( $? > 0 )) && return 1
                                fi
                            done
                            unset _item
                        fi
                    fi

                    local _export_vars=""
                    _cmd_export_vars "${_fn_env}" "${_fn_name}"

                    push "_fn_def"
                    push "_fn_call"
                    push "_export_vars"
                }
                _spacegal_context
                (( $? > 0 )) && return 1
            done
            unset _fn_wrap_item _fn_wrap_items _i
        fi

        local _export_vars=""
        _cmd_export_vars "${_fn_env}" "${_fn_name}"

        while ((_wrappers>0)); do
            ((_wrappers-=1))
            _wrapped_fn_def="RUN=\$(cat <<\"${_wrappers}${_SPACEGAL_EOF_TAG}\""$'\n'"${_wrapped_fn_def}${_export_vars}${_fn_def}${_fn_call}"$'\n\n'"${_wrappers}${_SPACEGAL_EOF_TAG}"$'\n'")"$'\n\n'
            pop "_export_vars"
            pop "_fn_call"
            pop "_fn_def"
        done

        if [[ -n ${_fn_redir} ]]; then
            _fn_call="${_fn_call} ${_fn_redir}"
        fi

        # $_fn_outer is used to make the RUN be inside a for loop
        # or some other prefixing or enclosing code.
        local _fn_outer_header=""
        local _fn_outer_footer=""
        if [[ -n ${_fn_outer} ]]; then
            _fn_outer_header=${_fn_outer%_CMD_*}
            _fn_outer_footer=${_fn_outer#*_CMD_}
            if [ "${_fn_outer_header}" = "${_fn_outer_footer}" ]; then
                _error "Outer command has no _CMD_ tag."
                return 1
            fi
        fi

        _export_cmd="${_cmd_options}${_export_cmd}${_wrapped_fn_def}${_export_vars}${_fn_def}${_fn_outer_header}${_fn_call}${_fn_outer_footer}"$'\n'

        _export_cmd="${_export_cmd}"'
# Space shows error message, if non clear exit.
_status="$?"; if [ "'${CMDSILENT:-0}'" -eq 0 ] && [ "${_status}" -ne "'${CMDEXIT:-0}'" ]; then
    [ "'${_LOG_ENABLE_COLORS}'" = "1" ] && printf "'${_COLOR_FG_RED}'"; printf "%s\n" "[ERROR] Script exited with status: ${_status}." >&2; [ "'${_LOG_ENABLE_COLORS}'" = "1" ] && printf "'${_COLOR_DEFAULT}'"
    exit "$(( ${_status} > 0 ? ${_status} : 1 ))"
fi
'

        (( _index += 1 ))
    done
    unset _index


    if [[ ! -z $_dry ]]; then
        if [[ -t 1 ]]; then
            _info "##################################################"
            _info "#######       DRY RUN - NOT EXECUTING      #######"
            _info "####### Redirect STDOUT to save as script. #######"
            _info "##################################################"
        fi

        local _sh="/bin/env sh"
        if [ "${_FORCE_BASH}" = "1" ]; then
            _sh="/bin/env bash"
        fi

        local _exportinfo="#!${_sh}
# Script exported by:
#   ____  ____   __    ___  ____  ___   __   __
#  / ___)(  _ \ / _\  / __)(  __)/ __) / _\ (  )
#  \___ \ ) __//    \( (__  ) _)( (_ \/    \/ (_/\\
#  (____/(__)  \_/\_/ \___)(____)\___/\_/\_/\____/
#                                         space.sh"
        printf "%s\n" "$_exportinfo"

        local _helpinfo="# Node: $_nodecombo"$'\n'
        [[ $_infotitle ]] && _helpinfo="${_helpinfo}# $_infotitle"$'\n'
        [[ $_infodesc ]] && _helpinfo="${_helpinfo}# ${_infodesc//$'\n'/$'\n'\# }"$'\n'
        [[ -n $_helpinfo ]] && printf "%s\n" "$_helpinfo"

        printf "%s\n" "$_export_cmd"
        return 0
    else
        # We run the final result in a separate shell, to isolate the
        # environment to not have leaky environment.
        local _sh="env sh"
        if [ "${_FORCE_BASH}" = "1" ]; then
            _sh="env bash"
        fi
        ${_sh} -c "$_export_cmd"
    fi
}

#============
# _cmd_extract
#
# Helper function to analyze and extract RUN function and headers.
# The following Space header variables could or are expected to have been set with default values:
# - SPACE_FN (required)
# - SPACE_ENV
# - SPACE_REDIR
# - SPACE_OUTER
# - SPACE_OUTERARGS
# - SPACE_ARGS
# - SPACE_WRAP
#
# Expects:
#   _cmd_names=()
#   _cmd_bodies=()
#   _cmd_args=()
#   _cmd_redirs=()
#   _cmd_outers=()
#   _cmd_wraps=()
#   _cmd_deps=()
#   _cmd_envs=()
#
#============
_cmd_extract()
{
    trap '_error "Problem when evaluating SPACE_ header variables or function body for: ${_fn_name}. Look for unbound variable or other syntax error."; trap - EXIT; return 1; ' EXIT
    local _space_cmds=("${SPACE_FN}")
    local _space_cmd_index=0
    while :; do
        # TODO: When we implement FORK, we have to consider
        # SPACE_ARGS, etc also.
        (( _space_cmd_index >= ${#_space_cmds[@]} )) && break
        SPACE_FN=${_space_cmds[$_space_cmd_index]}
        (( _space_cmd_index += 1))

        local _counter=0
        while :; do
            # Loop until we reach the "actual" function,
            # which is a function that does not chain to
            # another function using SPACE_FN="funcname".
            (( _counter += 1 ))
            if (( _counter > 100 )); then
                _error "Aborting! Looks like your function chaining using SPACE_FN is looping. Function: ${SPACE_FN}."
                trap - EXIT
                return 1
            fi

            local _fn_name= _fn_body=
            _get_fn "$SPACE_FN" "_fn_name" "_fn_body"
            if (( $? > 0 )); then
                _error "Function $SPACE_FN is not declared or syntax error."
                trap - EXIT
                return 1
            fi

            local _args=()
            _split_quoted "_args" "${SPACE_ARGS}"
            local _cmd_args_count=${#_args[@]};
            unset _args

            # Separate the SPACE_ variables header and the function body.
            local _space_cmd=$SPACE_FN
            local _fnlines=()
            local _spacelines=()
            _cmd_extract_space_header "${_fn_body}" "${_fn_name}" "${_cmd_args_count}" "0" "${SPACE_ARGS}"
            (( $? > 0 )) && { trap - EXIT; return 1; }

            # If we have any SPACE_ variables we evaluate them together
            # with the function arguments.
            if (( ${#_spacelines[@]} > 0 )); then
                local _SPACE_ARGS=$SPACE_ARGS
                local _fns=
                printf -v _fns "    %s\n" "${_spacelines[@]}"
                _fns="_set_args () {"$'\n'"${_fns}}"$'\n'"_set_args ${_SPACE_ARGS}"$'\n'
                eval "$_fns"
                if (( $? > 0 )); then
                    _error "Could not evaluate function header of ${SPACE_FN} to set SPACE_ variables."
                    trap - EXIT
                    return 1
                fi
                unset _fns
            fi
            unset _spacelines

            # Check if this function is a compile time wrapper for another function,
            # if so we want to evaluate it now to let it do its variable manipulation.
            #if [[ -n ${SPACE_CMDFORK} ]]; then
                # TODO: fork many commands from this command, by adding
                # to _space_cmds.
                # Not implemented yet.
            if [[ ${SPACE_FN} != ${_space_cmd} ]]; then
                local _SPACE_ARGS=$SPACE_ARGS
                local _fns=
                # Not using "set -e" anymore, if got too shakey (see http://mywiki.wooledge.org/BashFAQ/105).
                # printf -v _fns "set -e;\n%s\nset +e;\n" "${_fnlines[@]-:}"
                printf -v _fns "%s\n" "${_fnlines[@]-:}"
                local _export_vars=""
                if [ -n "${SPACE_ENV}" ]; then
                    # We will provide this in case SPACE_ARGS uses any of them.
                    _cmd_export_vars "${SPACE_ENV}" "${_fn_name}"
                fi
                _fns="_wrapper () {"$'\n'"${_fns}}"$'\n'"${_export_vars}"$'\n'"_wrapper ${_SPACE_ARGS}"$'\n'
                eval "$_fns"
                if (( $? > 0 )); then
                    _error "Error in wrapper function: ${_space_cmd}."
                    trap - EXIT
                    return 1
                fi
                unset _fns
            else
                # This function is the actual function.
                local _fn_def=
                local _fn_env="${SPACE_ENV}"
                printf -v _fn_def "%s\n" "${_fnlines[@]-:}"
                _fn_def="${_fn_name}()"$'\n'"{"$'\n'"${_fn_def}""}"$'\n\n'
                _cmd_add_fn_dep "${SPACE_DEP}" "${_fn_name}"
                if (( $? > 0 )); then trap - EXIT; return 1; fi

                # If SPACE_OUTER, then get that body and it's headers DEP/ENV values.
                # And we'll isolate this in a function to not pollute env variables.
                function _space_context2()
                {
                    # Isolate all SPACE header variables to not get overwritten,
                    # except SPACE_OUTERDEP and SPACE_OUTERENV.
                    local SPACE_DEP= SPACE_ENV= SPACE_REDIR=
                    local SPACE_WRAP= SPACE_FN= SPACE_ARGS="${SPACE_ARGS}"
                    if [ -n "${SPACE_OUTER}" ]; then
                        # The command is referring to an OUTER command.
                        # We will fetch the outer command's body and it's SPACE headers:
                        # SPACE_DEP, SPACE_ENV.
                        local _fn_name= _fn_body=
                        _get_fn "$SPACE_OUTER" "_fn_name" "_fn_body"
                        if (( $? > 0 )); then
                            _error "Function $SPACE_OUTER is not declared or syntax error."
                            trap - EXIT
                            return 1
                        fi
                        local _args=()
                        _split_quoted "_args" "${SPACE_OUTERARGS}"
                        local _cmd_args_count=${#_args[@]};
                        unset _args
                        local _fnlines=()
                        local _spacelines=()
                        _cmd_extract_space_header "${_fn_body}" "${_fn_name}" "${_cmd_args_count}" "1" "${SPACE_OUTERARGS}"
                        (( $? > 0 )) && { trap - EXIT; return 1; }
                        local _fn_def=
                        printf -v _fn_def "%s\n" "${_fnlines[@]-:}"
                        SPACE_OUTER="${_fn_name} ()"$'\n'"{"$'\n'"${_fn_def}""}"$'\n'"${_fn_name} ${SPACE_OUTERARGS}"$'\n\n'
                        # If we have any SPACE_ variables we evaluate them together
                        # with the function arguments.
                        if (( ${#_spacelines[@]} > 0 )); then
                            local _SPACE_ARGS=$SPACE_OUTERARGS
                            local _fns=
                            printf -v _fns "    %s\n" "${_spacelines[@]}"
                            _fns="_set_args () {"$'\n'"${_fns}}"$'\n'"_set_args ${_SPACE_ARGS}"$'\n'
                            eval "$_fns"
                            if (( $? > 0 )); then
                                _error "Could not evaluate function header of ${SPACE_OUTER} to set SPACE_ variables."
                                trap - EXIT
                                return 1
                            fi
                            unset _fns
                        fi
                        unset _spacelines
                        SPACE_OUTERENV="${SPACE_ENV}"
                        SPACE_OUTERDEP="${SPACE_DEP}"
                    fi
                }
                local SPACE_OUTERDEP=
                local SPACE_OUTERENV=
                _space_context2
                if (( $? > 0 )); then trap - EXIT; return 1; fi

                _add_cmd "${_fn_name}" "${_fn_def}" "${SPACE_ARGS}" "${SPACE_REDIR}" "${SPACE_OUTER}" "${SPACE_WRAP}" "${SPACE_DEP}" "${_fn_env}" "${SPACE_OUTERDEP}" "${SPACE_OUTERENV}"
                unset _fn_def
                break
            fi
        done
    done
    trap - EXIT
}

#==========
# _cmd_extract_space_header
#
# Helper function to extract space headers from the function body.
#
# Expects:
#   _fnlines
#   _spacelines
#   SPACE_xyz
#
#==========
_cmd_extract_space_header ()
{
    local _fn_body="$1"
    shift

    local _fn_name="$1"
    shift

    local _cmd_args_count="${1-}"
    shift || :

    local is_outercmd="${1-}"
    shift || :

    local _given_args="${1-}"
    shift || :

    # NOTE: This is a special case for now.
    # We do not want this line in the PRINT function.
    # But we do want it in all the other functions exported, for PRINT to use.
    [[ $_fn_name != "PRINT" ]] && _fnlines+=("    local _SPACE_NAME=\"${_fn_name}\"")

    local _line=
    local _isheader="1"
    while IFS= read -r _line; do
        # Disconsider comments when evaluating header line
        if [[ $_isheader == "1" ]]; then
            if [[ $_line =~ ^[\ ]*(SPACE_[^=]+)=(.+) ]]; then
                local _spacevar=${BASH_REMATCH[1]}
                if [[ ${_spacevar} == "SPACE_SIGNATURE" ]]; then
                    if [[ -n ${_cmd_args_count-} ]]; then
                        # Check so that signature matches.
                        local _signature=${BASH_REMATCH[2]}
                        [[ ${_signature:0:1} == \" ]] && _signature=${_signature:1}
                        [[ ${_signature: -1} == ";" ]] && _signature=${_signature:0:$((${#_signature}-1))}
                        [[ ${_signature: -1} == \" ]] && _signature=${_signature:0:$((${#_signature}-1))}
                        local _sigcount=0
                        local _signature2="${_signature}"
                        if [ "${_signature:0:1}" = "[" ]; then
                            _signature2=${_signature##*\]}
                        elif [ "${_signature: -1}" = "]" ]; then
                            _signature2=${_signature%%\[*}
                        else
                            _sigcount=$(( ${#_signature} > 0 ? 1 : 0 ))
                        fi
                        _signature2=${_signature2//[^\ ]}
                        (( _sigcount += ${#_signature2} ))
                        if (( _sigcount > _cmd_args_count )); then
                            _error "Missing $((_sigcount-_cmd_args_count)) argument(s). Function $_space_cmd has the signature: ${_signature}, but only these arguments where provided: ${_given_args}."
                            return 1
                        fi
                    fi
                elif [ "${is_outercmd}" = "1" ]; then
                    if [[ ${_spacevar} == "SPACE_ENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ENV=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_DEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_DEP=${BASH_REMATCH[2]}")
                    else
                        _error "Unknown SPACE HEADER variable: ${_spacevar}, in OUTER function: ${_fn_name}."
                        return 1
                    fi
                    continue
                else
                    if [[ ${_spacevar} == "SPACE_ENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ENV=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_DEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_DEP=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_REDIR" ]]; then
                        # Do not overwrite.
                        if [[ -z ${SPACE_REDIR} ]]; then
                            _spacelines+=("SPACE_REDIR=${BASH_REMATCH[2]}")
                        fi
                    elif [[ ${_spacevar} == "SPACE_OUTER" ]]; then
                        # Do not overwrite.
                        if [[ -z ${SPACE_OUTER} ]]; then
                            _spacelines+=("SPACE_OUTER=${BASH_REMATCH[2]}")
                        fi
                    elif [[ ${_spacevar} == "SPACE_OUTERARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_OUTERARGS=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_ARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ARGS=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_WRAP" ]]; then
                        # Always overwritten, but prepended to.
                        local _s="${BASH_REMATCH[2]}"
                        if [ "${_s:0:1}" = "\"" ]; then
                            _s="${_s:1}"
                        fi
                        if [ "${_s: -1}" = ";" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        if [ "${_s: -1}" = "\"" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        _spacelines+=("SPACE_WRAP=\"${_s}${SPACE_WRAP:+ ${SPACE_WRAP}}"\")
                        unset _s
                    elif [[ ${_spacevar} == "SPACE_FN" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_FN=${BASH_REMATCH[2]}")
                    else
                        _error "Unknown SPACE HEADER variable: ${_spacevar}, in function: ${_fn_name}."
                        return 1
                    fi
                fi
            elif [[ $_line =~ ^[\ ]*#.* ]]; then
                continue
            else
                # Stop extracting header if a row is not prefixed by "SPACE_" nor "#".
                _isheader="0"
            fi
        fi
        if [[ $_isheader == "0" ]]; then
            _fnlines+=("$_line")
        fi
    done <<< "${_fn_body}"
    unset _line _isheader
}

#==========
# _cmd_export_vars
#
# Expects:
#   _export_vars
#
#==========
_cmd_export_vars()
{
    local _fn_env="${1}"
    shift

    local _fn_name="${1}"
    shift

    trap '_error "Problem when evaluating SPACE_FN(OUTER)ENV header variables associated with ${_fn_name}. Look for unbound variable or syntax error in named function or in its chain of functions."; trap - EXIT; return 1; ' EXIT
    if [[ -n ${_fn_env} ]]; then
        local _fn_env_item= _k1= _k2= _v= _done=""
        for _fn_env_item in ${_fn_env}; do
            _k1=${_fn_env_item%%=*}
            if [[ ${_done} =~ (^|[\ ])${_k1}($|[\ ]) ]]; then
                # Variable already exported.
                continue;
            else
                _done="${_done} ${_k1}"
            fi
            _v=""
            if [[ ${_k1} == ${_fn_env_item} ]]; then
                _k2="\${${_fn_env_item}}"
                eval "_v=\"${_k2}\""
                if [ "$?" != "0" ]; then
                    _error "Problem when evaluating SPACE_FN(OUTER)ENV header variable '${_fn_env_item}' associated with fucntion ${_fn_name}. Look for unbound variable or syntax error in function ${_fn_name} or in its chain of functions."
                    trap - EXIT
                    return 1
                fi
            else
                _v=${_fn_env_item##*=}
            fi
            _escape "_v" '"'
            _export_vars="${_export_vars}${_k1}=\""$_v"\""$'\n'
        done
        unset _fn_env_item _k _v _done
    fi
    trap - EXIT
}

#============
# _cmd_add_fn_dep
#
# Helper function
#
# Expects:
#   _fn_def
#   _fn_env
#
#============
_cmd_add_fn_dep()
{
    local _fn_dep="${1-}"
    shift || :

    local _fn_name="${1-}"
    shift || :

    [[ -z ${_fn_dep} ]] && return 0

    local _fn_dep_name= _fn_dep_body= _fn_dep_item= _i=0 _arr=()
    IFS=' ' read -r -a _arr <<< "${_fn_dep}"
    while (( _i < ${#_arr[@]} )); do
        _fn_dep_item=${_arr[$_i]}
        (( _i += 1 ))
        # Check so that this function does not already exists in $_fn_def
        # to avoid multiple occurrences.
        if [[ ${_fn_def} =~ (.?)${_fn_dep_item}[\ ]*\(\)$'\n'\{[\ ]*$'\n' ]]; then
            if [ "${#BASH_REMATCH[1]}" -eq 0 -o "${BASH_REMATCH[1]}" = $'\n' ]; then
                continue
            fi
        fi
        _get_fn "${_fn_dep_item}" "_fn_dep_name" "_fn_dep_body"
        if (( $? > 0 )); then
            _error "Dependency function not found or syntax error: ${_fn_dep_item}. Referred from function: ${_fn_name}."
            return 1
        fi
        local _spacelines=() _fnlines=() _line=
        # We set some space header variable to non empty because we do not
        # want them returned in _spacelines.
        local SPACE_DEP= SPACE_ENV= SPACE_REDIR=1
        local SPACE_WRAP=1 SPACE_FN=1 SPACE_OUTER=1 SPACE_ARGS=1 SPACE_OUTERARGS=1
        _cmd_extract_space_header "${_fn_dep_body}" "${_fn_dep_name}"
        (( $? > 0 )) && return 1
        local _fns=
        printf -v _fns "    %s\n" "${_spacelines[@]-:}"
        _fns="_set_args () {"$'\n'"${_fns}}"$'\n'"_set_args"
        eval "$_fns"
        unset _fns
        local _fns=
        printf -v _fns "%s\n" "${_fnlines[@]-:}"
        _fn_def="${_fn_def}${_fn_dep_name}()"$'\n'"{"$'\n'"${_fns}}"$'\n\n'
        unset _fns
        if [[ -n ${SPACE_ENV} ]]; then
            _fn_env="${_fn_env} ${SPACE_ENV}"
        fi

        # Now check for further dependencies.
        if [[ -n ${SPACE_DEP} ]]; then
            local _arr2=() _item2=
            IFS=' ' read -r -a _arr2 <<< "${SPACE_DEP}"
            for _item2 in "${_arr2[@]}"; do
                if [[ ! ${_fn_dep} =~ (^|[\ ])${_item2}($|[\ ]) ]]; then
                    _arr+=("${_item2}")
                    _fn_dep="${_fn_dep} ${_item2}"
                fi
            done
            unset _arr2 _item2
        fi
        unset _spacelines _fnlines _line SPACE_DEP
    done
    unset _fn_dep_name _fn_dep_body _fn_dep_item _i _arr
}

#=========
# _add_cmd
#
# Add a command to be exported to the list, together with all its data.
#
#=========
_add_cmd()
{
    _cmd_names+=("${1-}")
    shift || :

    _cmd_bodies+=("${1-}")
    shift || :

    _cmd_args+=("${1-}")
    shift || :

    _cmd_redirs+=("${1-}")
    shift || :

    _cmd_outers+=("${1-}")
    shift || :

    _cmd_wraps+=("${1-}")
    shift || :

    _cmd_deps+=("${1-}")
    shift || :

    _cmd_envs+=("${1-}")
    shift || :

    _cmd_outerdeps+=("${1-}")
    shift || :

    _cmd_outerenvs+=("${1-}")
    shift || :
}

#============
# _escape_inline
#
# Used when evaluating environment variables.
#
#============
_escape_inline()
{
    eval "local var=${1}"
    shift

    _escape "var" '"'
    echo "\"${var}\""
}

#==========
# _escape
#
# Escape a variable which name is given by $1.
# Double quotes are escaped one up.
# Dollar signs are escaped one up.
#
#============
_escape()
{
    local _s=$1
    shift
    local _c=${1-\"\$}
    shift || :

    local _s2=${!_s}

    if [[ $_c =~ \" ]]; then
        _s2=${_s2//\"/\\\"}
        _s2=${_s2//\\\\\"/\\\\\\\"} # Adjust the odd ones...
    fi

    if [[ $_c =~ \$ ]]; then
        _s2=${_s2//\$/\\\$}
        _s2=${_s2//\\\\\$/\\\\\\\$} # Adjust the odd ones...
    fi

    eval "$_s=\$_s2"
    return 0
}

#===========
# _to_lower
#
# Lower case a string and echo it back.
# Probably slow, but works in Bash 3.
#
#===========
_to_lower()
{
    local _s=$1
    shift

    local _trans="abcdefghijklmnopqrstuvwxyz"

    local _s2=""
    local _i=
    local _c=
    local _ascii=
    for (( _i=0; _i<${#_s}; _i++ )); do
        _c=${_s:$_i:1}
        printf -v _ascii "%d" "'$_c"
        if (( _ascii >= 65 && _ascii <= 90 )); then
            ((_ascii-=65))
            _c=${_trans:$_ascii:1}
        fi
        _s2="${_s2}${_c}"
    done
    echo "${_s2}"
}

#==========
# _split_quoted
#
# Helper function to split a string into it's quoted components.
#
# Parameters:
#   $1 the variable name of the array to add extracted arguments to.
#   $2 The string to parse.
#
#==========
_split_quoted()
{
    # NOTE: This should have a neater solution, no?

    local _output=$1
    shift
    local _s=$1
    shift

    local _tag="_PAIRED_SPACE_TAG_"

    # Remove whitespace
    if [[ $_s =~ ^([ ])+(.*) ]]; then
        _s=${BASH_REMATCH[2]}
    fi

    while ((${#_s} > 0)); do
        local _del=
        if [[ ${_s:0:1} == \" ]]; then
            # Find next double quote which is not escaped.
            _del=\"
            _s=${_s:1}
        elif [[ ${_s:0:1} == \' ]]; then
            # Find next single quote which is not escaped.
            _del=\'
            _s=${_s:1}
        else
            _del=" "
        fi
        local _s2=${_s//$_del/$_tag}
        local _s2=${_s2//\\$_tag/\\$_del}
        local _s3=${_s2%%$_tag*}
        if [[ $_s2 == "$_s3" ]]; then
            # Closing not found, just take the rest.
            eval "$_output+=(\"\$_s\")"
            break
        fi
        local _pos=$((${#_s3}))
        local _s4=${_s:0:$_pos}
        _s4=${_s4//\\\"/\"}
        _s4=${_s4//\\\\\"/\\\"}  # Adjust some oddities.
        eval "$_output+=(\"\$_s4\")"
        ((_pos+=1))
        _s=${_s:$_pos}
        # Remove whitespace
        if [[ $_s =~ ^([ ])+(.*) ]]; then
            _s=${BASH_REMATCH[2]}
        fi
    done
}

#==========
# _get_fn
#
# Helper function to extract the body and name of a given function
#
# Parameters:
#   $1 Name of the function.
#   $2 Name of the variable to write to the fn name to.
#   $3 Name of the variable to write to the fn body to.
#
# Returns:
#   1 on error
#
#==========
_get_fn()
{
    local _cmdname=$1
    shift

    local _varname=$1
    shift

    local _varbody=$1
    shift

    # A special case for the dynamically defined function _anonymous.
    if [ "${_cmdname}" = "_anonymous" ]; then
        eval "${_varbody}=\${_anonymous}"
        eval "${_varname}=\${_cmdname}"
        return 0
    fi

    # Look through all loaded source files to find the declaration, in reverse order.
    local _i=$((${#_SOURCE_FILES_TOTAL[@]}-1))
    while [ "${_i}" -gt -1 ]; do
        _file="${_SOURCE_FILES_TOTAL[$_i]}"
        local _content="$(cat ${_file})"$'\n'  # We add a '\n' so that pattern matching below works properly.
        if [[ ${_content} =~ (.?)${_cmdname}[\ ]*\(\)$'\n'\{[\ ]*$'\n'(.*$'\n') ]]; then
            if [ "${#BASH_REMATCH[1]}" -eq 0 -o "${BASH_REMATCH[1]}" = $'\n' ]; then
                _content="${BASH_REMATCH[2]}"
                _content="${_content%%$'\n'\}$'\n'*}"
                eval "${_varbody}=\${_content}"
                eval "${_varname}=\${_cmdname}"
                return 0
            fi
        fi
        _i=$(( _i-1 ))
    done
    return 1
}

#===============
# _apply_cmd_env
#
# Apply the cmd line environment variables if provided.
#
# Expects:
#   _envE
#===============
_apply_cmd_env()
{
    local _ev=
    for _ev in "${_envE[@]-}"; do
        if [[ $_ev =~ ([_a-zA-Z0-9]+)=(.*) ]]; then
            local _varname=${BASH_REMATCH[1]}
            if [[ ${BASH_REMATCH[2]} == "!unset" ]]; then
                printf "%s\n" "unset $_varname"
            else
                printf "%s\n" "local $_varname=\"${BASH_REMATCH[2]}\""
            fi
        fi
    done
}

#=============
# push
#
# Push variable onto stack.
# Note: Only handles strings, for now.
#
# Parameters:
#   $1: variable name
#
#=============
push()
{
    ((_STACK_POINTER+=1))

    local _stname="${_STACK_PREFIX}${_STACK_POINTER}"
    eval "${_stname}=\$${1}"
}

#=============
# pop
#
# Pop variable from stack.
#
# Parameters:
#   $1: variable name to pop into.
#
#=============
pop()
{
    if ((_STACK_POINTER == 0)); then
        return 1;
    fi

    local _stname="${_STACK_PREFIX}${_STACK_POINTER}"
    eval "${1}=\$${_stname}"

    ((_STACK_POINTER-=1))
}

_main "$@"
