#!/usr/bin/env bash
###############################################################################
###          |                       !                                 |    ###
##           |                       .                                 |     ##
#            !                       _                                 !      #
#            .               S P A C E `..                             .      #
#            .         IoT automation - By.Blockie                     .      #
#                                         .                                   #
##           .                            .                                 .##
###                                                                        !###
##           .                                                             . ##
#            .                                                                #
#          __áˆ´__                                                              #
###############################################################################

#
# Copyright:
#   Blockie AB 2016-2017 (blockie.org)
#
# Authors:
#   Thomas Backlund (blund@blockie.org).
#   Maicon Filippsen (filippsen@blockie.org).
#
# Copying:
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation version 3 of the License.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Hacker's Guide:
#   See the man page and https://space.sh for more details.
#
# WHAT IS SpaceGal:
#   SpaceGal is a suite of tools and services for automating the Internet of Things (IoT),
#   aimed to provide small footprint automation for IoT devices,
#   servers and life in general.
#
#   The SpaceGal shell is this Bash script, referred to as "Space" below.
#   The SpaceGal shell's site is found at https://space.sh.
#
# Bash compatibility:
#   Space is made to work with Bash version 3.2 and upwards.
#   It has been tested using Bash 3.2.57 and several Bash 4 versions.
#
# EXTERNAL programs:
#   Space uses some external programs for certain tasks,
#   mostly coupled to tasks that involve disk and/or network access.
#   These external programs are not all POSIX 1003.1 compliant but have been
#   tested to work with GNU/Linux, BusyBox and OSX.
#   Search for the word EXTERNAL to see where and how they are used.
#
# Static analysis:
#   Space cares about hints from static analysis tools. However, it has chosen not to disable friendly diagnostics and warnings.
#   Below is a list of warnings which are considered harmless:
#   <shellcheck> --exclude=2181
#

# Exit when trying to access undeclared variables.
set -o nounset

#==========
# GLOBALS
#==========


#
# Program
#

# Version
readonly _VERSION="0.13.0"
# Find absolute path to bash binary
if command -v bash >/dev/null; then
    readonly _BASHBIN=$(command -v bash)
else
    readonly _BASHBIN="${BASH-}"
fi
# Full path the space script it self.
readonly _SPACEBIN=$0
# Absolute path to the directory where space is located.
readonly _BASEDIR=$( cd "${_SPACEBIN%/*}" 2>/dev/null && pwd )
# Usage help string
readonly _USAGE="Usage:
    space [-f|m namespace [-M modules] [-ep key=value] [node] [-a]] [-vkKCX value] [-dlShgZB] [-- args]
    space [-hVQu]
    space -U [module]"

#
# Output configuration
#

# Set log level for final script in interval [0,5]
# Inherited from environment and forwarded to final script.
SPACE_LOG_LEVEL=${SPACE_LOG_LEVEL:-4}

# Enable colored message output
# Inherited from environment
# Also used internally for Space.
SPACE_LOG_ENABLE_COLORS=${SPACE_LOG_ENABLE_COLORS:-1}
_LOG_ENABLE_COLORS=${SPACE_LOG_ENABLE_COLORS}

# The expected script exit status.
# This is exported to script, it's not a SPACE header variable.
SPACE_ASSERT_EXIT=0

# Set to 1 to ignore exit status and always return 0.
# This is exported to script, it's not a SPACE header variable.
SPACE_MUTE_EXIT=0

# The verbosity level: 0-4 [none-everything]
_VERBOSITY=3
# Set to 1 to output the preprocessed YAML result.
_DEBUG_OUTPUT_PREPROCESSED=0
# Set to 1 to output the parsed YAML to Bash
_DEBUG_OUTPUT_PARSED=0
# Set to 1 to output the re-transformed YAML, back from Bash
_DEBUG_OUTPUT_TRANSFORMED_YAML=0
# Set to 1 to output all _loadnode eval code.
_DEBUG_OUTPUT_ENV=0


#
# Modules settings
#

# Shared directory for cloning modules into.
_MODULES_SHARED=${SPACE_MODULES_SHARED:-~/.space/space_modules}

#
# Modules parsing and processing
#

# This must always be underscore prefixed.
# Should not be changed during runtime.
_YAML_PREFIX="_sg"
# This should be changed when loading and working on different YAML documents.
_YAML_NAMESPACE=1
# Tag we use for here documents.
readonly _SPACEGAL_EOF_TAG="_SPACEGAL_SAYS_END_OF_FINITY_"
# Use caching. 0 = no, 1 = yes (default), 2 = regenerate cache.
_CACHE_LEVEL=1
# Internal identifier of the cache files current format.
readonly _CACHE_FORMAT="2.3"

# Array of files that will get sourced before executing.
# Added using _source function.
_SOURCE_FILES=()
# A complete and unique list of all sh/bash files sourced using _source,
# including space itself.
_SOURCE_FILES_TOTAL=("${0}")
# Internal variable automatically set when Bash completion is performed.
_BASH_COMPLETION=0
readonly _COLOR_DEFAULT="\033[0m"
readonly _COLOR_FG_RED="\033[31m"
readonly _COLOR_FG_GREEN="\033[32m"
readonly _COLOR_FG_YELLOW="\033[33m"
readonly _COLOR_FG_MAGENTA="\033[35m"
readonly _COLOR_FG_CYAN="\033[36m"
readonly _COLOR_FG_WHITE="\033[37m"

# Override column position for print function
_PRINT_COLUMN_POSITION="0"

# These are environment variables to be overwritten in the YAML or by Space functions.
# They are intentionally not inherited from the Bash environment.
unset SPACE_ARGS
unset RUN_ALIAS
unset RUN
unset SPACE_OUTER
unset SPACE_OUTERARGS
unset SPACE_REDIR
unset SPACE_DEP
unset SPACE_ENV
unset SPACE_WRAP
unset SPACE_WRAPARGS

# Figure out if there's a shasum executable in the OS.
# We use this for caching purposes, so not required.
# EXTERNAL: sha256sum, sha1sum, shasum.
if command -v sha256sum >/dev/null; then
    readonly _SHASUMBIN=sha256sum
elif command -v sha1sum >/dev/null; then
    readonly _SHASUMBIN=sha1sum
elif command -v shasum >/dev/null; then
    readonly _SHASUMBIN="shasum -a 256"
else
    readonly _SHASUMBIN=
fi

# Figure out if curl or wget is installed in the OS.
# We use this for checking modules against banlists
# and also as fallback for downloading modules if Git
# is not installed.
# EXTERNAL: curl, wget
if command -v curl >/dev/null; then
    readonly _HTTPBIN=curl
elif command -v wget >/dev/null; then
    readonly _HTTPBIN=wget
else
    readonly _HTTPBIN=
fi

# Find out if uname is available
# EXTERNAL: uname
if command -v uname >/dev/null; then
    readonly _UNAMEBIN="uname"
    readonly _UNAME="$_UNAMEBIN -srvm"
else
    readonly _UNAMEBIN=""
    readonly _UNAME=""
fi

# The server we consult to check if a module is banned.
readonly _SECURITY_BAN_SERVER="https://get.space.sh/verify_module"

# Check the Git url to clone or update against the banlist.
#  0=do not check at all
#  1=check and accept "unknown" and "non banned" modules.
#  2=check and require "trusted" status for module.
_SECURITY_CHECK_BANNED=1

# Verify the modules Git commit signature against web-of-trust.
#  0=do not very signature at all.
#  1=accept marginal trust.
#  2=only accept full trust.
_SECURITY_GPG_VERIFY_SIGNATURE=0

# Stack current pointer
_STACK_POINTER=0

# Stack name prefix
_STACK_PREFIX="_stack_"

# Set to "1" to force to run export in Bash.
# Will autoamtically be set to "1" if any module
# loaded with a .bash file.
_FORCE_BASH="0"

# Set HTTPS tarball download using curl/wget.
_FORCE_HTTPS_FALLBACK=0

# Set to "1" to enable GUI
_ENABLE_GUI="0"

# Set to "0" to disable Space checking modules version compatibility
_MODULE_CHECK_VERSION_COMPATIBILITY="1"

# Minimum requirements file
readonly _MODULE_REQUIREMENT_FILE_NAME="space-requirement.txt"

# Stable version description file
readonly _MODULE_STABLE_FILE_NAME="space-module.txt"

# Set to "1" to allow Space to use
# external OS tools to speed things up.
# Like awk, sort, etc.
_ALLOW_EXTERNAL="1"

#==========
# _helpusage
#
# Outputs help and usage text
#==========
_helpusage()
{
    local _s=
    IFS= read -d '' -r _s << _EOF
Space. (C) Blockie AB 2016-2017, blockie.org. GPL version 3 licensed.

See man pages and https://space.sh for more info.

$_USAGE

          -f  YAML file to load, relative or absolute path, defaults to: ./Spacefile.yaml.
              -f and -m options define namespaces in where to look for nodes, for a given dimension of nodes.
              There can be maximum three namespaces and three dimensions. One namespace can have more than one dimension.
              Dimension two and three could be found from namespace one below the node in dimension 1.
              If only one dimension is given Space looks below "node/_dimensions/second" for a space separated set of lists that makes up the second dimension.
              The second dimension then uses second namespace if defined else first namespace.
              If two dimensions are given Space looks below "node/_dimensions/third" for a space separated list, each list object's "match" node is matched
              against the node in the second dimension, if match then the list below "nodes" makes up the third dimension.
              The third dimension then uses third namespace if defined else first namespace.
          -m  [giturl/][username]/reponame module to run.
              Direct access to run nodes in a module.
              Only the Space specific user gitlab.com/space-sh could be denoted using
              only reponame, then username is defaulted to space-sh and giturl is
              defaulted to https://gitlab.com/.
              All other users must specify domainname/username/reponame, for example
              ssh://gitlab.com/filippsen/somemodule.
              The protocol defaults to https.
          -M  [giturl/][username]/reponame module to load. (e.g. \"gitlab.com/blockie-org/amodule\")
              Clone and load a modules shell file. Separate multiple by space within quotes,
              or use multiple -M switches, one for each module.
              Use this to load a modules shell file but not it's yaml counterpart.
              Example: space -m os /info/ -M ssh -e SPACE_WRAP=SSH_WRAP -e SSHHOST=1.2.3.4
              Using the -M switch alone will not do anything since Space needs a target node to load.
              -M modules shell scripts are loaded after -m module shell scripts and can override functions.
              If a scripts funnctions loaded using -M has dependencies on other modules they must then also be provided using -M.
          -e  environment variable to forcefully apply/overwrite before parsing the YAML.
              -e var1="value1".
              Use one -e for each variable.
              To unset a variable use -evar1='!unset'
          -E  file with variable definitions to apply after -e variables, on the format of a shell file:
                Example:
                    var1=value
                    # Comments on single lines are ignored.
                    export var2=value
              Use one -E for each file to load.
          -p  preprocess variable to set before preprocessing.
              -p inventory=staging.
              Use one -p for each variable.
          -v  verbosity level, 0 = off, 1 = error, 2 = warning, 3 = info, 4 = debug.
              Default is 2. Outputs to stderr.
          -d  dry run. Will echo the Bash command line computed instead of running it.
          -l  list nodes. Do not run anything, only output the nodes matched.
          -k  Check modules against the ban list. 0 = off, 1 = accept unknown modules
              but not banned modules, 2 = require module to be known and not banned.
              Default = 1.
          -K  Verify module Git HEAD signature using GPG. 0 = off,
              1 = accept moderate trust, 2 = only accept full trust signatures.
              Default = 1.
          -S  Set HTTPS fallback for downloading modules using curl or wget.
          -h  help, show Space usage or help on specific node.
          node(s) Pattern of one or many nodes to run.
              If no node path is given the root node "/" is implied.
              If node path(s) are given but none matches then Space aborts.
              A node pattern is defined after a namespace (-f/-m) and then belongs to that namespace.
              Nodes support regular expressions to run multiple nodes in sequence.
              Ex: "/west/.*" will match all nodes below /west/,
                  "/we.*/ will match /west/ and /web/ nodes.
                  When using asterisk make sure you use quotes so that
                  Bash will not expand that before passing it to Space as arguments.
                  /we{st,b}/ without quotes will get expanded by Bash as two arguments
                  /west/ and /web/ that are passed to Space, which is cool of that is what you meant.
          -V  show Space version information
          -a  All. Adds a ".*" to the node it suffixes, to match all it's nodes below.
          -C  caching level, 0 = off, 1 = on (default), 2 = regenerate cache.
          -B  Set to force to run modules in Bash. Normally Bash dependency depends
              on module script files ending in .bash instead of .sh.
          -Q  Queries updates and general state of the SpaceGal services.
          -u  Update current Space install to the latest version.
          -U  Update module(s). Performs a Git pull on matched module(s) then quit.
              Space will update repositories both in local space_modules and also in shared space_modules directories.
              -U ""    means update all modules.
              -U "ssh" means update gitlab.com/space-sh/ssh.
              -U "gitlab.com/blockie-org/ssh" means update gitlab.com/blockie-org/ssh repository.
              -U "space-sh/.*" means update every module for the space-sh user on gitlab.com.
          -X  Outputs debug information.
              1 = preprocessed YAML result, 2 = YAML parsed to Bash, 3 = YAML loaded from Bash (retransformed), 4 = eval code
          -g  Enable graphical user interface. Defaults to 0, disabled.
          -Z  Skips checking modules version compatibility against current Space version

Examples:

# Load a module named "os" from the official Space repositories and run the node named "info"
space -m "os" /info/

# Load and run a local module and show description for its root node
space -f Spacefile.yaml / -h

_EOF
    printf "%s" "$_s" >&2
}

#==========
# _helpversion
#
# Outputs version information
#
# Expects:
#   _VERSION
#
#==========
_helpversion()
{
    local _s=
    IFS= read -d '' -r _s << _EOF
Space $_VERSION
_EOF
    printf "%s" "$_s" >&2
}

#==========
# _helpnode
#
# Outputs help on a node.
#
# Parameters:
#   $1: slash-separated path of node to show help for. The path must end with a slash. E.g. "/parent_node/node1/node2/"
#
# Expects:
#   nodes must be loaded prior to calling this function because copy and list operations rely on node variables already being defined
#
#==========
_helpnode()
{
    local _path=$1
    shift

    _print "$_path"

    local _str=
    _copy "_str" "${_path}_info/title"
    _print $'\t'"${_str//$'\n'/$'\n'$'\t'}"$'\n'
    _copy "_str" "${_path}_info/desc"
    if [ -n "$_str" ]; then
        _print $'\t'"${_str//$'\n'/$'\n'$'\t'}"$'\n'
    fi

    local _listItems=()
    _list "_listItems" "${_path}"
    local _item=
    if [ "${#_listItems[@]}" -gt 0 ]; then
        for _item in "${_listItems[@]}"; do
            _print "+ $_item"
        done
    fi
}

#========
# _transform_to_yaml
#
# Go thru the whole parsed and evaluated YAML structure and output it in YAML format.
#
# Parameters:
#   $1: slash-separated path to start at. Does NOT end with a slash.
#   $2: last node of given path
#   $3: indent spaces
#
# Expects:
#   nodes must be loaded prior to calling this function because copy and list operations rely on node variables already being defined
#
#========
_transform_to_yaml()
{
    local _path=${1-}
    shift || :
    local _node=${1-}
    shift || :
    local _indent=${1-}
    shift || :

    local _value=
    _copy "_value" "$_path"
    if [ -z "$_value" ]; then
        # No leaf, recurse it.
        if [ -n "$_node" ]; then
            printf "%s%s%s\n" "$_indent" "$_node" ":"
        fi
        local _keys=()
        _path="$_path/"
        _list "_keys" "$_path" "1" "1"
        local _key=
        if [ "${#_keys[@]}" -gt 0 ]; then
            for _key in "${_keys[@]}"; do
                if [ "$_path" = "/" ]; then
                    local _indent2=$_indent
                else
                    local _indent2="$_indent    "
                fi
                _transform_to_yaml "$_path$_key" "$_key" "$_indent2"
            done
        fi
    else
        # Is leaf.
        if [ "${_value//$'\n'}" != "${_value}" ]; then
            local _trailingnewline="-"
            if [ "${_value: -1}" = $'\n' ]; then
                _trailingnewline=""
                _value="${_value:0:$((${#_value}-1))}"
            fi
            local _multiline="${_indent}    ${_value//$'\n'/$'\n'$_indent    }"
            printf "%s%s%s\n" "$_indent" "$_node" ": |${_trailingnewline}"
            printf "%s\n" "${_multiline}"
        else
            # We might want to split up long strings using multiline.
            printf "%s%s%s%s\n" "$_indent" "$_node" ": " "${_value}"
        fi
    fi
}

#========
# _list
#
# List all nodes below a given node.
#
# Parameters:
#   $1: name of output array to append to
#   $2: slash-separated path, starts and ends with slash.
#   $3: include_hidden, set to "1" to include leaf nodes beginning with underscore.
#   $4: include leaf node, set to "1" to include leaf nodes.
#
# Expects:
#   _parsedyamlnodelist*
#   _YAML_NAMESPACE
#   _YAML_PREFIX
#
#========
_list()
{
    local _output=$1
    shift

    local _path=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    if [[ ! $_path =~ (^/.+/$)|(^/$) ]]; then
        _error "Malformed path ($_path) as argument to _list. Must start and end with a slash. Lonesome cowboy slashes are OK dough."
        return 1
    fi

    local _nodes=()
    _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}" "${_path}.*/" "${_includehidden}" "1" "${_includeleafs}"
    if [ "${#_nodes[@]}" -eq 0 ]; then
        eval "${_output}=()"
    else
        eval "${_output}=(\"\${_nodes[@]}\")"
    fi
}


#==========
# _copy
#
# Copy a YAML variable (leaf) to another variable by assignment.
#
# Parameters:
#   $1: the name of the variable to copy to.
#   $2: the slash-separated _path of the variable to copy. Does NOT end with slash.
#
# Expects:
#   _YAML_PREFIX
#   _YAML_NAMESPACE
#
# Returns:
#   1 if the variable to copy was undefined.
#
#==========
_copy()
{
    local __var=$1
    shift

    local __path=$1
    shift

    __path=${__path//_/0x5f}
    __path="${_YAML_PREFIX}${_YAML_NAMESPACE}${__path//\//_}"
    local __ret=0
    if [ "${!__path+set}" != "set" ]; then
        __ret=1
    fi
    eval "$__var=\${$__path-}"
    return "${__ret}"
}

#==========
# _quicksort
#
# Quick sort an array of string and return output
#
# Integral parts of each line will be padded with zeroes
# for 10 digits. This is so that integral comparison
# makes sense in an ASCII comparable way. Otherwise
# "2 is greater than "10", etc, which is not what we want.
# However "0000000002" < "10", which gives us what we expect.
#
# Parameters:
#   $1: name of array of strings to sort
#   _quicksort_output: array where results are stored. This is expected to be defined by the caller
#
#==========
_quicksort()
{
    _quicksort_output=()

    # Early return and stop condition
    if [ $# -eq 0 ]; then
        return 0
    fi

    local str=''
    local _line1padded=''

    if [ "${_ALLOW_EXTERNAL}" = "1" ]; then
        local _arr=()
        for str in "$@"; do
            _sort_pad "_line1padded" "$str"
            _arr+=("$_line1padded $str")
        done
        while IFS=$'\n' read -r _line; do
            _quicksort_output+=("$_line")
        done < <(printf "%s\n" "${_arr[@]}" | sort | awk '{print $3" "$4}')
        return
    fi

    local _partition_a=()
    local _partition_b=()
    local _line2padded=''
    local _pivot=$1
    shift

    # A/B split
    for str in "$@"; do
        _sort_pad "_line1padded" "$str"
        _sort_pad "_line2padded" "$_pivot"

        if [[ "$_line1padded" > "$_line2padded" ]]; then
            _partition_b+=("$str")
        else
            _partition_a+=("$str")
        fi
    done

    # Recursion on A side
    if [ "${#_partition_a[@]}" -gt 0 ]; then
        _quicksort "${_partition_a[@]}"
        _partition_a=("${_quicksort_output[@]}")
    fi

    # Recursion on B side
    if [ "${#_partition_b[@]}" -gt 0 ]; then
        _quicksort "${_partition_b[@]}"
        _partition_b=("${_quicksort_output[@]}")
    fi

    # Merge results
    _quicksort_output=()
    if [ "${#_partition_a[@]}" -gt 0 ]; then
        _quicksort_output+=("${_partition_a[@]}")
    fi
    _quicksort_output+=("$_pivot")
    if [ "${#_partition_b[@]}" -gt 0 ]; then
        _quicksort_output+=("${_partition_b[@]}")
    fi
}


#==========
# _sort_pad
#
# Helper function for comparison routines to pad number parts of string to 10 digits.
# Example: "1" padded turns into "0000000001"
#
# Parameters:
#   $1: name of variable to store result in.
#   $2: string to zero pad to 10 digits.
#
#==========
_sort_pad()
{
    local _output=$1
    shift

    local _s=$1
    shift

    local _s2="" _tmp=""
    while [[ $_s =~ ([^0-9.]*)([0-9]+)(.*) ]]; do
        printf -v _tmp "%010d" "${BASH_REMATCH[2]}"
        _s2=$_s2${BASH_REMATCH[1]}$_tmp
        _s=${BASH_REMATCH[3]}
    done
    _s2=$_s2$_s
    eval "$_output=\$_s2"
}

#=============
# _source_added
#
# Source all sh/bash files added so far with _source and then resets the list.
#
# Expects:
#   _SOURCE_FILES
#
#=============
_source_added()
{
    local _file=''
    local _i=0
    while [ "$_i" -lt "${#_SOURCE_FILES[@]}" ]; do
        _file=${_SOURCE_FILES[$_i]}
        _source_file "${_file}"
        [ "$?" -gt 0 ] && return 1
        _i=$(( _i + 1 ))
    done
    unset _file _i
    _SOURCE_FILES=()    # Reset the list.
}

#=============
# _source
#
# Add a file to be sourced later, before execution.
#
# Parameters:
#   $1: file name
#
# Expects:
#   _SOURCE_FILES
#
#=============
_source()
{
    local _filename=$1
    shift

    _debug "Add source: \"$_filename\""

    if [ "${_filename##*.}" = "bash" ]; then
        _FORCE_BASH="1"
    fi

    _SOURCE_FILES+=("$_filename")
}

#==========
# _source_file
#
# Source a file, but never actually sourcing it.
# Only checking that it exists and adding it to the
# list of files from which we can extract functions from.
# Any code outside functions will be ignored.
#
# Parameters:
#   $1: file path(s), relative or absolute.
#
# Expects:
#   _SOURCE_FILES_TOTAL
#
#==========
_source_file()
{
    local _filepaths=$1
    shift

    local _filepath=''
    for _filepath in $_filepaths; do
        if [ ! -f "$_filepath" ]; then
            _error "Could not source file \"$_filepath\". Try to run space using -C0 flag to invalidate the cache and have modules cloned again if they were removed."
            return 1
        fi
        local _i=
        for ((_i=0; _i<${#_SOURCE_FILES_TOTAL[@]}; _i+=1 )); do
            if [[ $_filepath == "${_SOURCE_FILES_TOTAL[$_i]}" ]]; then
                continue 2
            fi
        done
        unset _i
        if [ ! -e "${_filepath}" ]; then
            _error "Could not find and source file: ${_filepath}."
            return 1
        fi
        _SOURCE_FILES_TOTAL+=("${_filepath}")
    done
}

#==========
# _parse_yaml
#
# Parse well formatted YAML document into Bash variables.
#
# Parameters:
#   $1: name of variable to read YAML from.
#   $2: name of array variable to append to.
#   $3: name of array to use as completion array.
#
# Expects:
#   _SPACEGAL_EOF_TAG
#   array items must be indented at least one space from its parents
#
#==========
_parse_yaml()
{
    local _invarname=$1
    shift
    local _outvarname=$1
    shift
    local _outcompletionvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${${_invarname}[@]}\")"

    local _numrows=${#_allrows[@]}
    local _rowindex=0
    local _lastindent=0 _nodes=("/") _lastkey="" _prefix="/"
    local _indent=0 _rowtype='' _key='' _readahead=() _nextindent=0
    local _arrayextraindent=0
    local _output=''

    while _yaml_get_next 0;
    do
        # Set node prefix for changed indentation level.
        if [ "$_indent" -gt "$_lastindent" ]; then
            # Increasing indentation level, add to prefix.
            _prefix="$_prefix$_lastkey/"
            _nodes[$_indent]=$_prefix
        elif [ "$_indent" -lt "$_lastindent" ]; then
            # Decreasing indentation level, fallback to earlier prefix.
            _prefix=${_nodes[$_indent]}
        fi
        _lastindent=$_indent
        case "${_rowtype}" in
            leaf) # A regular key value row.
                local _varname=$_prefix$_key

                # Add to node name completion list.
                local _completionname="${_varname}/"
                local _item=
                # Break down the path and add each sub path as completion name, early quit when
                # a path is found since we are guaranteed all the remaining sub paths are already added.
                while :; do
                    eval '
                    for _item in "${'$_outcompletionvarname'[@]-}"; do
                        if [[ $_item == "${_completionname} 0" || $_item == "${_completionname} 1" ]]; then
                            break 2
                        fi
                    done
                    '
                    if [ "$_completionname" = "${_varname}/" ]; then
                        # The leaf node
                        eval "$_outcompletionvarname+=(\"${_completionname} 1\")"
                    else
                        eval "$_outcompletionvarname+=(\"${_completionname} 0\")"
                    fi
                    if [ $_completionname = "/" ]; then
                        break
                    fi
                    _completionname=${_completionname%/*/}/
                done
                unset _item
                unset _completionname

                _varname=${_varname//_/0x5f}
                _varname=${_varname//\//_}
                if ((${#_readahead[@]} == 0)); then
                    # Simulate multiline value for the single line
                    if [[ ${value//\ } != "" ]]; then
                        _readahead[0]="$value"
                    else
                        _readahead[0]=""
                    fi
                else
                    # Newlines and multiline strings....
                    if [[ ${value:0:10} == "!nospace >" ]]; then
                        # Collapse newlines into one line non-space separated
                        printf -v _s "%s" "${_readahead[@]}"
                        _readahead=("$_s")
                        if [[ ${value:10:1} != "-" ]]; then
                            # Make for trailing newline.
                            _readahead+=("")
                        fi
                    elif [[ ${value:0:1} == ">" ]]; then
                        # Collapse newlines into one line space separated
                        local _s=${_readahead[*]}
                        _readahead=("$_s")
                        if [[ ${value:1:1} != "-" ]]; then
                            # Make for trailing newline.
                            _readahead+=("")
                        fi
                    elif [[ ${value:0:1} == "|" ]]; then
                        if [[ ${value:1:1} != "-" ]]; then
                            # Make for trailing newline.
                            _readahead+=("")
                        fi
                    fi
                fi
                eval "$_outvarname+=(\"\$_varname\")"
                local _line=
                for _line in "${_readahead[@]}"; do
                    local _line2=${_line/$_SPACEGAL_EOF_TAG}
                    if [ "${_line}" != "${_line2}" ]; then
                        _error "YAML line cannot contain the reserved EOF tag."
                        return 1
                    fi
                    eval "$_outvarname+=(\"\$_line\")"
                done
                eval "$_outvarname+=(\"\$_SPACEGAL_EOF_TAG\")"
                _lastkey=$_key
                ;;
            object) # Start of new object
                _lastkey=$_key
                ;;
            arrayobject)
                # New array object begins
                # Output key index at given indent
                local _i=$(($_indent+$_arrayextraindent))
                local _varname="_index_count${_prefix//\//_}"
                local _count=${!_varname-0}
                eval "local $_varname=$(($_count+1))"
                local _subrows=()
                # Reinsert the key value of first line to have it handled as a normal leaf.
                if [ -z "$_key" ]; then
                    printf -v _output "%*s%s" $_i "" "$_count: $value"
                else
                    printf -v _output "%*s%s" $_i "" "$_key: $value"
                fi
                _subrows+=("$_output")
                if ((${#_readahead[@]} > 0)); then
                    _i=$(( _i + 4 ))
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        printf -v _output "%*s%s" $_i "" "$_line"
                        _subrows+=("$_output")
                    done
                fi
                _allrows=("${_allrows[@]:0:$_rowindex}" "${_subrows[@]}" \
                    "${_allrows[@]:$_rowindex:$_numrows-$_rowindex}")
                ((_numrows+=${#_subrows[@]}))
                _lastkey=$_count
                ;;
        esac
    done
}

#==========
# _pp_yaml
#
# Preprocess YAML
#
# Parameters:
#   $1: name of variable to store result in.
#   $2: filepath to read YAML from.
#   $3: filter
#   $4: subdoc
#   $5-x: preprocess variable value assigned to @1, etc.
#
# Expects:
#   _yamlfilelist
#   _SPACEGAL_EOF_TAG
#   _CACHE_LEVEL
#
# Returns:
#   1 if YAML file not found.
#   2 if recursion error occurred.
#   3 if failed to clone modules 
#   4 if assertion failure was triggered.
#
#==========
_pp_yaml()
{
    local _varname=$1
    shift
    local _filepath=$1
    shift
    local _filter=${1:-/}
    shift || :
    local _inheritedindent=${1:-0}
    shift || :
    local _inheritedprefix=${1-/}
    shift || :
    # Read preprocess variables
    local _count=1
    while [ ${#@} -gt 0 ]; do
        eval "local _PP_$_count=\$1"
        shift
        _count=$(( _count + 1 ))
    done
    # Reset all other preprocess @include variables
    while [ "${_count}" -lt 10 ]; do
        # We first set the variable as local, then unset it.
        # We can't unset it right away becaue that would unset it in the caller context.
        eval "local _PP_$_count="
        eval "unset _PP_$_count"
        _count=$(( _count + 1 ))
    done
    local _subdoc=()
    if [[ -n ${_readahead[@]-} && (( ${#_readahead[@]} > 0 )) ]]; then
        _subdoc=("${_readahead[@]}")  # Inherited from recursive parent.
    fi

    # Look at the filepath if it's relative
    # and search through paths to find the file.
    if [[ ${_filepath:0:1} != "/" ]]; then
        local _dir=
        while :; do
            # Check path relative to current YAML file's dir _PP_DIR.
            if [ -f "$_PP_DIR/$_filepath" ]; then
                _filepath=$_PP_DIR/$_filepath
                break
            fi
            for _dir in ${_INCLUDEPATH[@]}; do
                if [ -f "$_dir/$_filepath" ]; then
                    _filepath=$_dir/$_filepath
                    break
                fi
            done
            break
        done
    fi

    # Check so that the YAML file exists.
    if [ ! -e "$_filepath" ]; then
        return 2
    fi

    # Preprocess variable that points to the dir of the YAML file being processed.
    local _PP_DIR=${_filepath%/*}

    local _allrows=() _rowindex=0
    # Read all lines and keeping blank lines for correct row counting.
    local _aline=
    while IFS= read  -r _aline; do
        _allrows+=("${_aline}")
    done < "${_filepath}"
    unset _aline
    local _numrows=${#_allrows[@]}

    if [[ ! $_yamlfilelist =~ "$_filepath " ]]; then
        _yamlfilelist="${_yamlfilelist}$_filepath "
    fi

    local _lastindent=0 _filterindent=-1 _nodes=("/") _lastkey="" _prefix="/"
    local _indent=0 _rowtype='' _key='' _readahead=() _nextindent=0
    local _includefile='' _includefilter='' _includevariables=''
    local _arrayextraindent=0 _output=''
    local _isarrayobjectfiltered=0
    while _yaml_get_next 1;
    do
        if [ "$_rowtype" = "" ]; then
            continue;
        fi

        # Set node prefix for changed indentation level.
        if [ "$_indent" -gt "$_lastindent" ]; then
            # Increasing indentation level, add to prefix.
            _prefix=$_prefix$_lastkey\/
            _nodes[$_indent]=$_prefix
        elif [ "$_indent" -lt "$_lastindent" ]; then
            # Decreasing indentation level, fallback to earlier prefix.
            _prefix=${_nodes[$_indent]}
        fi
        _lastkey=$_key
        _lastindent=$_indent

        # We use this to recognize @includes as immediate child nodes to get the
        # subdoc insertion correctly done for multiple includes.
        local _immediatechild=0

        # Check if filtering wants this.
        if [[ "$_prefix$_key" =~ ^$_filter ]] || [[ -z $_key && "$_prefix${_key}.*" =~ ^$_filter ]]; then
            # Filter matched, if first time save indent as the base level indent.
            if [ "$_filterindent" -eq -1 ]; then
                _filterindent=$_indent
            fi
            if [[ $_rowtype != "assign" && $_rowtype != "assert"  && $_rowtype != "cache" && $_rowtype != "dotdot" && $_rowtype != "prompt" && $_rowtype != "source"  && $_rowtype != "debug" && $_rowtype != "clone" && ${_key:0:1} != "_" && "$_prefix$_key/" =~ ^${_filter}([a-zA-Z0-9_])+/$ ]]; then
                _immediatechild=1
            fi
            if [[ $_rowtype == "include" && "$_prefix$_key/" =~ ^${_filter}/$ ]]; then
                _immediatechild=2

            fi
            # Check if we are on an immediate child to the filtered match and
            # that it is an object node, if so inject subdoc if given.
            if [[ $_immediatechild == 1 && ${#_subdoc[@]} -gt 0 ]]; then
                local _subrow= _subrows=()
                for _subrow in "${_subdoc[@]}"; do
                    local _i=$(($_indent+$_nextindent))
                    printf -v _subrow "%*s%s" $_i "" "$_subrow"
                    _subrows+=("$_subrow")
                done
                _allrows=("${_allrows[@]:0:$_rowindex}" "${_subrows[@]}" \
                    "${_allrows[@]:$_rowindex:$_numrows-$_rowindex}")
                ((_numrows+=${#_subrows[@]}))
            fi
        else
            _filterindent=-1
            continue
        fi

        local _actualindent=$(($_indent-$_filterindent+$_inheritedindent))
        # Here we need to do the postponed preprocess variable substitution of @{PARENT} and @{PARENTPATH}.
        local _parentpath=
        _parentpath=$_inheritedprefix${_prefix#$_filter}
        _key=${_key//_PP_PARENTPATH/$_parentpath}
        value=${value//_PP_PARENTPATH/$_parentpath}

        local _s=${_parents[$_actualindent]-}  # Get preprocess variable "parent".
        _key=${_key//_PP_PARENT/$_s}
        value=${value//_PP_PARENT/$_s}
        unset _s

        case "${_rowtype}" in
            assign) # Assign a preprocess variable
                local _ppkey=_PP_$_key
                eval "local ${_ppkey}=\$value"
                unset _s _ppkey
                ;;
            dotdot) # do a "cd .." on a node path.
                local _ppkey=_PP_$_key
                local _s=
                eval "_s=\$${_ppkey}"
                if [ "${#_s}" -gt 1 ]; then
                    _s="${_s%/*/}/"
                fi
                eval "$_ppkey=\$_s"
                unset _s _ppkey
                ;;
            prompt) # Prompt a value for a pp variable.
                local _ppkey=_PP_$_key
                local _s=$(prompt "$value")
                eval "$_ppkey=\$_s"
                unset _s _ppkey
                ;;
            include) # Do an include of a file
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                if [[ $_immediatechild == 2 && ${#_readahead[@]} == 0 ]]; then
                    if (( ${#_subdoc[@]} > 0 )); then
                        _readahead=("${_subdoc[@]}")
                    fi
                fi
                _pp_yaml "$_varname" "${_includefile:-$_filepath}" "$_includefilter" $_i "${_parentpath}" $_includevariables
                local _status=$?
                if [ $_status -eq 2 ]; then
                    _error "[$_filepath: $(($_rowindex))] Could not find file \"$_includefile\"."
                    return 1
                elif [ $_status -gt 0 ]; then
                    return $_status
                fi
                ;;
            clone) # Clone module(s)
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                # _retrepo variable is populated by _module_clone
                local _retrepo= _v=
                for _v in $value; do
                    _module_clone "_retrepo" "$_v"
                    local _status=$?
                    if [ $_status -gt 0 ]; then
                        _error "[$_filepath: $(($_rowindex))] Could not clone module repository \"$_v\"."
                        return 1
                    fi
                    printf -v _output "%*s%s" $_i "" "_source:"
                    eval "$_varname+=(\"\$_output\")"
                    printf -v _output "%*s    - %s" $_i "" "$_retrepo"
                    eval "$_varname+=(\"\$_output\")"
                done
                ;;
            source) # Source module(s) shell file
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                printf -v _output "%*s%s" $_i "" "_source:"
                eval "$_varname+=(\"\$_output\")"
                printf -v _output "%*s    - %s" $_i "" "$value"
                eval "$_varname+=(\"\$_output\")"
                ;;
            debug) # Output debug info
                _debug "@debug: $value"
                ;;
            assert) # Do assertion
                _debug "@assert: $value"
                if [[ $value =~ (.*)\ (.*) ]]; then
                    local _fn=${BASH_REMATCH[1]}
                    local _val=${BASH_REMATCH[2]}
                    if [ "$_fn" = "nonempty" ] && [ -z "$_val" ]; then
                        _error "Assertion failed: $value: $_filepath:$_rowindex"
                        return 1
                    fi
                fi
                ;;
            cache) # Change cache behaviour
                _debug "@cache: $value"
                _CACHE_LEVEL=$value
                ;;
            leaf) # A regular key value row.
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                if [ "${value:0:1}" == "[" ]; then
                    _error "Space does not support YAML inline list declarations: ${value}."
                    return 1
                fi
                if [[ "$_prefix$_key" =~ ^$_filter$ ]]; then
                    # Filter is for leaf content.
                    if [ "${_isarrayobjectfiltered}" = "1" ]; then
                        _i=$((_i-2))
                    fi
                    if [ "${value}" != "" ] && [ "${value:0:1}" != ">" ] && [ "${value:0:1}" != "|" ] && [ "${value:0:1}" != "!" ]; then
                        printf -v _output "%*s%s" $_i "" "$value"
                        eval "$_varname+=(\"\$_output\")"
                    fi
                else
                    if [ "${#value}" -eq 0 ]; then
                        printf -v _output "%*s%s" $_i "" "$_key:"
                    else
                        printf -v _output "%*s%s" $_i "" "$_key: $value"
                    fi
                    eval "$_varname+=(\"\$_output\")"
                    _i=$(( _i + 4 ))
                fi
                if ((${#_readahead[@]} > 0)); then
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        if [[ $_line =~ ^(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
                            _yaml_pp_multiline_include "$_i"
                            local _status=$?
                            if [ $_status -gt 0 ]; then
                                return $_status
                            fi
                        else
                            printf -v _output "%*s%s" $_i "" "$_line"
                            eval "$_varname+=(\"\$_output\")"
                        fi
                    done
                fi
                ;;
            object) # Start of new object
                local _i=$(($_indent-$_filterindent+$_inheritedindent))
                local _i2=$(($_i+$_nextindent))
                printf -v _output "%*s%s" $_i "" "$_key:"
                eval "$_varname+=(\"\$_output\")"
                # Set the parent node for the sub nodes following
                _parents[$_i2]=$_key
                ;;
            arrayobject) # Array item object start
                # Output key index at given indent, also readahead.
                local _i2=$(($_indent-$_filterindent+$_inheritedindent))
                local _i3=$(($_arrayextraindent-1))
                _isarrayobjectfiltered=0
                if [ "${value:0:1}" == "[" ] || [ "${value:0:1}" == "{" ]; then
                    _error "Space does not support YAML inline list/object declarations: ${value}."
                    return 1
                fi
                if [[ -n $_key && $_prefix$_key =~ ^$_filter$ ]] || [[ -z $_key && "$_prefix${_key}.*" =~ ^$_filter$ ]]; then
                    # Handle "/.*" filtering.
                    if [ "${value}" != "" ] && [ "${value:0:1}" != ">" ] && [ "${value:0:1}" != "|" ] && [ "${value:0:1}" != "!" ]; then
                        if [ -z "$_key" ]; then
                            # index item
                            printf -v _output "%*s%s" $_i2 "" "$value"
                            eval "$_varname+=(\"\$_output\")"
                        elif [ -n "$value" ]; then
                            printf -v _output "%*s%s" $_i2 "" "$value"
                            eval "$_varname+=(\"\$_output\")"
                        fi
                    else
                        _i2=$((_i2-4))
                    fi
                    _i3=0
                    _isarrayobjectfiltered=1
                else
                    if [ -z "$_key" ]; then
                        # index item
                        printf -v _output "%*s-%*s%s" $_i2 "" $_i3 "" "$value"
                    elif [ -n "$value" ]; then
                        printf -v _output "%*s-%*s%s" $_i2 "" $_i3 "" "$_key: $value"
                    else
                        printf -v _output "%*s-%*s%s" $_i2 "" $_i3 "" "$_key:"
                    fi
                    eval "$_varname+=(\"\$_output\")"
                fi
                local _i4=$(($_i2+$_i3+4))
                if ((${#_readahead[@]} > 0)); then
                    local _line=
                    for _line in "${_readahead[@]}"; do
                        if [[ $_line =~ ^(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
                            _yaml_pp_multiline_include "$_i4"
                            local _status=$?
                            if [ $_status -gt 0 ]; then
                                return $_status
                            fi
                        else
                            printf -v _output "%*s%s" $_i4 "" "$_line"
                            eval "$_varname+=(\"\$_output\")"
                        fi
                    done
                fi
                ;;
        esac
        unset _parentpath
    done
}

#==========
# _yaml_pp_multiline_include
#
# Macro helper function for handling
# @include directives inside multiline variables.
#
# Parameters
#   $1: indent used in multiline
#
# Expects:
#   To have $BASH_REMATCH:
#     if [[ $_line =~ ^(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
#
#==========
_yaml_pp_multiline_include()
{
    local _i=$1
    shift

    local _readahead=
    local _row= _rowtype=
    local _op=${BASH_REMATCH[2]}
    local _value=${BASH_REMATCH[3]}
    local _includevariables=
    local _includefile=
    local _includefilter=
    local _includevariables=
    if [[ $_value =~ ^(.*)[\ ]*\|[\ ]*(.*) ]]; then
        _includefile=${BASH_REMATCH[1]}
        local _s=${BASH_REMATCH[2]}
        if [[ $_s =~ (.*)\((.*)\)$ ]]; then
            _includefilter=${BASH_REMATCH[1]}
            _includevariables=${BASH_REMATCH[2]}
        else
            _includefilter=$_s
        fi
    else
        _includefile=$_value
        _includefilter=""
    fi
    # Check if $_includefile is a module
    if [[ -n $_includefile && ! $_includefile =~ \.yaml$ ]]; then
        _module_find_yaml "$_includefile" "_includefile"
    fi
    if [ -n "${_includefile}" ] && [ ! -f "$_includefile" ]; then
        if [ "$_op" = "-" ]; then
            # Ignore missing yaml file.
            continue
        else
            _error "[$_filepath: $(($_rowindex))] Could not find file \"$_includefile\"."
            return 1
        fi
    fi

    _pp_yaml "$_varname" "${_includefile:-$_filepath}" "$_includefilter" $_i "${_parentpath}" $_includevariables
}


#==========
# _yaml_get_row
#
# MACRO helper to get a single row from the feed
# and substitute preprocess variables in that row.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: row index
#   $2: preprocessing switch
#
# Expects:
#   _allrows
#   _PP_${value}
#
#==========
_yaml_get_row()
{
    local _index=$1
    shift
    local _dopreprocess=$1
    shift

    _row=${_allrows[$_index]}
    while [[ $_dopreprocess == "1" ]] && [[ $_row =~ ^(.*)\@\{([^}]+)\}(.*)$ ]]; do
        # Substitute preprocessed variable
        local _left=${BASH_REMATCH[1]}
        local _s=${BASH_REMATCH[2]}
        local _right=${BASH_REMATCH[3]}
        if [[ $_s =~ ([a-zA-Z0-9_]+)(:?\-)(.+) ]]; then
            local _substvar=_PP_${BASH_REMATCH[1]}
            local _op=${BASH_REMATCH[2]}
            local _substvar2=${BASH_REMATCH[3]}
            if [[ ${_substvar2:0:1} == "@" ]]; then
                _substvar2=_PP_${_substvar2:1}
                local _substvalue2=${!_substvar2-}
            else
                local _substvalue2=$_substvar2
            fi
            local _substvalue=
            if [ "$_op" = "-" ]; then
                _substvalue=${!_substvar-$_substvalue2}
            else
                _substvalue=${!_substvar:-$_substvalue2}
            fi
        else
            local _substvar=_PP_$_s
            if [ "${_substvar: -1}" = "-" ]; then
                _substvar="${_substvar:0:$((${#_substvar}-1))}"
            fi
            if [ "${_substvar: -1}" = ":" ]; then
                _substvar="${_substvar:0:$((${#_substvar}-1))}"
            fi
            local _substvalue=${!_substvar-}
        fi

        _row=${_left}${_substvalue}${_right}
    done
}

#==========
# _yaml_get_next
#
# MACRO helper to _pp_yaml and _parse_yaml.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: preprocessing switch
#
# Expects:
#   _rowindex
#   _numrows
#
# Returns:
#   0: if there are more rows to process
#   1: no more rows to process
#
#==========
_yaml_get_next()
{
    if [ "$_rowindex" -ge "$_numrows" ]; then
        return 1
    fi

    local _dopreprocess=${1}
    shift

    # This particular preprocess value will have its substitution postponed because
    # we do not know the correct parent node already.
    local _PP_PARENT=_PP_PARENT
    local _PP_PARENTPATH=_PP_PARENTPATH

    local _row=
    _yaml_get_row "$_rowindex" "$_dopreprocess"
    _rowindex=$(( _rowindex + 1 ))

    _key=""
    value=""
    _rowtype=""
    _readahead=()

    if [[ $_row =~ ^([\ ]*)(\@include)[\ ]*:(-?)[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        local _op=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _includevariables=
        if [[ $value =~ ^(.*)[\ ]*\|[\ ]*(.*) ]]; then
            _includefile=${BASH_REMATCH[1]}
            local _s=${BASH_REMATCH[2]}
            if [[ $_s =~ (.*)\((.*)\)$ ]]; then
                _includefilter=${BASH_REMATCH[1]}
                _includevariables=${BASH_REMATCH[2]}
            else
                _includefilter=$_s
            fi
        else
            _includefile=$value
            _includefilter=""
        fi
        _yaml_get_multiline 0
        # Check if $_includefile is a module
        if [[ -n $_includefile && ! $_includefile =~ \.yaml$ ]]; then
            _module_find_yaml "$_includefile" "_includefile"
        fi
        if [ "$_op" = "-" ] && [ ! -f "$_includefile" ]; then
             # Ignore missing yaml file.
            _rowtype=""
        else
            _rowtype="include"
        fi
    elif [[ $_row =~ ^([\ ]*)(\@clone)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="clone"
    elif [[ $_row =~ ^([\ ]*)(\@source)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="source"
    elif [[ $_row =~ ^([\ ]*)(\@debug)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="debug"
    elif [[ $_row =~ ^([\ ]*)(\@dotdot)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        value=
        _key=${BASH_REMATCH[3]}
        _rowtype="dotdot"
    elif [[ $_row =~ ^([\ ]*)(\@assert)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="assert"
    elif [[ $_row =~ ^([\ ]*)(\@cache)[\ ]*:[\ ]+(.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        _key=
        value=${BASH_REMATCH[3]}
        _rowtype="cache"
    elif [[ $_row =~ ^([\ ]*)(\@prompt)[\ ]*:(-?)[\ ]+([^\ ]+)[\ ](.*) ]]; then
        _indent=${#BASH_REMATCH[1]}
        local _op=${BASH_REMATCH[3]}
        _key=${BASH_REMATCH[4]}
        value=${BASH_REMATCH[5]}
        if [ "$_op" = "-" ]; then
            # @prompt:- means only prompt on variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        fi
        _rowtype="prompt"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)\ (.*) ]]; then
        # Assign preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [ "$_op" = ":-" ]; then
            # @var:- means only assign variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":+" ]; then
            # @var:+ means only assign variable if it already has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":" ]; then
            # @var: means always assign to variable.
            # Fall through.
            :
        fi
        value=${BASH_REMATCH[4]}
        _rowtype="assign"
    elif [[ $_row =~ ^([\ ]*)\@([a-zA-Z0-9_]+)[\ ]*(:|:-|:\+)$ ]]; then
        # Unset a preprocess variable.
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        local _op=${BASH_REMATCH[3]}
        if [ "$_op" = ":-" ]; then
            # @var:- means only unset variable if it lacks a value or is unset.
            local _pp_varname="_PP_$_key"
            if [[ -n ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":+" ]; then
            # @var:+ means only unset variable if it has a value.
            local _pp_varname="_PP_$_key"
            if [[ -z ${!_pp_varname-} ]]; then
                return 0
            fi
        elif [ "$_op" = ":" ]; then
            # @var: means always unset variable.
            # Fall through.
            :
        fi
        eval "unset _PP_$_key"
    elif [[ $_row =~ ^([\ ]*)([a-zA-Z0-9_]+)[\ ]*:[\ ]?(.*) ]]; then
        # Key value or new object/array row
        _indent=${#BASH_REMATCH[1]}
        _key=${BASH_REMATCH[2]}
        value=${BASH_REMATCH[3]}
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            _rowtype="leaf"
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" || ${value:0:10} == "!nospace >" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        else
            value=""
            # This node has no value, we must figure out if it's
            # an empty leaf or an object.

            # Find out the nextindent level for an object row.
            local _yamlindent=0
            _yaml_find_nextindent
            if [ "$_yamlindent" -gt "$_indent" ]; then
                _rowtype="object"
            else
                _rowtype="leaf"
            fi
            unset _yamlindent
        fi
    elif [[ $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:[\ ]+(.*) ||
             $_row =~ ^([\ ]*)\-([\ ]+)([a-zA-Z0-9_]+)[\ ]*:($) ]]; then
        # Array item with child object.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=$((${#BASH_REMATCH[2]}+1))
        _key=${BASH_REMATCH[3]}
        value=${BASH_REMATCH[4]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" || ${value:0:10} == "!nospace >" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        fi
    elif [[ $_row =~ ^([\ ]*)\-[\ ]+(.*) || $_row =~ ^([\ ]*)\-($) ]]; then
        # Array index item with only value.
        _indent=${#BASH_REMATCH[1]}
        _arrayextraindent=0
        _key=
        value=${BASH_REMATCH[2]}
        _rowtype="arrayobject"
        if [[ ${value//\ } != "" ]]; then
            # This row has a value (other than spaces)
            # Check if we should do a read ahead.
            if [[ ${value:0:1} == "|" || ${value:0:1} == ">" || ${value:0:10} == "!nospace >" ]]; then
                _yaml_get_multiline "$_dopreprocess"
            fi
        fi
    else
        # Unknown row
        if [[ $_row =~ ^[\ ]*([^\#^\ ].*) ]]; then
            if [ "${BASH_REMATCH[1]}" != "---" ] && [ "${BASH_REMATCH[1]}" != "..." ]; then
                _warning "Can't parse the row [$_rowindex]: $_row"
            fi
        fi
    fi
    return 0
}

#==========
# _yaml_find_nextindent
#
# Peek into object for the given indentation level.
# It relies on caller-defined local variables.
#
# Expects:
#   _allrows
#   _indent
#   _numrows
#   _rowindex
#
#==========
_yaml_find_nextindent()
{
    local _i=$_rowindex
    _nextindent=4  # Default value
    _yamlindent=0

    while :; do
        if [ "$_i" -ge "$_numrows" ]; then
            return
        fi
        local _peekrow=${_allrows[$_i]}
        _i=$(( _i + 1 ))
        if [[ $_peekrow =~ ^([\ ]*)\-([\ ]+)[a-zA-Z0-9_]+[\ ]*:[\ ]*.* ]]; then
            _yamlindent=$((${#BASH_REMATCH[1]}+${#BASH_REMATCH[2]}+1))
            break
        elif [[ $_peekrow =~ ^([\ ]*)([a-zA-Z0-9_@]+)[\ ]*:[\ ]*(.*) ]]; then
            _yamlindent=${#BASH_REMATCH[1]}
            break
        elif [[ $_peekrow =~ ^([\ ]*)\-[\ ]*$ ]]; then
            _yamlindent=${#BASH_REMATCH[1]}
            break
        elif [[ $_peekrow =~ ^([\ ]*)\-[\ ]*.+$ ]]; then
            _yamlindent=${#BASH_REMATCH[1]}
            break
        fi
    done
    if [ "$_yamlindent" -gt "$_indent" ]; then
        _nextindent=$(($_yamlindent-$_indent))
    fi
}

#==========
# _yaml_get_multiline
#
# MACRO helper function.
# It relies on caller-defined local variables.
#
# Parameters:
#   $1: preprocessing switch
#
# Expects:
#   _indent
#   _numrows
#   _rowindex
#
#==========
_yaml_get_multiline()
{
    local _dopreprocess=$1
    shift

    if [ "$_rowindex" -ge "$_numrows" ]; then
        return
    fi
    local _row=
    _yaml_get_row "$_rowindex" "$_dopreprocess"
    if [[ $_row =~ ^([\ ]+)([^\ ].*) ]]; then
        local _subindent=${#BASH_REMATCH[1]}
        local _subvalue=${BASH_REMATCH[2]}
        if [ "$_subindent" -gt "$_indent" ]; then
            _readahead+=("$_subvalue")
            while :; do
                _rowindex=$(( _rowindex + 1 ))
                if [ "$_rowindex" -ge "$_numrows" ]; then
                    break
                fi
                _yaml_get_row "$_rowindex" "$_dopreprocess"
                if [[ $_row =~ ^([\ ]+)([^\ ].*) || $_row =~ ^([\ ]{$_subindent})(.*) ]]; then
                    local _subindent2=${#BASH_REMATCH[1]}
                    if [ "$_subindent2" -lt "$_subindent" ]; then
                        break
                    fi
                    printf -v _subvalue "%*s%s" $(($_subindent2-$_subindent)) "" \
                        "${BASH_REMATCH[2]}"
                    _readahead+=("$_subvalue")
                else
                    break
                fi
            done
        fi
    fi
}

#==================
# clone
#
# Clone modules repositories,
# and add the sh/bash file for sourcing.
#
# Parameters:
#   $@: module name(s) to clone
#
# Expects:
#   CWD
#   _MODULES_SHARED
#
# Returns:
#   0: success
#   1: failure
#
#==================
_clone()
{
    local _modules="$@"
    shift

    # Cloning will always be to $_INCLUDEPATH[1],
    # so here we set that to be in the shared area.
    local _INCLUDEPATH=($CWD/space_modules $_MODULES_SHARED $CWD)
    local _loadmod=
    for _loadmod in ${_modules}; do
        local _sourcefile= _rf=
        _module_clone "_sourcefile" "$_loadmod"
        local _status=$?
        if [ $_status -gt 0 ]; then
            _error "Could not clone module repository \"$_loadmod\"."
            return 1
        fi
        unset _status
        if [[ -n $_sourcefile ]]; then
            _source "$_sourcefile"
        else
            _debug "No sh/bash file found when loading module $_loadmod"
        fi
        unset _sourcefile
    done
    return 0
}

#==========
# _module_clone
#
# Clone a module Git repository.
#
# Parameters:
#   $1: variable name to put the module name which is to be "_sourced".
#   $2: modulename inclusive optional Git commit: [https://[gitlab.com/]][username/]repo[:v1.1]
#
# Returns:
#   0 on success, non-zero otherwise
#
#==========
_module_clone()
{
    local _repo=$1
    shift

    local _mod=$1
    shift

    local _protocol=
    local _domain=
    local _domainuser=
    local _username=
    local _reponame=""
    local _commit=
    local _str_commit=
    local _repofullname=
    _extract_repo_parts "${_mod}"
    (( $? > 0 )) && return 1

    local _repodir=$_domain/$_username/$_reponame$_str_commit

    # Check to see of the repo is already existing.
    local _dir=
    for _dir in ${_INCLUDEPATH[@]}; do
        if [[ -d $_dir/$_repodir ]]; then
            break
        fi
        _dir=
    done

    if [[ -z $_dir ]]; then
        # Directory does not exist

        # Check so that we are not bash auto completing
        if [[ $_BASH_COMPLETION != "0" ]]; then
            return 1
        fi

        _dir=${_INCLUDEPATH[1]}/$_repodir
        if [[ ! -z $_domainuser ]]; then
            _domainuser="$_domainuser@"
        elif [[ $(_to_lower $_protocol) == "ssh" ]]; then
            _domainuser="git@"
        fi
        local _giturl=$_protocol://$_domainuser$_domain/$_username/$_reponame

        # Check the module banlist.
        _module_check_banlist "${_giturl}:${_commit}"
        (( $? > 0 )) && return 1

        if ! command -v git >/dev/null \
           || [ "$_FORCE_HTTPS_FALLBACK" = "1" ]; then
            # Git is not installed, check if we could use fallback.
            local _d=$(_to_lower $_domain)
            local _p=$(_to_lower $_protocol)
            if [[ $_p != "https" ]]; then
                _error "Could not clone module since Git is not installed."
                return 1
            fi
            if [[ $_HTTPBIN == "" ]]; then
                _error "Could not clone module since Git is not installed. Nor curl or wget is available as fallback."
                return 1
            fi
            if [[ $_d == "github.com" || $_d == "gitlab.com" || $_d == "bitbucket.org" ]]; then
                # Fetch tarball from Git host into /tmp, unpack it and move it to the right place.
                _info "Downloading tarball \"$_giturl\" over HTTPS using: $_HTTPBIN."
                # EXTERNAL: mktemp, tar, curl/wget
                local _tmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')
                (( $? > 0 )) && { _error "Could not mktemp."; return 1; }
                local _status_code=0
                local _versionurl="$_giturl/raw/master/${_MODULE_STABLE_FILE_NAME}"
                if [ "$_HTTPBIN" = "curl" ]; then
                    _status_code=$($_HTTPBIN -sL --write-out %{http_code} --silent --output "$_tmpdir/${_MODULE_STABLE_FILE_NAME}" $_versionurl)
                    if [ "$_status_code" -eq 200 ]; then
                        local _latest_stable_version=
                        _get_module_latest_stable_version "$_tmpdir/${_MODULE_STABLE_FILE_NAME}"
                        if [ "$?" -gt 0 ]; then
                            return 1
                        fi

                        _commit=${_latest_stable_version}
                    else
                        _commit="master"
                    fi
                    rm "$_tmpdir/${_MODULE_STABLE_FILE_NAME}"
                elif [ "$_HTTPBIN" = "wget" ]; then
                    _status_code=$($_HTTPBIN -O "$_tmpdir/${_MODULE_STABLE_FILE_NAME}" $_versionurl)
                    # Note: use exit code instead
                    if [ "$?" -eq 0 ]; then
                        local _latest_stable_version=
                        _get_module_latest_stable_version "$_tmpdir/${_MODULE_STABLE_FILE_NAME}"
                        if [ "$?" -gt 0 ]; then
                            return 1
                        fi

                        _commit=${_latest_stable_version}
                    else
                        _commit="master"
                    fi
                    rm "$_tmpdir/${_MODULE_STABLE_FILE_NAME}"
                fi
                if [[ $_d == "github.com" ]]; then
                    local _durl="$_giturl/archive/${_commit}.tar.gz"
                elif [[ $_d == "gitlab.com" ]]; then
                    local _durl="$_giturl/repository/archive.tar.gz?ref=${_commit}"
                elif [[ $_d == "bitbucket.org" ]]; then
                    local _durl="$_giturl/get/${_commit}.tar.gz"
                fi

                # Check if URL exists before proceeding with actual download
                _status_code=0
                if [ "$_HTTPBIN" = "curl" ]; then
                    _status_code=$($_HTTPBIN -sL --write-out %{http_code} --silent --output "/dev/null" --head $_durl)
                    if [ "$_status_code" -ne 200 ]; then
                        _error "Failed to access: $_durl. Make sure the repository is publicly accessible"
                        return 1
                    fi
                elif [ "$_HTTPBIN" = "wget" ]; then
                    _status_code=$($_HTTPBIN -q --spider $_durl)
                    # Note: use exit code instead
                    if [ "$?" -ne 0 ]; then
                        _error "Failed to access: $_durl. Make sure the repository is publicly accessible"
                        return 1
                    fi
                fi

                {
                    if [[ $_HTTPBIN == "curl" ]]; then
                        $_HTTPBIN -sL $_durl
                    elif [[ $_HTTPBIN == "wget" ]]; then
                        $_HTTPBIN -q -O- $_durl
                    fi
                } | tar -xvzf - -C $_tmpdir > /dev/null 2>&1
                if [ "$?" -gt 0 ]; then
                    _error "Could not fetch and unpack tarball for $_giturl."
                    return 1
                fi

                # EXTERNAL: find
                local _tmpdir2=$(find $_tmpdir -maxdepth 1 -mindepth 1)
                # EXTERNAL: mkdir
                mkdir -p ${_dir%/*}
                # EXTERNAL: mv
                mv $_tmpdir2 $_dir
            else
                _error "Could not clone module since Git is not installed. Only gitlab.com/github.com/bitbucket.org work with curl/wget fallback."
                return  1
            fi
        else
            # EXTERNAL: git, rm

            # Expect url NOT to have the .git extension at this point. Append it now.
            # Some host providers do support git cloning without .git at the end. Don't count on it.
            # See also: "GIT URLS" in 'man git-clone'
            _giturl="$_giturl".git

            _info "Git clone $_giturl into $_dir"
            git clone -q "$_giturl" "$_dir" 2>&1
            if [[ $? != "0" ]]; then
                _error "Could not Git clone $_giturl."
                return 1
            fi
            cd "$_dir"
            if [ "$?" != "0" ]; then
                _error "Could not enter directory: $_dir"
                return 1
            fi
            if [ "$_commit" = "" ]; then
                if [ -f "./${_MODULE_STABLE_FILE_NAME}" ]; then
                    local _latest_stable_version=
                    _get_module_latest_stable_version "./${_MODULE_STABLE_FILE_NAME}"
                    if [ "$?" -gt 0 ]; then
                        return 1
                    fi

                    _commit=${_latest_stable_version}
                    _info "Set to latest stable version: $_commit"
                else
                    _commit="master"
                    _info "Set to current version: $_commit"
                fi
            else
                _info "Set to version: $_commit"
            fi
            git checkout "$_commit" > /dev/null 2>&1
            if [[ $? != "0" ]]; then
                _error "Could not Git checkout $_commit of $_repofullname. Will delete directory."
                ( rm -rf "$_dir" >&2 )
                return 1
            fi
            if [[ -f ${_dir}/.gitmodules ]]; then
                ( cd "$_dir" && git submodule init >&2 && git submodule update >&2 )
                if [[ $? != "0" ]]; then
                    _error "Could not perform Git submodule init && update. Is Perl installed?"
                    ( rm -rf "$_dir" >&2 )
                    return 1
                fi
            fi
            # Check the signature of the commit, if applicable.
            # TODO How should we actually do this?
            if [[ $_SECURITY_GPG_VERIFY_SIGNATURE != "0" ]]; then
                ( cd "$_dir" && git verify-commit HEAD >&2 )
                if [[ $? != "0" ]]; then
                    _security "Could not verify signature of Git repository: $_giturl."
                    ( rm -rf "$_dir" >&2 )
                    return 1
                fi
            fi
        fi
    else
        _dir=${_dir}/$_repodir
    fi

    # Check if sh/bash file to source does exist.
    local _f=""
    eval "$_repo="
    for _f in "$_dir/Spacefile.yaml"; do
        if [[ -f $_f ]]; then
            _f=${_f%.yaml}
            if [[ -f "${_f}.sh" ]]; then
                eval "$_repo=\${_f}.sh"
            elif [[ -f "${_f}.bash" ]]; then
                eval "$_repo=\${_f}.bash"
            fi
            break
        fi
    done

    return 0
}

#=============
# _extract_repo_parts
#
# Populate env variables
#
# Parameters:
#   $1: the module name
#
# Expects:
#   _domain
#   _domainuser
#   _username
#   _reponame
#   _commit
#   _str_commit
#   _repofullname
#
#=============
_extract_repo_parts()
{
    local _mod="${1}"
    shift

    _protocol="https"
    # Domain is only defaulted for the "space-sh" user.
    _domain=
    _domainuser=
    _username="space-sh"
    _reponame=""
    _commit=""
    _str_commit=
    _repofullname=

    # Extract protocol if given.
    if [[ $_mod =~ (.+)://(.*) ]]; then
        _protocol=${BASH_REMATCH[1]}

        #
        # Further check if the 'domain' part appears to be an IP address
        # Otherwise, try to capture the domain name into two parts:
        # [1] before and [2] after the expected dot, in order to provide meaningful error messages
        #
        local _domain_part=${BASH_REMATCH[2]}
        if [[ $_domain_part =~ ([0-9]{1,3}[\.]){3}[0-9]{1,3} ]]; then
            _debug "_extract_repo_parts: $_domain_part accepted"
        elif [[ $_domain_part =~ ^([-@:A-Za-z0-9]+)(\.)?([a-z]{2,3}(\.[a-z]{2,3})?)? ]]; then
            # Check if punctuation was provided then requires the extension
            if [[ -n ${BASH_REMATCH[2]} && -z ${BASH_REMATCH[3]} ]]; then
                _error "Expected domain extension: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
                return 1
            fi
        else
            _error "Malformed import name: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
            return 1
        fi
    fi

    # Extract "user@domain", if given, and the repo name.
    if [[ $_mod =~ (.+://)?([-@:A-Za-z0-9.]+)/ ]]; then
        # Domain provided
        _domain=${BASH_REMATCH[2]}

        # In case it is a name, not an IP, check if punctuation was provided
        # Require name extension for implicit protocol settings
        if [[ ! $_domain =~ ([0-9]{1,3}[\.]){3}[0-9]{1,3} ]] && \
           [[ $_domain =~ ^([-@:A-Za-z0-9]+)(\.)?([a-z]{2,3}(\.[a-z]{2,3})?)? ]]; then

            if [[ -n ${BASH_REMATCH[2]} && -z ${BASH_REMATCH[3]} ]]; then
                _error "Expected domain extension: $_domain Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
                return 1
            fi
        fi

        # Extract domainuser, if provided
        if [[ $_domain =~ (.+)[@](.+) ]]; then
            _domainuser=${BASH_REMATCH[1]}
            _domain=${BASH_REMATCH[2]}
        fi

        # Expect both username and reponame to have been provided
        if [[ $_mod =~ (.*://)?([-@:A-Za-z0-9.?]+)/([-A-Za-z0-9_]+)/([-A-Za-z0-9_:.]+) ]]; then
            _username=${BASH_REMATCH[3]}
            _reponame=${BASH_REMATCH[4]}
            # Remove .git extension if exists
            _reponame=${_reponame%.git}
        else
            _error "Expected username and reponame: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/$_mod\" \"space -m https://gitlab.com/$_mod\""
            return 1
        fi
    else
        # Domain not provided, expect username and/or reponame[:commit]
        if [[ $_mod =~ ([-A-Za-z0-9_]+)/([-A-Za-z0-9_:.]+) ]]; then
            _username=${BASH_REMATCH[1]}
            _reponame=${BASH_REMATCH[2]}
        elif [[ $_mod =~ ^([-A-Za-z0-9_:.]*) ]]; then
            _reponame=${BASH_REMATCH[1]}
        fi

        # Remove .git extension if exists
        _reponame=${_reponame%.git}

        if [[ $_username == "space-sh" ]]; then
            _domain="gitlab.com"
        else
            _error "Expected domain name for git url with explicit protocol set: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/$_mod\" \"space -m https://gitlab.com/$_mod\""
            return 1
        fi
    fi

    # Extract :commit from reponame
    if [[ $_reponame =~ (.+)[:](.+) ]]; then
        _reponame=${BASH_REMATCH[1]}
        _commit=${BASH_REMATCH[2]}
    fi
    if [[ $_protocol == "" || $_domain == "" || $_username == "" || $_reponame == "" ]]; then
        _error "Malformed import name: $_mod. Format: (protocol)<domain>/<user_name>/<repo_name>. Examples: \"space -m gitlab.com/<user_name>/<repo_name>\" \"space -m https://gitlab.com/<user_name>/<repo_name>\""
        return 1
    fi
    if [ -z "$_commit" ]; then
        # We skip commit name if it is empty
        _str_commit=""
    else
        _str_commit=":$_commit"
    fi
    _repofullname=$_username/$_reponame$_str_commit
}

#=============
# _urlencode
#
# Percent encode all that is not part of the
# unreserved character list according to RFC 3986.
#
# Parameters:
#   $1: data to urlencode
#
# Expects:
#   _encoded_data
#
#=============
_urlencode()
{
  local _data="$1"

  local _length=${#_data}
  local _counter=
  _encoded_data=

  for (( _counter=0; _counter<_length; _counter++ )); do
     local _curr_char=${_data:$_counter:1}
     if [[ "$_curr_char" =~ ^[a-zA-Z0-9\~\_\.\-]$ ]]; then
        _encoded_data+="${_curr_char}"
     else
        local _tmp_char=
        printf -v _tmp_char '%%%02X' "'$_curr_char"
        _encoded_data+="${_tmp_char}"
     fi
  done
}

#=============
# _module_check_banlist
#
#=============
_module_check_banlist()
{
    local _giturl=$1
    shift

    if [[ $_SECURITY_CHECK_BANNED != "0" ]]; then
        local _response=
        # We want the Bash version and OS info to check if the module is broken
        # for some specific combination.
        _debug "Ban server check against: $_giturl"
        if [[ $_HTTPBIN == "curl" ]]; then
            _response=$($_HTTPBIN $_SECURITY_BAN_SERVER -s -X POST --data-urlencode "git_url=${_giturl}" --data-urlencode "bash=${BASH_VERSION}" --data-urlencode "space=${_VERSION}" --data-urlencode "os=$(${_UNAME})")
            _debug "Ban server response, curl: ${_response}."
        elif [[ $_HTTPBIN == "wget" ]]; then
            local _post_data=
            local _encoded_data=
            _urlencode "${_giturl}"
            _post_data="git_url=${_encoded_data}"
            _urlencode "${BASH_VERSION}"
            _post_data="${_post_data}&bash=${_encoded_data}"
            _urlencode "${_VERSION}"
            _post_data="${_post_data}&space=${_encoded_data}"
            _urlencode "$(${_UNAME})"
            _post_data="${_post_data}&os=${_encoded_data}"
            _response=$($_HTTPBIN $_SECURITY_BAN_SERVER -q -O- --post-data="${_post_data}")
            _debug "Ban server response, wget: ${_response}."
        else
            _error "No curl/wget found in OS. Cannot check module banlist."
            return 1
        fi

        if [[ $_SECURITY_CHECK_BANNED == "1" ]]; then
            if [[ $_response == '{"status":"banned"}' ]]; then
                _security "The module $_giturl IS BANNED!"
                return 1
            elif [[ $_response == '{"status":"broken"}' ]]; then
                _debug "The module $_giturl is BROKEN!"
                return 1
            elif [[ $_response == '{"status":"unknown"}' ]]; then
                _debug "The module $_giturl is unknown, but is allowed by user."
                return 0
            elif [[ $_response == '{"status":"trusted"}' ]]; then
                _debug "The module $_giturl is trusted."
                return 0
            else
                _security "Could not communicate with banserver."
                return 1
            fi
        elif [[ $_SECURITY_CHECK_BANNED == "2" ]]; then
            if [[ $_response == '{"status":"banned"}' ]]; then
                _security "The module $_giturl IS BANNED!"
                return 1
            elif [[ $_response == '{"status":"broken"}' ]]; then
                _debug "The module $_giturl is BROKEN!"
                return 1
            elif [[ $_response == '{"status":"unknown"}' ]]; then
                _security "The module $_giturl is unknown!"
                return 1
            elif [[ $_response == '{"status":"trusted"}' ]]; then
                _debug "The module $_giturl is trusted."
                return 0
            else
                _security "Could not communicate with the security server."
                return 1
            fi
        else
            _error "Bad SECURITY model."
            return 1
        fi
    fi

    return 0
}


#=============
# _module_find_yaml
#
# Search for a modules YAML file using defaults and
# trying all the different YAML file name variants.
#
# Parameters:
#   $1: module name: [username/]reponame
#   $2: variable name to assign found YAML file path to.
#
#=============
_module_find_yaml()
{
    local _module=$1
    shift

    local _outvarname=$1
    shift

    local _domainname=""
    local _username="space-sh"
    local _reponame=$_module
    if [[ $_module =~ (.+)/(.+)/(.+) ]]; then
        _domainname=${BASH_REMATCH[1]}
        _username=${BASH_REMATCH[2]}
        _reponame=${BASH_REMATCH[3]}
    elif [[ $_module =~ (.+)/(.+) ]]; then
        _username=${BASH_REMATCH[1]}
        _reponame=${BASH_REMATCH[2]}
    fi
    #[[ $_reponame =~ ([^:]+) ]]
    #local _reponameclean=${BASH_REMATCH[1]}
    unset _module

    if [ "${_domainname}" = "" ]; then
        if [ "${_username}" = "space-sh" ]; then
            _domainname="gitlab.com"
        fi
    fi

    local _dir= _f=
    for _dir in ${_INCLUDEPATH[@]}; do
        for _f in "$_dir/$_domainname/$_username/$_reponame/Spacefile.yaml"; do
            if [[ -f $_f ]]; then
                _debug "Found module $_f"
                eval "$_outvarname=\$_f"
                return
            fi
        done
    done
}

#================
# _enter_gui_mode
#
# Enters graphical user interface mode
#
#================
_enter_gui_mode()
{
    _debug "Entering GUI mode"
    source "./gui/sg.sh"
    _sg_entrypoint
    return 0
}

#=====
# PRINT
#
# Redirects a message to a file descriptor.
# In the occasion _SPACE_NAME is set, its value gets prefixed to the final message output.
# This function is meant to be exported.
#
# Parameters:
#   $1: output message
#   $2: level type (error, warning, debug, ...). Defaults to "info"
#   $3: file descriptor where the message will be redirected to. Defaults to "2"
#
# Expects:
#   SPACE_LOG_ENABLE_COLORS
#   SPACE_LOG_LEVEL
#   _SPACE_NAME
#
#=====
PRINT()
{
    SPACE_ENV="_PRINT_COLUMN_POSITION"
    local color="\033[0m"
    local header=''
    [ "${2-info}" = "error" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 0 ] && header="[ERROR] " && color="\033[31m"
    [ "${2-info}" = "security" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 0 ] && header="[SEC]   " && color="\033[35m"
    [ "${2-info}" = "warning" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 1 ] && header="[WARN]  " && color="\033[33m"
    [ "${2-info}" = "ok" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 2 ] && header="[OK]    " && color="\033[32m"
    [ "${2-info}" = "info" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 3 ] && header="[INFO]  " && color="\033[37m"
    [ "${2-info}" = "debug" ] && [ "${SPACE_LOG_LEVEL:-4}" -gt 4 ] && header="[DEBUG] " && color=""
    [ -z "${header}" ] && return 0
    [ "${_SPACE_NAME-}" != "" ] && ( [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && printf "\033[${_PRINT_COLUMN_POSITION}G${color}%s%s: %s\033[0m\n" "${header}" "${_SPACE_NAME}" "${1}" >&${3-2}) || ( [ "${SPACE_LOG_ENABLE_COLORS}" = "1" ] && printf "\033[${_PRINT_COLUMN_POSITION}G${color}%s%s\033[0m\n" "${header}" "${1}" >&${3-2} )
    [ "${_SPACE_NAME-}" != "" ] && ( [ "${SPACE_LOG_ENABLE_COLORS}" != "1" ] && printf "%s%s: %s\n" "${header}" "${_SPACE_NAME}" "${1}" >&${3-2}) || ( [ "${SPACE_LOG_ENABLE_COLORS}" != "1" ] && printf "%s%s\n" "${header}" "${1}" >&${3-2} )
    :
}

_print()
{
    printf "%s\n" "$*" >&2
}

_security()
{
    local _msg=
    IFS= read -d '' -r _msg << _EOF
    $@
               *****************************************************************
               *  Do not take too lightly on this security error.              *
               *  Before disabling any security checks, please head over       *
               *  to the Space.sh site to see that everything else is OK.      *
               *****************************************************************
_EOF
    [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_MAGENTA}" >&2
    _print "[SEC]   $_msg"
    [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}" >&2
}

_error()
{
    if (( $_VERBOSITY >= 1 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_RED}" >&2
        _print "[ERROR] $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}" >&2
    fi
}

_warning()
{
    if (( $_VERBOSITY >= 2 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_YELLOW}" >&2
        _print "[WARN]  $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}" >&2

    fi
}

_info()
{
    if (( $_VERBOSITY >= 3 )); then
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_FG_WHITE}" >&2
        _print "[INFO]  $@"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}" >&2
    fi
}

_runinfo()
{
    if (( $_VERBOSITY >= 3 )); then
        local _msg=$1
        shift
        local _color=${1-$_COLOR_DEFAULT}
        shift || :
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_color}" >&2
        _print "[RUN]   $_msg"
        [ "$_LOG_ENABLE_COLORS" = "1" ] && printf "${_COLOR_DEFAULT}" >&2
    fi
}

_debug()
{
    if (( $_VERBOSITY >= 4 )); then
        _print "[DEBUG] $@"
    fi
}

#==========
# prompt
#
# Use this in YAML _env variable values to prompt the user for input.
#
# Example:
# node:
#   _env:
#       - name: $(prompt 'what is your name? ')
#
# Parameters:
#   $1: string to echo as prompt
#
# Returns:
#   echoes on stdout the answer, so your capture the output to a variable.
#
#==========
prompt()
{
    _print "$1"
    local _s
    read -r _s
    printf "%s\n" "$_s"
}

#==========
# _check_minimum_requirements
#
# Check current Space meets module minimum requirements
#
# Parameters:
#   $1: module path
#
# Returns:
#   0: meets minimum requirements
#   1: invalid format
#   2: failed to meet minimum requirements
#
#==========
_check_minimum_requirements()
{
    local _base_directory="$1"

    # Early exit if check is disabled
    if [ "${_MODULE_CHECK_VERSION_COMPATIBILITY}" != "1" ]; then
        _debug "Skipping module version compatibility tests"
        return 0
    fi

    local _minimum_requirements_file="${_base_directory}/${_MODULE_REQUIREMENT_FILE_NAME}"
    local _minimum_required_space_version=
    local _minimum_required_space_version_major=
    local _minimum_required_space_version_minor=
    if [ -f "$_minimum_requirements_file" ]; then
        _debug "Reading minimum requirements from: $_minimum_requirements_file"
        # EXTERNAL: cat
        _minimum_required_space_version=$(cat "$_minimum_requirements_file")
        if [[ ! "$_minimum_required_space_version" =~ ^[0-9]+\.[0-9]+\.[0-9] ]]; then
            _error "Unexpected minimum required version for ${_base_directory##*/}. Version \"$_minimum_required_space_version\" does not match format \"major.minor.patch\""
            return 1
        fi
        _minimum_required_space_version_major=${_minimum_required_space_version%%.*}
        _minimum_required_space_version_minor=${_minimum_required_space_version#*.}
        _minimum_required_space_version_minor=${_minimum_required_space_version_minor%.*}
        _check_version()
        {
            local _program_name=$1
            local _required_major=$2
            local _required_minor=$3
            local _current_major=$4
            local _current_minor=$5
            if [ "$_current_major" -lt "$_required_major" ] \
                || ( [ "$_current_major" -le "$_required_major" ] && [ "$_current_minor" -lt "$_required_minor" ]); then
                _error "$_program_name requires Space version ${_required_major}.${_required_minor} or later. Current version: ${_current_major}.${_current_minor}"
                return 2
            fi
        }
        local _space_version_major=${_VERSION%%.*}
        local _space_version_minor=${_VERSION#*.}
        _space_version_minor=${_space_version_minor%.*}
        _check_version "${_base_directory##*/}" "${_minimum_required_space_version_major}" "${_minimum_required_space_version_minor}" "${_space_version_major}" "${_space_version_minor}"
    fi
}

#==========
# _get_module_latest_stable_version
#
# Reads Module stable version specifications
# and returns module version that matches current Space version
#
# Parameters:
#   $1: ${_MODULE_STABLE_FILE_NAME} file path
#
# Expects:
#   _latest_stable_version: where the results are stored
#
# Returns:
#   0: Found a matching version and stored to _latest_stable_version
#   1: Failed to find matching version
#
#==========
_get_module_latest_stable_version()
{
    local _stable_version_file="$1"
    _latest_stable_version=

    local _version_line=
    while read _version_line; do
        # Check expected format:
        # Space v0: 0.0.0
        local _module_latest_stable_tag=${_version_line%:*}
        local _space_version_major=${_VERSION%%.*}
        local _expected_matching_version="Space v${_space_version_major}"
        if [ "${_module_latest_stable_tag}" = "${_expected_matching_version}" ]; then
            _latest_stable_version=${_version_line#*:}
            _latest_stable_version=${_latest_stable_version## }  # Trim spaces
            _latest_stable_version=${_latest_stable_version%% }  #
            return 0
        fi
    done < "${_stable_version_file}"
    _error "Failed to find module latest stable version for Space ${_VERSION}"
    return 1
}

#==========
# _main
#
# Space program entrypoint
#
#==========
_main()
{
    # First thing we do is to try to figure out if
    # space was invoked as an interpretor using a shebang.
    # If that's so then the following code will modify the positional parameters
    # to fit space normal invocation.
    #
    # Note: Shebang behaviour might vary on different platforms:
    #   This is tested only on Linux so far.
    #   What could differ is that $1 would be many args instead of one,
    #   and that the chaining of shebang's might not work.
    #   ref: http://www.in-ulm.de/~mascheck/various/shebang/

    # New note: Here we try to detect wether if's a FreeBSD/OSX type of shebang
    # and modify the parameters to look like a Linux shebang.
    if [ "$#" -gt 0 ]; then
        if [ "${1}" = "!" ]; then
            # This is shebang where all args are seperated.
            # We want to remove the first and last arg containing "!" which
            # denotes the start and end of shebang arguments.
            # First one is easy.
            shift
            local _args=()
            while [ $? -eq 0 ]; do
                local _arg="${1}"
                if [ "${_arg}" = "!" ]; then
                    shift
                    break
                fi
                _args=("${_args[@]}" "${_arg}")
                shift
            done
            # Re-set all args now, but shebang args as big one arg this time.
            set -- "${_args[*]}" "$@"
            unset _args _arg
        elif [ "${1:0:2}" = "! " ]; then
            # This is shebang where all args are one, but we expected them to be separated.
            # We'll just cut away "! " and " !" from start and end of $1 and send it along.
            local _arg1="${1:2:$((${#1} - 4))}"
            # Repopulate the positional arguments.
            shift
            set -- "${_arg1}" "$@"
            unset _arg1
        fi
    fi

    local _isshebang=0
    if [ "$#" -gt 0 ]; then
        if [ -f "${1}" ]; then
            # First argument is a file, inject "-f" switch as $1, and continue
            set -- "-f" "$@"
            _isshebang=1
        elif [ "$#" -gt 1 ] && [ -f "${2}" ]; then
            # Second argument is a file, now check if first argument is more than
            # a -f switch, and if so, we have things to figure out.
            if [ "${1}" != "-f" ]; then
                _isshebang=1
                # Break $1 into parts.
                local _args_shebang=()
                _split_args "_args_shebang" "${1}"
                (( $? > 0 )) && return 1
                local _filename="${2}"
                shift 2
                local _args=("$@")
                local _newargs=()

                # Go through all _args_shebang up til any "--".
                local _shebang__=-1
                local _rowindex=
                for ((_rowindex=0; _rowindex<${#_args_shebang[@]}; _rowindex+=1 )); do
                    if [[ ${_args_shebang[$_rowindex]} == "--" ]]; then
                        _shebang__=$_rowindex
                        break
                    else
                        _newargs+=("${_args_shebang[$_rowindex]}")
                    fi
                done

                # Go through all _args up til any "--".
                local _hadargs=0
                for ((_rowindex=0; _rowindex<${#_args[@]}; _rowindex+=1 )); do
                    if [[ ${_args[$_rowindex]} == "--" ]]; then
                        # We have -- args.
                        # Add filename as first -- args
                        _hadargs=1
                        _newargs+=("--" "${_filename}")
                        # Keep on adding args.
                    else
                        _newargs+=("${_args[$_rowindex]}")
                    fi
                done

                # If -- args not added, see if we have from shebang args.
                if [ "${_hadargs}" = 0 ]; then
                    _newargs+=("--" "${_filename}")
                   if [ "${_shebang__}" -gt "-1" ]; then
                       _newargs+=("${_args_shebang[@]:$((_shebang__+1))}")
                   fi
                fi
                while shift; do :; done
                set -- "${_newargs[@]}"
                unset _args_shebang _filename _args _newargs _shebang__ _rowindex _hadargs
            fi
        fi
    fi

    local _loadmodules="" # -M
    local _envE=()        # -e
    local _envP=()        # -p
    local _dry="0"        # -d
    local _help=""        # -h
    local _listnodes=0    # -l
    local _updatemodules=  #-U
    local _updatespace=    #-u
    local _queryspace=     #-Q
    local _bash_completion_current= # -L
    local _envFiles=""

    local _o=

    local _namespaces=()
    local _dimensions=()
    local _strip_args=0
    local _dimensioncompletion=

    # Parse nodes and switches in any order.
    while (( $# > 0 )); do
        if [[ ${1} == '--' ]]; then
            # End of options
            shift
            # Save the remaining of "$@" as is, because we will use Bash's special treatment of "$@" when forwarding the arguments.
            _strip_args="1" # This will strip of the -- args from RUN in YAML.
            break
        elif [[ ${1:0:1} == '-' ]]; then
            # A normal switch, let getopts handle it.
            OPTIND=1
            getopts ":f:m:aM:e:dp:v:k:K:ShVlC:BQuU:X:13:4:5:6:gZE:" "_o"
            case "${_o}" in
                f)
                    if (( ${#_namespaces[@]} == 3 )); then
                        _error "Too many namespaces defined using (-f/-m). Maximum three allowed."
                        return 1
                    fi
                    _namespaces+=("file=${OPTARG}")
                    (return 1)
                    ;;
                m)
                    if (( ${#_namespaces[@]} == 3 )); then
                        _error "Too many namespaces defined using (-f/-m). Maximum three allowed."
                        return 1
                    fi
                    _namespaces+=("module=${OPTARG}")
                    (return 1)
                    ;;
                a)
                    if (( ${#_dimensions[@]} == 0 )); then
                        _error "-a flag must come after node."
                        return 1
                    fi
                    local _s=${_dimensions[$((${#_dimensions[@]}-1))]}
                    _s="${_s}.*/"
                    _dimensions[$((${#_dimensions[@]}-1))]=$_s
                    (return 1)
                    ;;
                M)
                    _loadmodules="$_loadmodules ${OPTARG}"
                    (return 1)
                    ;;
                e)
                    if [[ ! $OPTARG =~ ^[a-zA-Z0-9_]+\=.*$ ]]; then
                        if [[ $_BASH_COMPLETION == "0" ]]; then
                            _error "Malformed -e switch not on format [a-ZA-Z0-9_]+=.*: $OPTARG"
                            return 1
                        fi
                    else
                        local _s="${OPTARG}"
                        _escape "_s" '"'
                        _envE+=("${_s}")
                    fi
                    (return 1)
                    ;;
                E)
                    _envFiles="$_envFiles ${OPTARG}"
                    (return 1)
                    ;;
                d)
                    _dry=1
                    (return 1)
                    ;;
                p)
                    if [[ ! $OPTARG =~ ^[a-zA-Z0-9_]+\=.*$ ]]; then
                        _error "Malformed -p switch not on format [a-ZA-Z0-9_]+=.*: $OPTARG"
                        #if [[ $_BASH_COMPLETION != "2" ]]; then
                            #_error "Malformed -p switch not on format [a-ZA-Z0-9_]+=[a-ZA-Z0-9_-.]*: $OPTARG"
                            #return 1
                        #fi
                        :
                    else
                        _envP+=("${OPTARG}")
                    fi
                    (return 1)
                    ;;
                v)
                    case "${OPTARG}" in
                        0)
                            _VERBOSITY=0
                            (return 1)
                            ;;
                        1)
                            _VERBOSITY=1
                            (return 1)
                            ;;
                        2)
                            _VERBOSITY=2
                            (return 1)
                            ;;
                        3)
                            _VERBOSITY=3
                            (return 1)
                            ;;
                        4)
                            _VERBOSITY=4
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -v argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                k)
                    case "${OPTARG}" in
                        0)
                            _SECURITY_CHECK_BANNED=0
                            (return 1)
                            ;;
                        1)
                            _SECURITY_CHECK_BANNED=1
                            (return 1)
                            ;;
                        2)
                            _SECURITY_CHECK_BANNED=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -k argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                K)
                    case "${OPTARG}" in
                        0)
                            _SECURITY_GPG_VERIFY_SIGNATURE=0
                            (return 1)
                            ;;
                        1)
                            _SECURITY_GPG_VERIFY_SIGNATURE=1
                            (return 1)
                            ;;
                        2)
                            _SECURITY_GPG_VERIFY_SIGNATURE=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -K argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                S)
                    _FORCE_HTTPS_FALLBACK=1
                    (return 1)
                    ;;
                h)
                    _help="general"
                    (return 1)
                    ;;
                V)
                    _help="version"
                    (return 1)
                    ;;
                l)
                    _listnodes=1
                    (return 1)
                    ;;
                C)
                    case "${OPTARG}" in
                        0)
                            _CACHE_LEVEL=0
                            (return 1)
                            ;;
                        1)
                            _CACHE_LEVEL=1
                            (return 1)
                            ;;
                        2)
                            _CACHE_LEVEL=2
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -C argument $OPTARG."
                        return 1
                    fi
                    (return 1)
                    ;;
                B)
                    _FORCE_BASH="1"
                    (return 1)
                    ;;
                U)
                    _updatemodules=${OPTARG:-*}
                    (return 1)
                    ;;
                u)
                    _updatespace="1"
                    (return 1)
                    ;;
                Q)
                    _queryspace="1"
                    (return 1)
                    ;;
                X)
                    case "${OPTARG}" in
                        1)
                            _DEBUG_OUTPUT_PREPROCESSED=1
                            (return 2)
                            ;;
                        2)
                            _DEBUG_OUTPUT_PARSED=1
                            (return 1)
                            ;;
                        3)
                            _DEBUG_OUTPUT_TRANSFORMED_YAML=1
                            (return 1)
                            ;;
                        4)
                            _DEBUG_OUTPUT_ENV=1
                            (return 1)
                            ;;
                    esac
                    if (($? == 0)); then
                        _error "Unknown -X argument ${OPTARG-}."
                        return 1
                    fi
                    (return 1)
                    ;;
                1)
                    # Bash completion on nodes.
                    _BASH_COMPLETION=1
                    _bash_completion_current=${#_dimensions[@]}
                    (return 1)
                    ;;
                2)
                    # Bash completion on preprocess variable names
                    #_bash_completion_current=${OPTARG}
                    #_BASH_COMPLETION=2
                    _error "Not implemented."
                    (return 1)
                    ;;
                3)
                    # Bash completion on installed modules.
                    _bash_completion_current=${OPTARG}
                    _BASH_COMPLETION=3
                    (return 1)
                    ;;
                4)
                    # Bash completion on env variable names.
                    _bash_completion_current=${OPTARG}
                    _BASH_COMPLETION=4
                    (return 1)
                    ;;
                5)
                    # Bash completion on env variable values.
                    _bash_completion_current=${OPTARG}
                    _BASH_COMPLETION=5
                    (return 1)
                    ;;
                6)
                    # Bash completion on position arguments.
                    _bash_completion_current=${OPTARG}
                    _BASH_COMPLETION=6
                    (return 1)
                    ;;
                g)
                    _ENABLE_GUI="1"
                    (return 1)
                    ;;
                Z)
                    _MODULE_CHECK_VERSION_COMPATIBILITY="0"
                    (return 1)
                    ;;
                \?)
                    _error "Unknown option -${OPTARG-}."
                    _print "$_USAGE"
                    return 1
                    ;;
                :)
                    if [[ $_BASH_COMPLETION == "0" ]]; then
                        _error "Option -${OPTARG-} requires an argument."
                        _print "$_USAGE"
                        return 1
                    fi
                    (return 1)
                    ;;
            esac
            if (($? == 0)); then
                _error "Unknown option $1."
                _print "$_USAGE"
                return 1
            elif (($OPTIND == 1)); then
                # This happens when doing for example: -al
                _error "Unknown option $1."
                _print "$_USAGE"
                return 1
            fi
            shift $((OPTIND-1))
        else
            # A node name
            local _node=${1}
            # We strip these because they are no longer wanted,
            # they can come here with the auto completion script.
            local _node=${_node//\"}
            local _node=${_node//\\}
            if [[ $_node =~ ^[123]:/ ]]; then
                # This is a special format only used for dynamic auto completion.
                _dimensioncompletion=$_node
                shift
                unset _node
                continue
            elif [[ ${_node:0:1} != "/" ]]; then
                if [ "${_isshebang}" = 1 ]; then
                    _error "Cannot understand the argument '${_node}'. Did you mean: -- ${_node}?"
                else
                    _error "Node name '${_node}' must begin and end with slash. Cowboy slash (lonesome single slash) is OK."
                fi
                return 1
            fi
            if [[ $_node =~ [\ ] ]]; then
                _error "Invalid node name: $_node"
                return 1
            fi
            _dimensions+=("$_node")
            unset _node
            if (( ${#_dimensions[@]} > 3 )); then
                _error "Dimensions (node collections) cannot exceed three in total."
                return 1
            fi
            # If no namespace defined, we inject default Spacefile.yaml as ns 1.
            if (( ${#_namespaces[@]} == 0 )); then
                # This means look for default file names for the first namespace.
                _namespaces+=("file=")
            fi
            shift
        fi
    done
    unset _o
    unset _isshebang

    # Dynamic auto completion, replace a dimension.
    if [ -n "${_dimensioncompletion}" ]; then
        _debug "Dynamic completion: $_dimensioncompletion"
        local _dim="${_dimensioncompletion%%:*}"
        local _node="${_dimensioncompletion#*:}"
        _dimensions[((_dim-1))]="$_node"
        unset _dim _node
    fi

    if [[ $_BASH_COMPLETION != "0" ]]; then
        # Reset some switches that will get in our way when auto completing.
        _help=""
        _DEBUG_OUTPUT_PREPROCESSED=0
        _DEBUG_OUTPUT_PARSED=0
        _DEBUG_OUTPUT_TRANSFORMED_YAML=0
        _DEBUG_OUTPUT_ENV=0
        _updatemodules=
        _CACHE_LEVEL=1
        _listnodes=0
        _VERBOSITY=0
        _dry=0
        _loadmodules=
        _envE=()
    fi

    local CWD=$(pwd)  # Set as global environment variable.

    if [[ $_help == "version" ]]; then
        _helpversion
        return 0
    fi

    if [[ $_help == "general" ]]; then
        if (( ${#_dimensions[@]} == 0 && ${#_namespaces[@]} == 0 )); then
            _helpusage
            return 0
        else
            _help="node"
        fi
    fi

    if [ "${_queryspace}" = "1" ]; then
        _query_version_and_update "1"
        return
    fi

    if [ "${_updatespace}" = "1" ]; then
        _query_version_and_update
        return
    fi

    if [[ -n ${_updatemodules-} ]]; then
        _update_modules "$_updatemodules"
        return
    fi

    if [[ $_BASH_COMPLETION == "3" ]]; then
        _completion_modules "$_bash_completion_current"
        return
    fi

    # Check so that at least one namespace exists.
    if (( ${#_namespaces[@]} == 0 )); then
        # This means look for default file names for the first namespace.
        _namespaces+=("file=")
    fi

    # Check so that at least one dimension exists.
    if (( ${#_dimensions[@]} == 0 )); then
        _dimensions+=("/")
    fi

    # If -E environment variable file was provided then load those and
    # append variables to _envE array.
    if [ -n "${_envFiles}" ]; then
        _load_env_files
        if [ "$?" != "0" ]; then
            _error "Problem when evaluating -E environment file."
            return 1
        fi
    fi

    # Set command line -e envs, if provided.
    eval $(_apply_cmd_env)
    if [ "$?" != "0" ]; then
        _error "Problem when evaluating -e environment variables. Look for unbound variable or syntax error."
        return 1
    fi

    # Set any preprocess variables given on command line.
    local _envPs=""
    local _ev=
    for _ev in "${_envP[@]-}"; do
        _envPs=${_envPs}$_ev" "
        if [[ $_ev =~ ([_a-zA-Z0-9]+)=(.*) ]]; then
            eval "_PP_${BASH_REMATCH[1]}=\${BASH_REMATCH[2]}"
        fi
    done
    unset _ev

    # Load all YAML files into respective namespace.
    local _counter=0
    while (( _counter < ${#_namespaces[@]} )); do
        local _namespace=${_namespaces[$_counter]}
        (( _counter+=1 ))
        _debug "Loading namespace ${_counter}:${_namespace}."
        [[ $_namespace =~ (.+)=(.*) ]]
        local _t=${BASH_REMATCH[1]}
        local _path=${BASH_REMATCH[2]}
        local _yamlfile=
        local _cachefile=
        local _INCLUDEPATH=
        if [[ $_t == "file" ]]; then
            # Load file.
            if [[ -z $_path ]]; then
                # No -f give, try the defaults.
                local _cwddir=${CWD##*/}
                local _f=
                for _f in "./Spacefile.yaml"; do
                    if [[ -f $_f ]]; then
                        _path=$_f
                        break
                    fi
                done
                unset _f _cwddir

                if [[ -z $_path ]]; then
                    _error "No Spacefile.yaml file found."
                    return 1
                fi
                _debug "Found file $_path."
            elif [[ ! -f $_path ]]; then
                _error "YAML file $_path does not exist."
                return 1
            fi

            # Figure out the absolute path of $_path
            # to load the accompanying sh/bash file, if present.
            local _dir=${_path%/*}
            local _file=${_path##*/}
            if [[ -z $_dir || $_dir == "$_path" ]]; then
                _path=$CWD/$_path
                _dir=${_path%/*}
            else
                # Convert relative path to absolute.
                _dir=$( cd "$_dir" && pwd )
            fi
            _path="$_dir/$_file"
            _yamlfile=$_path

            _check_minimum_requirements "${_dir}"
            local _check_status="$?"
            if [ "$_check_status" -gt 0 ]; then
                return "$_check_status"
            fi

            # Try to load the accompanying sh/bash file
            # clone and source will always be to $_INCLUDEPATH[1],
            # so here we set that to be in $CWD.
            _INCLUDEPATH=($CWD $CWD/space_modules $_MODULES_SHARED)
            _debug "Includepath: ${_INCLUDEPATH[@]}"
            local _sourcefile="${_path%.*}"
            if [[ -f "${_sourcefile}.sh" ]]; then
                _source "${_sourcefile}.sh"
            elif [[ -f "${_sourcefile}.bash" ]]; then
                _source "${_sourcefile}.bash"
            fi
            unset _sourcefile _dir _file
            # Disabling cachefile to be put in $CWD.
            #_cachefile=$CWD"/."${_yamlfile##*/}".cache"
            # Put cache file along side yaml file.
            _cachefile=${_yamlfile%/*}
            _cachefile=$_cachefile"/."${_yamlfile##*/}".cache"
        else
            # Load module.
            local _module=$_path
            _debug "Include module $_module"
            _clone "${_module}"
            (( $? > 0 )) && return 1

            local _protocol= _domain= _domainuser= _username= _reponame="" _commit= _str_commit= _repofullname=
            _extract_repo_parts "${_module}"
            (( $? > 0 )) && return 1

            _INCLUDEPATH=($CWD/space_modules $_MODULES_SHARED $CWD)
            _debug "Includepath: ${_INCLUDEPATH[@]}"
            _module_find_yaml "$_domain/$_repofullname" "_yamlfile"
            if [[ -z $_yamlfile ]]; then
                _error "Could not find YAML file in module ${_module}."
                return 1
            fi

            _check_minimum_requirements "${_yamlfile%/*}"
            local _check_status="$?"
            if [ "$_check_status" -gt 0 ]; then
                return "$_check_status"
            fi

            # Disabling cachefile to be put in $CWD.
            #_cachefile=$CWD"/."${_yamlfile##*/}".${_repofullname//\//.}.cache"
            # Put cache file along side yaml file.
            _cachefile=${_yamlfile%/*}
            _cachefile=$_cachefile"/."${_yamlfile##*/}".cache"
            unset _module _protocol _domain _domainuser _username _reponame _commit _str_commit _repofullname
        fi

        ## Parse and load YAML file(s).
        _YAML_NAMESPACE=${_counter}
        local _parsedyaml=()
        local _parsedyamlcompletion=()

        if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
            # Output divider between namespaces if more than 1.
            if [ "${#_namespaces[@]}" -gt 1 ]; then
                printf "\n%s\n" "# Namespace ${_counter} follows:"
            fi
        fi
        _load_yaml
        local _status=$?
        if (( _status > 0 )); then
            return $_status
        fi
        unset _status

        if (( ${#_parsedyamlcompletion[@]} == 0 )); then
            _warning "There are no nodes parsed, is the cache old? Try -C0."
        else
            eval "local _parsedyamlnodelist${_YAML_PREFIX}${_YAML_NAMESPACE}=(\"\${_parsedyamlcompletion[@]}\")"
        fi

        if (( ${#_parsedyaml[@]} > 0 )); then
            # Translate all parsed into Bash variables
            local _evals=() _line= _status=0
            _parsed_yaml_to_bash "_parsedyaml" "_evals"
            if (( ${#_evals[@]} == 0 )); then
                _warning "There are no lines parsed, is the cache old? Try -C0."
            fi
            for _line in "${_evals[@]-}"; do
                eval "$_line" || _status=$?
                if (($_status != 0)); then
                    [[ $_line =~ local\ ([^\=]+) ]]
                    local _varname=${BASH_REMATCH[1]}
                    _error "Could not evaluate YAML Bash translation for variable: $_varname. Likely some syntax error in the yaml."
                    unset _varname
                    return 1
                fi
                if [[ $_DEBUG_OUTPUT_PARSED == "1" ]]; then
                    [[ $_line =~ local\ ([^\=]+) ]]
                    local _varname=${BASH_REMATCH[1]}
                    eval "printf \"%s=%s\n\" $_varname \"\$$_varname\""
                    unset _varname
                fi

            done
            unset _status _line _evals

        fi
        unset _parsedyaml
        unset _yamlrows
        unset _parsedyamlcompletion

        if [[ $_DEBUG_OUTPUT_TRANSFORMED_YAML == "1" ]]; then
            _transform_to_yaml
        fi

        # NOTE: The preprocessing variable auto completion is disabled
        # since it's use case is questioned.
        #if [[ $_BASH_COMPLETION == "2" ]]; then
            ## Look in yaml file for defined preprocess variables.
            #if [[ -e $_yamlfile ]]; then
                #printf "%s\n" "${_bash_completion_current//./.}"
                #local _r=
                #while IFS= read -r _r; do
                    #if [[ $_r =~ ^@(${_bash_completion_current}[a-zA-Z0-9_]*):- ]]; then
                        #local _var=${BASH_REMATCH[1]}
                        #printf "%s\n" "${_var}="
                    #fi
                #done < $_yamlfile
                #unset _r
                #return 0
            #fi
            #return 1
        #fi

        # Check if we now should add more namespaces to be loaded.
        if (( _counter == 1 )); then
            _YAML_NAMESPACE=1
            if (( ${#_namespaces[@]} == 1 )); then
                # We only have one ns so far, see if to add the second.
                local _file=
                _copy "_file" "/_namespaces/second/file"
                local _module=
                _copy "_module" "/_namespaces/second/module"
                if [[ -n $_file ]]; then
                    _namespaces+=("file=$_file")
                    _debug "_dimensions auto added namespace 2: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                elif [[ -n $_module ]]; then
                    _namespaces+=("module=$_module")
                    _debug "_dimensions auto added namespace 2: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                fi
                unset _file _module
            fi
            if (( ${#_namespaces[@]} == 2 )); then
                # We only have two ns's so far, see if to add the third.
                local _file=
                _copy "_file" "/_namespaces/third/file"
                local _module=
                _copy "_module" "/_namespaces/third/module"
                if [[ -n $_file ]]; then
                    _namespaces+=("file=$_file")
                    _debug "_dimensions auto added namespace 3: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                elif [[ -n $_module ]]; then
                    _namespaces+=("module=$_module")
                    _debug "_dimensions auto added namespace 3: ${_namespaces[$((${#_namespaces[@]}-1))]}."
                fi
                unset _file _module
            fi
        fi

    done
    unset _t _path _namespace _counter _yamlfile _envPs

    if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
        return 0
    fi

    if [[ $_DEBUG_OUTPUT_PARSED == "1" ]]; then
        return 0
    fi

    if [[ $_DEBUG_OUTPUT_TRANSFORMED_YAML == "1" ]]; then
        return 0
    fi

    if [[ -n $_loadmodules ]]; then
        _debug "Load modules $_loadmodules"
        _clone "${_loadmodules}"
        (( $? > 0 )) && return 1
    fi

    # Source all sh/bash files added so far.
    _source_added
    (( $? > 0 )) && return 1

    # Figure out the dimension to namespace affinity.
    local _dim1ns=1 _dim2ns=1 _dim3ns=1
    if (( ${#_namespaces[@]} >= 2 )); then
        _dim2ns=2
    fi
    if (( ${#_namespaces[@]} >= 3 )); then
        _dim3ns=3
    fi

    if [[ $_BASH_COMPLETION == "1" ]]; then
        local _dim=$_bash_completion_current
        if [[ $_dim == "0" ]]; then
            return 1
        fi
        eval "local _ns=\$_dim${_dim}ns"

        # Check if we are to use friend dimension or isolated dimensions.
        local _hasfriends=0
        _YAML_NAMESPACE=1
        local _l=()
        _list "_l" "/_dimensions/" "1"
        if (( ${#_l[@]} > 0 )); then
            _hasfriends=1
        fi
        unset _l

        if [[ $_dim == "1" ]] || ( [[ $_hasfriends == "0" ]] && (($_dim <= ${#_namespaces[@]})) ); then
            local _pattern=${_dimensions[((_dim-1))]}
            local _node=$_pattern
            if [[ ${_node: -1} != "/" ]]; then
                _node=$_node".*/"
            fi
            _debug "Bash completion dimension $_dim for pattern: $_node in namespace ${_ns}."
            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_node"
            if (( ${#_nodes[@]} == 1 )); then
                if [[ ${_nodes[0]} == $_pattern ]]; then
                    _node=$_node".*/"
                    if [[ $_pattern == "/" ]]; then
                        _nodes=("/")
                    else
                        _nodes=()
                    fi
                    _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_node"
                    if (( ${#_nodes[@]} > 0 )); then
                        printf "%s\n" "${_nodes[@]}"
                        return 0
                    else
                        # No match.
                        return 1
                    fi
                fi
            fi
            if (( ${#_nodes[@]} > 0 )); then
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _dim _pattern _node _nodes _ns
            return 1
        elif [[ $_dim == "2" ]]; then
            local _first=${_dimensions[0]}
            local _pattern=${_dimensions[1]}
            if [[ ${_first: -1} != "/" ]]; then
                _first=$_first"/"
            fi
            _debug "Bash completion dimension 2 for pattern: $_pattern in namespace ${_dim2ns}."

            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}1" "$_first"
            if (( ${#_nodes[@]} == 0 )); then
                return 1
            fi

            # Roll out second dimension filter on second ns.
            local _dim2=()
            local _node=
            for _node in "${_nodes[@]}"; do
                _get_second_dimension "$_node" "$_dim2ns"
            done
            # Filter second dimension on pattern
            local _nodes=()
            if (( ${#_dim2[@]} > 0 )); then
                for _node in "${_dim2[@]}"; do
                    if [[ $_node =~ ${_pattern}.* ]]; then
                        local _node2=
                        for _node2 in "${_nodes[@]-}"; do
                            [[ $_node2 == $_node ]] && continue 2
                        done
                        _nodes+=("$_node")
                        unset _node2
                    fi
                done
            else
                _debug "No dim2 nodes found."
            fi

            if (( ${#_nodes[@]} == 0 )); then
                return 1
            else
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _first _pattern _nodes _node
        elif [[ $_dim == "3" ]]; then
            local _first=${_dimensions[0]}
            local _second=${_dimensions[1]}
            local _pattern=${_dimensions[2]}
            if [[ ${_first: -1} != "/" ]]; then
                _first=$_first"/"
            fi
            if [[ ${_second: -1} != "/" ]]; then
                _second=$_second"/"
            fi

            local _nodes=()
            _match_node "_parsedyamlnodelist${_YAML_PREFIX}1" "$_first"
            if (( ${#_nodes[@]} == 0 )); then
                return 1
            fi

            local _dim3=()
            local _node=
            for _node in "${_nodes[@]}"; do
                _get_third_dimension "$_node" "$_second" "$_dim3ns"
            done

            # Filter third dimension on pattern
            local _nodes=()
            if (( ${#_dim3[@]} > 0 )); then
                for _node in "${_dim3[@]}"; do
                    if [[ $_node =~ ${_pattern}.* ]]; then
                        local _node2=
                        for _node2 in "${_nodes[@]-}"; do
                            [[ $_node2 == $_node ]] && continue 2
                        done
                        _nodes+=("$_node")
                        unset _node2
                    fi
                done
            fi

            if (( ${#_nodes[@]} == 0 )); then
                return 1
            else
                printf "%s\n" "${_nodes[@]}"
                return 0
            fi
            unset _first _second _pattern _nodes _node
        fi
    fi

    # Match the dimension node pattern to a nodelist from the dimension associated namespace.
    local _dim1=() _dim2=() _dim3=()
    local _pattern=
    local _dimcounter=0
    for _pattern in "${_dimensions[@]}"; do
        if [[ ${_pattern: -1} != "/" ]]; then
            _node="$_pattern/"
        fi
        if [[ ! $_pattern =~ (^/.+/$)|(^/$) ]]; then
            _error "Malformed node path ($_pattern). Node path must begin and end with a slash."
            return 1
        fi
        (( _dimcounter+=1 ))
        eval "local _ns=\$_dim${_dimcounter}ns"
        local _nodes=()
        # If $_pattern begins with underscore we'll match nodes
        # for underscore, otherwise we ignore underscore nodes.
        local _includehidden=0
        if [[ ${_pattern} =~ ^.*/_[^/]+/.*$ ]]; then
            _includehidden=1
        fi
        _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_pattern" "$_includehidden"
        if (( ${#_nodes[@]} > 0 )); then
            eval "_dim${_dimcounter}=(\"\${_nodes[@]}\")"
        else
            _error "No nodes matched for: $_pattern in namespace ${_ns}."
            return 1
        fi
    done
    unset _ns _pattern _dimcounter _nodes

    # Show some debug info about namespaces.
    local _nsload= _s="" _counter=0
    for _nsload in "${_namespaces[@]}"; do
        ((_counter+=1))
        _s="$_s ${_counter}:${_nsload}"
    done
    _debug "Namespaces loaded:${_s}."
    unset _s _nsload _counter

    # Start executing on the dimensions.
    local _first= _second= _third=

    if [[ $_help == "node" ]]; then
        _YAML_NAMESPACE=$_dim1ns
        for _first in "${_dim1[@]}"; do
            _helpnode "$_first"
        done
        if [ "${#_dim2[@]}" -gt 0 ]; then
            _YAML_NAMESPACE=$_dim2ns
            for _second in "${_dim2[@]}"; do
                _helpnode "$_second"
            done
        fi
        if [ "${#_dim3[@]}" -gt 0 ]; then
            _YAML_NAMESPACE=$_dim3ns
            for _third in "${_dim3[@]}"; do
                _helpnode "$_third"
            done
        fi
        return 0
    fi

    #
    # GUI mode
    if [ "$_ENABLE_GUI" -eq "1" ]; then
        _enter_gui_mode
        return 0
    fi

    local _status=0
    local _nodecombo=
    local _dimorder=""
    local _dimensions_fill=0
    _YAML_NAMESPACE=1
    _copy "_dimorder" "/_dimensions_order"
    _copy "_dimensions_fill" "/_dimensions_fill"
    if [ -z "${_dimensions_fill}" ]; then
        _dimensions_fill=0
    elif [[ ! $_dimensions_fill =~ [0-3] ]]; then
        _error "_dimensions_fill must be a number: 0 to 3."
        return 1
    fi
    local _execcounter=0
    local _exectotal=${#_dim1[@]}
    local _execmax=-1  # How many combos to maximum run, -1 = run all.
    # Check if this is a dimensin completion we then we run only one combo.
    if [ -n "${_dimensioncompletion}" ]; then
        _execmax=1
    fi
    for _first in "${_dim1[@]}"; do
    _context()
    {
        printf -v _nodecombo "%s:%s" "$_dim1ns" "$_first"
        if (( ${#_dim2[@]} == 0 )) && [ "${_dimensions_fill}" -le 2 ]; then
            local _dim2=()
            _get_second_dimension "$_first" "$_dim2ns"
            _status=$?
            (( _status > 0 )) && return
            # We only keep the first node.
            #if (( ${#_dim2[@]} > 0 )); then
                #_dim2=("${_dim2[0]}")
            #fi
        fi
        if (( ${#_dim2[@]} > 0 )); then
            _exectotal=$((${#_dim1[@]} * ${#_dim2[@]} ))
            for _second in "${_dim2[@]}"; do
                _context2()
                {
                    printf -v _nodecombo "%s:%s %s:%s" "$_dim1ns" "$_first" "$_dim2ns" "$_second"
                    if (( ${#_dim3[@]} == 0 )) && [ "${_dimensions_fill}" -le 3 ]; then
                        local _dim3=()
                        _get_third_dimension "$_first" "$_second" "$_dim3ns"
                        _status=$?
                        (( _status > 0 )) && return $_status
                    fi
                    if (( ${#_dim3[@]} > 0 )); then
                        _exectotal=$((${#_dim1[@]} * ${#_dim2[@]} * ${#_dim3[@]} ))
                        for _third in "${_dim3[@]}"; do
                            printf -v _nodecombo "%s:%s %s:%s %s:%s" "$_dim1ns" "$_first" "$_dim2ns" "$_second" "$_dim3ns" "$_third"
                            ((_execcounter += 1 ))
                            if ((_execmax >= 0 && _execcounter > _execmax)); then
                                _status=0
                                break
                            fi
                            _exec_dimensions "$_dim1ns" "$_first" "$_dim2ns" "$_second" "$_dim3ns" "$_third" "$_dimorder" "${_execcounter}" "${_exectotal}" "$@"
                            _status=$?
                            (( _status > 0 )) && break
                        done
                    else
                        ((_execcounter += 1 ))
                        if ((_execmax >= 0 && _execcounter > _execmax)); then
                            _status=0
                            break
                        fi
                        _exec_dimensions "$_dim1ns" "$_first" "$_dim2ns" "$_second" "" "" "$_dimorder" "${_execcounter}" "${_exectotal}" "$@"
                        _status=$?
                    fi
                }
                _context2 "$@"
                (( _status > 0 )) && break
            done
        else
            ((_execcounter += 1 ))
            if ((_execmax >= 0 && _execcounter > _execmax)); then
                _status=0
                break
            fi
            _exec_dimensions "$_dim1ns" "$_first" "" "" "" "" "$_dimorder" "${_execcounter}" "${_exectotal}" "$@"
            _status=$?
        fi
    }
        _context "$@"
        if (( _status > 0 )); then
            _debug "Node(s): $_nodecombo failed executing (status: $_status)."
            return $_status
        fi
    done


    return 0
}

#======================
# _load_env_files
#
# Load variables from sh file.
#   var=value
#   export var=value
#
# Append these variables to environemnt -e variables.
#
# Expects:
# _envE
# _envFiles
#
#======================
_load_env_files()
{
    local _s= _line=
    for _s in ${_envFiles}; do
        while read -r _line || [ -n "$_line" ]; do
            if [ "${_line:0:1}" == "#" ]; then
                continue
            fi
            _line="${_line#export }"
            _envE+=("${_line}")
        done < ${_s}
    done
}

#======================
# _get_second_dimension
#
# For a first dimension get the second
# dimension if defined.
#
# Parameters:
#   $1: node in first dimension.
#   $2: namespace for second dimension.
#
# Expects:
#   $_dim2: will get added to
#
#======================
_get_second_dimension()
{
    local _node1=$1
    shift

    local _ns=$1
    shift

    local _levels1=${_node1//[^\/]}
    _levels1=${#_levels1}

    _YAML_NAMESPACE=1
    local _l=()
    _list "_l" "/_dimensions/" "1"

    if (( ${#_l[@]} > 0 )); then
        local _i=
        for _i in ${_l[@]}; do
            local _firststr= _secondstr=
            _copy "_firststr" "/_dimensions/$_i/first"
            _copy "_secondstr" "/_dimensions/$_i/second"
            if [[ -z $_firststr || -z $_secondstr ]]; then
                continue
            fi
            local _firstarr=() _secondarr=()
            IFS=' ' read -r -a _firstarr <<< "$_firststr"
            IFS=' ' read -r -a _secondarr <<< "$_secondstr"
            local _first=
            for _first in "${_firstarr[@]}"; do
                if [[ ! $_first =~ (^/.+/$)|(^/$) ]]; then
                    _error "Malformed _dimensions/${_i}/first node path (${_first}). Node path must begin and end with a slash."
                    return 1
                fi
                local _levelsfirst=${_first//[^\/]}
                _levelsfirst=${#_levelsfirst}
                if [[ $_levels1 == $_levelsfirst && $_node1 =~ ^${_first}$ ]]; then
                    local _second=
                    for _second in "${_secondarr[@]}"; do
                        if [[ ! $_second =~ (^/.+/$)|(^/$) ]]; then
                            _error "Malformed _dimensions/${_i}/second node path (${_second}). Node path must begin and end with a slash."
                            return 1
                        fi
                        local _nodes=()
                        local _includehidden=0
                        if [[ ${_second} =~ ^.*/_[^/]+/.*$ ]]; then
                            _includehidden=1
                        fi
                        _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_second" "${_includehidden}"
                        if (( ${#_nodes[@]} == 0 )); then
                            _debug "Friend nodes defined for second dimension but then not found in namespace ${_ns}: ${_second}."
                        else
                            _debug "_dimensions _dimensions/$((_i+1))/ Pattern: $_first $_second matched ${#_nodes[@]} nodes for second dimension in namespace ${_ns}."
                            _dim2+=("${_nodes[@]}")
                        fi
                    done
                    break # No point checking further if current first matched.
                fi
            done
            if [ "${#_dim2[@]}" -gt 0 ]; then
                # Quit if matched.
                break
            fi
        done
    fi
}

#=====================
# _get_third_dimension
#
# For a first and second dimension
# combo get the third dimension if defined.
#
# Parameters:
#   $1: node in first dimension.
#   $2: node in second dimension.
#   $3: namespace for third dimension.
#
# Expects:
#   $_dim3: will get added to
#
#=====================
_get_third_dimension()
{
    local _node1=$1
    shift

    local _node2=$1
    shift

    local _ns=$1
    shift

    local _levels1=${_node1//[^\/]}
    _levels1=${#_levels1}
    local _levels2=${_node2//[^\/]}
    _levels2=${#_levels2}

    _YAML_NAMESPACE=1
    local _l=()
    _list "_l" "/_dimensions/" "1"

    if (( ${#_l[@]} > 0 )); then
        local _i=
        for _i in ${_l[@]}; do
            local _firststr= _secondstr= _thirdstr=
            _copy "_firststr" "/_dimensions/$_i/first"
            _copy "_secondstr" "/_dimensions/$_i/second"
            _copy "_thirdstr" "/_dimensions/$_i/third"
            if [[ -z $_firststr || -z $_secondstr || -z $_thirdstr ]]; then
                continue
            fi
            local _firstarr=() _secondarr=() _thirdarr=()
            IFS=' ' read -r -a _firstarr <<< "$_firststr"
            IFS=' ' read -r -a _secondarr <<< "$_secondstr"
            IFS=' ' read -r -a _thirdarr <<< "$_thirdstr"
            local _first=
            for _first in "${_firstarr[@]}"; do
                if [[ ! $_first =~ (^/.+/$)|(^/$) ]]; then
                    _error "Malformed _dimensions/${_i}/first node path (${_first}). Node path must begin and end with a slash."
                    return 1
                fi
                local _levelsfirst=${_first//[^\/]}
                _levelsfirst=${#_levelsfirst}
                if [[ $_levels1 == $_levelsfirst && $_node1 =~ ^${_first}$ ]]; then
                    local _second=
                    for _second in "${_secondarr[@]}"; do
                        if [[ ! $_second =~ (^/.+/$)|(^/$) ]]; then
                            _error "Malformed _dimensions/${_i}/second node path (${_second}). Node path must begin and end with a slash."
                            return 1
                        fi
                        local _levelssecond=${_second//[^\/]}
                        _levelssecond=${#_levelssecond}
                        if [[ $_levels2 == $_levelssecond && $_node2 =~ ^${_second}$ ]]; then
                            local _third=
                            for _third in "${_thirdarr[@]}"; do
                                if [[ ! $_third =~ (^/.+/$)|(^/$) ]]; then
                                    _error "Malformed _dimensions/${_i}/third node path (${_third}). Node path must begin and end with a slash."
                                    return 1
                                fi
                                local _nodes=()
                                local _includehidden=0
                                if [[ ${_third} =~ ^.*/_[^/]+/.*$ ]]; then
                                    _includehidden=1
                                fi
                                _match_node "_parsedyamlnodelist${_YAML_PREFIX}${_ns}" "$_third" "${_includehidden}"
                                if (( ${#_nodes[@]} == 0 )); then
                                    _error "Friend nodes defined for third dimension but then not found in namespace ${_ns}: ${_third}."
                                    return 1
                                else
                                    _debug "_dimensions _dimensions/$((_i+1))/ Pattern: $_first $_second $_third matched ${#_nodes[@]} nodes for third dimension in namespace ${_ns}."
                                    _dim3+=("${_nodes[@]}")
                                fi
                            done
                            break # No point in check next second if already matched.
                        fi
                    done
                    if [ "${#_dim3[@]}" -gt 0 ]; then
                        # Quit if matched.
                        break 2
                    fi
                fi
            done
        done
    fi
}

#=================
# _exec_dimensions
#
# Merge nodes from one, two or three
# dimensions and execute.
#
#=================
_exec_dimensions()
{
    local _ns1=$1
    shift

    local _node1=$1
    shift

    local _ns2=$1
    shift

    local _node2=$1
    shift

    local _ns3=$1
    shift

    local _node3=$1
    shift

    local _dimorder=$1
    shift

    local _currentexecuting=$1
    shift

    local _counttoexecute=$1
    shift

    local _dimorder1=1
    local _dimorder2=2
    local _dimorder3=3
    if [ -n "${_dimorder}" ]; then
        # Arrange dimensions and their namespaces according to _dimorder.
        _debug "The dimension order specified is: ${_dimorder}."
        if [[ -n $_node3 ]]; then
            if [ "${#_dimorder}" -ne 5 ]; then
                _error "The dimension order must be on the format 'x y z', it is: $_dimorder."
                return 1
            fi
            local _i=
            for _i in ${_dimorder}; do
                if [ "${_i}" -eq 1 ]; then
                    _push "_ns1"
                    _push "_node1"
                    _push "_dimorder1"
                elif [ "${_i}" -eq 2 ]; then
                    _push "_ns2"
                    _push "_node2"
                    _push "_dimorder2"
                elif [ "${_i}" -eq 3 ]; then
                    _push "_ns3"
                    _push "_node3"
                    _push "_dimorder3"
                fi
            done
            _pop "_dimorder3"
            _pop "_node3"
            _pop "_ns3"
            _pop "_dimorder2"
            _pop "_node2"
            _pop "_ns2"
            _pop "_dimorder1"
            _pop "_node1"
            _pop "_ns1"
        elif [[ -n $_node2 ]]; then
            if [ "${#_dimorder}" -lt 3 ]; then
                _error "The dimension order must be on the format 'x y[ z]', it is: $_dimorder."
                return 1
            fi
            _push "_ns2"
            _push "_node2"
            _push "_dimorder2"
            _push "_ns1"
            _push "_node1"
            _push "1"
            _push "_dimorder1"
            local _i=
            for _i in ${_dimorder}; do
                if [ "${_i}" -eq 1 ]; then
                    _pop "_dimorder1"
                    _pop "_node1"
                    _pop "_ns1"
                elif [ "${_i}" -eq 2 ]; then
                    _pop "_dimorder2"
                    _pop "_node2"
                    _pop "_ns2"
                else
                    continue
                fi
            done
        fi
    fi

    local _nodecombo=
    printf -v _nodecombo "%s%s%s" "$_node1" "${_node2:+ $_node2}" "${_node3:+ $_node3}"

    if [[ ${_listnodes-} == "1" ]]; then
        printf "%s\n" "$_nodecombo"
        return 0
    fi

    # Isolate all -e cmd variables.
    # This is important to do here because
    # if we are iterating many nodes the variables
    # might get changed, either by YAML parsing,
    # module build functions or space it self.
    eval $(_apply_cmd_env "isolate")

    local _nodes=("$_ns1 $_node1")
    [[ -n $_node2 ]] && _nodes+=("$_ns2 $_node2")
    [[ -n $_node3 ]] && _nodes+=("$_ns3 $_node3")

    # These will be populated by _loadnode.
    local _infotitle="" _infodesc=""
    local _envvar=""       # When completing on a specific variable or positional argument.
    local _envvarindex="0"  # Position argument index for SPACE_ARGS
    local _envvalues=()
    local _envcompletion=""
    if [[ $_BASH_COMPLETION == "5" ]]; then
        _envvar="${_bash_completion_current%%=*}"
        local _envval="${_bash_completion_current#*=}"
    elif [[ $_BASH_COMPLETION == "6" ]]; then
        _envvar="SPACE_ARGS"
        _envvarindex="${_bash_completion_current%%=*}"
        local _envval="${_bash_completion_current#*=}"
    fi

    local _envcompletion2= _envcompletion2dim=
    local _status=0 _tuple= _node= _ns= _counter=0
    for _tuple in "${_nodes[@]}"; do
        (( _counter += 1 ))
        [[ $_tuple =~ ([^\ ]+)[\ ](.+) ]]
        _ns=${BASH_REMATCH[1]}
        _node=${BASH_REMATCH[2]}
        _YAML_NAMESPACE=${_ns}
        while :; do
            local _res=()
            _debug "Load node: ${_node}, from namespace: ${_ns}."
            _loadnode "_res" "$_node" "$_strip_args"
            _status=$?
            if (($_status != 0)); then
                _error "Could not evaluate node variables for node: $_node. There's probably some syntax error in the YAML."
                return 1
            fi

            # auto completion.
            if [ -n "${_envcompletion}" ]; then
                _envcompletion2=$_envcompletion
                # We need to transform back to the original dimension order.
                eval "_envcompletion2dim=\$_dimorder${_counter}"
                _envcompletion=
            fi

            # TODO: this trap thing is not very efficient in catching the right errors.
            trap '_error "Problem when evaluating syntax for node: ${_node}. Look for unbound variable or other syntax error in the YAML."; trap - EXIT; return 1; ' EXIT
            if (( ${#_res[@]} > 0 )); then
                local _str=
                for _str in "${_res[@]}"; do
                    if [[ $_DEBUG_OUTPUT_ENV == "1" ]]; then
                        printf "%s" "$_str"
                    fi
                    _status=0
                    eval "$_str" || _status="$?" 
                    if (($_status != 0)); then
                        _error "Could not evaluate node variables for node: $_node. There's probably some syntax error in the YAML."
                        trap - EXIT
                        return 1
                    fi
                done
                unset _Str
            fi
            trap - EXIT

            if [[ -n ${RUN_ALIAS-} ]]; then
                # Rerun for the new node, same namespace.
                _debug "Alias $_node to $RUN_ALIAS, namespace $_ns."
                if [[ ! $RUN_ALIAS =~ (^/[^ ]+/$)|(^/$) ]]; then
                    _error 'RUN_ALIAS must begin and end with slash, and have no funny characters. Like: /a/b/c/'
                    return 1
                fi
                _node=$RUN_ALIAS
                unset RUN_ALIAS
                # will continue
            else
                break
            fi
        done
    done
    unset _ns

    # auto completion.
    if [ -n "${_envcompletion2}" ]; then
        printf "%s\n" "$_envcompletion2dim:$_envcompletion2"
        return 2
    fi

    if [[ $_BASH_COMPLETION == "4" || $_BASH_COMPLETION == "5" || $_BASH_COMPLETION == "6" ]]; then
        local _sep="="
        if [[ $_BASH_COMPLETION == "5" ]] || [[ $_BASH_COMPLETION == "6" ]]; then
            _sep=""
        fi
        if [ "${#_envvalues[@]}" -gt 0 ]; then
            printf "%s$_sep\n" "${_envvalues[@]}"
            return 0
        fi
        return 1
    fi

    if [[ $_DEBUG_OUTPUT_ENV == "1" ]]; then
        return 0
    fi

    if [[ -z ${RUN-} ]]; then
        _error "No RUN environment variable specified in YAML nodes nor on command line. Use -h to get help or -a -l to list all child nodes."
        return 1
    fi

    _debug "Execute on $_nodecombo."
    _execute "$@"
    return $?
}

#===========
# _load_yaml
#
# Helper "macro" to _main to
# load, preprocess, parse and cache YAML file.
#
#===========
_load_yaml()
{
    if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
        _CACHE_LEVEL=0
    fi
    if (( $_CACHE_LEVEL == 1 )); then
        # Use cache if exists and still valid
        if [[ -e $_cachefile ]]; then
            _debug "Found cache file: $_cachefile"
            local _allrows=() _r=
            while IFS= read -r _r; do
                _allrows+=("$_r")
            done < $_cachefile
            unset _r
            local _cache_format=${_allrows[0]}

            local _isvalid=0
            while :; do
                if [[ $_cache_format != "$_CACHE_FORMAT" ]]; then
                    _debug "Cached format changed, invalidating."
                    break
                fi

                local _filelist=${_allrows[1]}
                local _filesum=${_allrows[2]}
                local _fileenvps=${_allrows[3]}

                # Check so that the first file in the list corresponds to $_yamlfile
                if [[ ${_filelist%%\ *} != $_yamlfile ]]; then
                    break
                fi

                local _currentsum=
                # EXTERNAL: cat
                [[ -n $_SHASUMBIN ]] && _currentsum=$(cat $_filelist 2>/dev/null | ${_SHASUMBIN} 2>/dev/null)

                if [[ -z $_currentsum ]]; then
                    _warning "Caching could not be used since checksum could not be generated"
                elif [[ $_currentsum == "$_filesum" && (-z $_envPs || $_envPs == "$_fileenvps") ]]; then
                    # Timestamps work out
                    _debug "Reusing cache: $_cachefile"
                    if [[ $_envPs != $_fileenvps ]]; then
                        _warning "Using cached -p variables."
                        _debug "Cached -p variables: $_fileenvps"
                    fi
                    IFS=';' read -r -a _parsedyamlcompletion <<< "${_allrows[4]}"
                    _parsedyaml=("${_allrows[@]:5}")
                    _isvalid=1
                fi
                break
            done
            if [[ $_isvalid == "0" ]]; then
                _debug "Cached version not valid."
            fi
            unset _filelist _filesum _fileenvps

            unset _allrows
        else
            _debug "Cache file not found: $_cachefile"
        fi
    elif (( $_CACHE_LEVEL == 0 )); then
        # rm cache file, to avoid future confusions.
        _debug "Deleting cache file: $_cachefile"
        # EXTERNAL: rm
        rm -f $_cachefile
    fi

    if (( ${#_parsedyaml[@]} == 0 )); then
        # (re)generate yaml
        _debug "preprocess YAML file: $_yamlfile ..."
        local _yamlrows=() _parents=() _yamlfilelist=""
        # Preprocess variable that points to the directory of the YAML file being processed
        local _PP_DIR=${_yamlfile%/*}
        # Preprocess variable that points to current CWD where user invoked space.
        local _PP_CWD=$CWD
        if [[ $_PP_DIR != $_PP_CWD ]]; then
            # If CWD is different that initial YAML file dir, then add
            # YAML file dir to _INCLUDEPATH.
            _INCLUDEPATH+=("$_PP_DIR")
        fi
        _pp_yaml "_yamlrows" $_yamlfile
        local _status=$?
        if (($_status == 2)); then
            _error "Could not find file: $_yamlfile"
            return 1
        elif (($_status > 0)); then
            return 1
        fi
        _debug "...done preprocessing."
        unset _status

        if [[ $_DEBUG_OUTPUT_PREPROCESSED == "1" ]]; then
            local _line=
            for _line in "${_yamlrows[@]}"; do
                printf "%s\n" "$_line"
            done
            unset _line
        fi

        _debug "parse YAML ..."
        if (( ${#_yamlrows[@]} > 0 )); then
            _parse_yaml "_yamlrows" "_parsedyaml" "_parsedyamlcompletion"
            (( $? > 0 )) && return 1
            local _quicksort_output=()
            _quicksort "${_parsedyamlcompletion[@]}"
            _parsedyamlcompletion=("${_quicksort_output[@]}")
        fi
        unset _parents
        _debug "...done parsing"

        if (( $_CACHE_LEVEL > 0 )); then
            # (re)save cache file.
            _debug "Write to cache file: $_cachefile"

            local _currentsum=
            # EXTERNAL: cat
            [[ -n $_SHASUMBIN ]] && _currentsum=$(cat $_yamlfilelist 2>/dev/null | ${_SHASUMBIN} 2>/dev/null)

            if [[ -z $_currentsum ]]; then
                _warning "Cache could not be stored since checksum could not be generated"
            else
                printf "%s\n" "$_CACHE_FORMAT" > $_cachefile
                printf "%s\n" "$_yamlfilelist"  >> $_cachefile
                printf "%s\n" "$_currentsum" >> $_cachefile
                printf "%s\n" "$_envPs" >> $_cachefile
                local _s=$(IFS=';'; echo "${_parsedyamlcompletion[*]-}")
                printf "%s\n" "$_s" >> $_cachefile
                unset _s
                if (( ${#_parsedyaml[@]} > 0 )); then
                    printf "%s\n" "${_parsedyaml[@]}" >> $_cachefile
                fi
            fi
        fi
        unset _yamlfilelist
    fi
}

#====================
# _completion_modules
#
# Perform Bash auto completion on modules.
#
#====================
_completion_modules()
{
    local _bash_completion_current=$1
    shift

    local _places=( "$CWD/space_modules" "$_MODULES_SHARED" )
    local _dir=
    local _f=$_bash_completion_current
    local _default=${_bash_completion_current}

    if [[ ${_f} == "." ]]; then
        _f=""
    fi

    local _items=() _i=
    for _i in 1 2; do
        for _dir in "${_places[@]}"; do
            # EXTERNAL: find
            local _modules=$(cd $_dir 2>/dev/null && find . -mindepth 3 -maxdepth 3 -wholename "./${_f}*" -type d)
            for _f in $_modules; do 
                _items+=("${_f:2}")
            done
        done
        if (( ${#_items[@]} == 1 )); then
            printf "%s\n" "${_items[0]}"
            break
        elif (( ${#_items[@]} > 1 )); then
            if [[ $_default != $_bash_completion_current ]]; then
                # Rewrite current word.
                printf "%s\n" "$_default"
                printf "%s\n" "${_items[@]}"
                return 3
            else
                printf "%s\n" "${_items[@]}"
                break
            fi
        else
            if [[ ! $_f =~ \/ ]]; then
                _default="gitlab.com/space-sh/"
                _f="gitlab.com/space-sh/$_f"
            elif [[ ! $_f =~ space-sh\/([^\/]*) ]]; then
                _default="gitlab.com/space-sh/"
                _f="gitlab.com/space-sh/$_f"
            else
                return 1
            fi
        fi
    done
    unset _f
}

_query_version_and_update()
{
    local _only_check_version="${1-0}"

    local _installer_url="https://get.space.sh"
    if [ "$_only_check_version" -eq "1" ]; then
        _installer_url="${_installer_url}/?checkversion"
    fi
    _debug "Checking version from: $_installer_url"

    local _current_space_version="'${_VERSION}'"
    local _latest_space_version=

    local _tmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')
    if [ "$?" -gt 0 ]; then
        _error "Could not mktemp directory"
        return 1
    fi

    local _tmpfilename="installer.txt"
    local _tmpfile="${_tmpdir}/${_tmpfilename}"

    _compare_current_version_to_latest_available()
    {
        local _version=
        while IFS= read -r _version; do
            if [[ "$_version" =~ (_version=)(\'.*\') ]]; then
                _latest_space_version="${BASH_REMATCH[2]}"
                break
            fi
        done < "$_tmpfile"

        if [ "$_current_space_version" = "$_latest_space_version" ]; then
            _print "Space is up to date"
            return 0
        else
            local _current_version=${_current_space_version//\'/}
            local _current_major=${_current_version%%.*}
            local _current_minor=${_current_version#*.}
            _current_minor=${_current_minor%.*}
            local _latest_version=${_latest_space_version//\'/}
            local _latest_major=${_latest_version%%.*}
            local _latest_minor=${_latest_version#*.}
            _latest_minor=${_latest_minor%.*}

            if [ "$_current_major" -lt "$_latest_major" ] \
                || ( [ "$_current_major" -le "$_latest_major" ] && [ "$_current_minor" -lt "$_latest_minor" ]); then
                _print "A new Space version is available: ${_latest_space_version}. Update by running: \`space -u\`"
                _print "For more information visit https://space.sh"
                return 1
            else
                _print "Current Space version is newer (${_current_version}) than the latest (${_latest_version})"
                return 2
            fi
        fi
    }

    _update_space()
    {
        _debug "Updating Space. Temporary directory: $_tmpdir"
        cd "$_tmpdir"
        if [ "$?" -eq 0 ]; then
            local _sh="env sh"
            if [ "${_FORCE_BASH}" = "1" ]; then
                _sh="env bash"
            fi
            ${_sh} "${_tmpfilename}"
        else
            _error "Failed to change to temporary directory: $_tmpdir"
            return 1
        fi
    }

    if [ "$_HTTPBIN" = "curl" ]; then
        _status_code=$($_HTTPBIN -sL --write-out %{http_code} --silent --output "$_tmpfile" $_installer_url)
        if [ "$_status_code" -eq 200 ]; then
            _compare_current_version_to_latest_available
            if [ "$?" -ne 0 ] && [ "$_only_check_version" -ne 1 ]; then
                _update_space
            fi
            rm "$_tmpfile"
            return 0
        else
            _error "Error trying to fetch ${_installer_url} with curl. Status code: ${_status_code}"
            return "1"
        fi

    elif [ "$_HTTPBIN" = "wget" ]; then
        _status_code=$($_HTTPBIN -O "$_tmpfile" $_installer_url 2>/dev/null)
        if [ "$?" -eq 0 ] && [ "$_only_check_version" -ne 1 ]; then
            _compare_current_version_to_latest_available
            if [ "$?" -ne 0 ]; then
                _update_space
            fi
            rm "$_tmpfile"
            return 0
        else
            _error "Error trying to fetch ${_installer_url} with wget. Status code: $?"
            return "1"
        fi
    else
        _error "Could not update Space: failed to find curl or wget"
        return 1
    fi
}

#===============
# _update_modules
#
# Update all existing space modules
#
#===============
_update_modules()
{
    local _updatemodules=$1
    shift

    # EXTERNAL: git
    if ! command -v git >/dev/null; then
        _error "Git is not installed, cannot update modules."
        return 1
    fi

    local _pattern=".*"
    if [[ $_updatemodules != "*" ]]; then
        local _domainname="gitlab.com"
        local _username="space-sh"
        local _reponame=$_updatemodules 
        if [[ $_updatemodules  =~ (.+)/(.+)/(.+) ]]; then
            _domainname=${BASH_REMATCH[1]}
            _username=${BASH_REMATCH[2]}
            _reponame=${BASH_REMATCH[3]}
        elif [[ $_updatemodules  =~ (.+)/(.+) ]]; then
            _username=${BASH_REMATCH[1]}
            _reponame=${BASH_REMATCH[2]}
        fi
        if [[ $_username == "*" ]]; then
            _username=".*"
        fi
        if [[ $_reponame == "*" ]]; then
            _reponame=".*"
        fi
        _pattern="./$_domainname/$_username/$_reponame"
    fi
    _info "Updating space modules to pattern: $_pattern"
    local _places=( "$CWD/space_modules" "$_MODULES_SHARED" )
    local _dir=
    for _dir in "${_places[@]}"; do
        # EXTERNAL: find
        local _modules=$(cd $_dir 2>/dev/null && find . -mindepth 3 -maxdepth 3 -type d -regex "$_pattern")
        if [[ -n $_modules ]]; then
            _info "Modules found in $_dir: " $_modules
            (
                cd $_dir 2>/dev/null
                for d in $_modules; do
                    d=${d:2}
                    _info "Update module $_dir/$d"
                    cd $_dir/$d
                    # EXTERNAL: git
                    if [[ -d .git ]] ; then
                        # Check the module banlist.
                        local _giturl=$(git config --get remote.origin.url)
                        if [[ "$d" =~ .*[:]+(.*) ]]; then
                            _module_check_banlist "${_giturl}:${BASH_REMATCH[1]}"
                            (( $? > 0 )) && return 1

                            git symbolic-ref -q HEAD > /dev/null 2>&1
                            if [ "$?" -gt "0" ]; then
                                _info "Skipping update. Keeping revision ${BASH_REMATCH[1]}";
                                continue
                            fi
                        else
                            _module_check_banlist "$_giturl"
                            (( $? > 0 )) && return 1
                        fi
                        local _current_version=""
                        local _new_version="master"
                        if [ -f "./${_MODULE_STABLE_FILE_NAME}" ]; then
                            local _latest_stable_version=
                            _get_module_latest_stable_version "./${_MODULE_STABLE_FILE_NAME}"
                            if [ "$?" -gt 0 ]; then
                                return 1
                            fi

                            _current_version=${_latest_stable_version}
                        fi
                        git checkout master > /dev/null 2>&1
                        if [ "$?" -gt 0 ]; then
                            _error "Failed to checkout master branch"
                            return 1
                        fi
                        local _git_pull_output=
                        _git_pull_output=$(git pull 2>&1)
                        if [ "$?" -gt 0 ]; then
                            _error "Failed to pull master branch"
                            continue
                        fi
                        if [ -f "./${_MODULE_STABLE_FILE_NAME}" ]; then
                            local _latest_stable_version=
                            _get_module_latest_stable_version "./${_MODULE_STABLE_FILE_NAME}"
                            if [ "$?" -gt 0 ]; then
                                return 1
                            fi

                            _new_version=${_latest_stable_version}

                            if [ "$_current_version" != "$_new_version" ]; then
                                _info "Updating to version: $_new_version"
                            else
                                _info "Keeping version: $_new_version"
                            fi
                            git checkout "$_new_version" > /dev/null 2>&1
                            if [ "$?" != "0" ]; then
                                _error "Could not Git checkout $_new_version of $_reponame."
                                return 1
                            fi
                        else
                            if [ "$_git_pull_output" = "Already up-to-date." ]; then
                                _info "Already up-to-date"
                            else
                                _info "Updated to latest master"
                            fi
                        fi
                        if [[ -f .gitmodules ]]; then
                            git submodule update >&2
                            if (( $? > 0 )); then
                                _error "Could not perform Git submodule update. Is Perl installed?"
                                return 1
                            fi
                        fi
                        # TODO Check the signature of the commit, if applicable.
                    else
                        _warning "Directory $_dir/$d is not a Git repository and cannot be updated."
                    fi
              done
            )
            if [ "$?" -gt 0 ]; then
                return 1
            fi
        else
            _info "No modules found in $_dir."
        fi
    done
}

#============
# _parsed_yaml_to_bash
#
# Translate parsed YAML into Bash variables.
#
# Parameters:
#   $1: variable name of input array.
#   $2: variable name of output array.
#
#============
_parsed_yaml_to_bash()
{
    local _invarname=$1
    shift

    local _outvarname=$1
    shift

    local _allrows=()
    eval "_allrows=(\"\${"${_invarname}"[@]}\")"

    local _line= _str= _varname= _haddata=0
    for _line in "${_allrows[@]}"; do
        if [[ -z $_varname ]]; then
            _varname="${_YAML_PREFIX}${_YAML_NAMESPACE}${_line}"
            _str="local $_varname="$'\n'"IFS= read -d '' -r $_varname << \"$_SPACEGAL_EOF_TAG\""
        elif [[ $_line == "$_SPACEGAL_EOF_TAG" ]]; then
            _str=$_str$'\n'$_SPACEGAL_EOF_TAG$'\n'
            if [ "${_haddata}" -eq 1 ]; then
                _str="${_str}${_varname}=\${${_varname}: 0:\$(( \${#${_varname}} > 0 ? \${#${_varname}}-1 : 0 ))}"$'\n'
            else
                _str="${_str}:"$'\n'
            fi
            eval "$_outvarname+=(\"\$_str\")"
            _str=""
            _varname=
            _haddata=0
        else
            _str=$_str$'\n'$_line
            _haddata=1
        fi
    done
}

#==========
# _match_node
#
# Matches a given pattern to a list of nodes
#
# Parameters:
# $1: name of array containing sorted list of nodes.
# $2: pattern to match against list of nodes, ex: "/sites/.*/".
# $3: include hidden nodes. set to 1 to include hidden leave nodes beginning with an underscore.
# $4: simple, set to 1 to only return the last node part.
# $5: includeleafs, set to 1 to include leaf nodes.
#
# Expects:
#   $_nodes: Array to add results to.
#
#==========
_match_node()
{
    local _inputname=$1
    shift

    local _nodepath=$1
    shift

    local _includehidden=${1:-0}
    shift || :

    local _simple=${1:-0}
    shift || :

    local _includeleafs=${1:-0}
    shift || :

    local _item= _node= _isleaf=
    local _nodelist=()
    eval '
    for _item in "${'$_inputname'[@]-}"; do
        if [[ $_item =~ ([^ ]+)\ (.*) ]]; then
            _node=${BASH_REMATCH[1]}
            _isleaf=${BASH_REMATCH[2]}
            if [[ ($_isleaf == "1" && $_includeleafs == "1") || $_isleaf == "0" ]]; then
                _nodelist+=($_node)
            fi
        fi
    done
    '
    unset _item _node _isleaf

    if ((${#_nodelist[@]} == 0)); then
        return 0
    fi

    local _item= _levels=
    local _match= _matched=

    # Figure out how many levels we have by counting slashes.
    _levels=${_nodepath//[^\/]}
    _levels=${#_levels}
    ((_levels-=1))
    if (($_levels == 0)); then
        _nodes+=("/")
    else
        _match=""
        for ((i=0; i<$_levels; i++)); do
            #if ((i < _levels-1)) || [[ $_includehidden == "1" ]]; then
            if [[ $_includehidden == "1" ]]; then
                _match="${_match}/[a-zA-Z0-9_]+"
            else
                _match="${_match}/[a-zA-Z0-9][a-zA-Z0-9_]*"
            fi
        done
        _match="${_match}/"
        for _item in "${_nodelist[@]}"; do
            if [[ $_item =~ ^($_match)$ ]]; then
                _matched=${BASH_REMATCH[1]}
                if [[ $_matched =~ $_nodepath ]]; then
                    if [[ $_simple == "0" ]]; then
                        _nodes+=("$_matched")
                    else
                        local _arr=()
                        IFS='/' read -r -a _arr <<< "${_matched}"
                        _nodes+=("${_arr[$((${#_arr[@]}-1))]}")
                        unset _arr
                    fi
                fi
            fi
        done
    fi
    unset _item _levels
    unset _match _matched
    unset _nodepath
}

#==========
# _loadnode
#
# Load the environment variables for a particular node one part at a time.
#
# Parameters:
#   $1: name of the output array to append to.
#   $2: the node path to load.
#   $3: set to "1" to strip RUN variable of -- arguments. We do this when we have commands on command line that shall override.
#
#==========
_loadnode()
{
    local _output=$1
    shift

    local _fullnodepath=$1
    shift

    local _strip_args=${1:-0}
    shift || :

    if [[ ${_fullnodepath:0:1} != "/" ]]; then
        _error "Malformed node ($_fullnodepath), node must begin with slash."
        return 1
    fi

    local _nodeparts=()
    IFS='/' read -r -a _nodeparts <<< "${_fullnodepath}"


    local _nodepath=""
    local _i=0
    local _nrparts=${#_nodeparts[@]}
    while (( _i < _nrparts )); do
        local _node=${_nodeparts[$_i]}
        _nodepath="${_nodepath}${_node}/"
        ((_i+=1))

        local _str=
        _copy "_str" "${_nodepath}_info/desc"
        [[ -n $_str ]] && _infodesc="$_str"
        _copy "_str" "${_nodepath}_info/title"
        [[ -n $_str ]] && _infotitle="$_str"

        local _srcs=()
        _list "_srcs" "${_nodepath}_source/" "1" "1"
        if (( ${#_srcs[@]} > 0 )); then
            local _src=
            local _key=
            for _key in "${_srcs[@]}"; do
                _copy "_src" "${_nodepath}_source/${_key}"
                local _s='_source "'${_src}'"'$'\n'
                eval "$_output+=( \"\$_s\" )"
            done
        fi

        local _envarrkeys=()
        _list "_envarrkeys" "${_nodepath}_env/" "1"
        if [[ -z ${_envarrkeys-} || ((${#_envarrkeys} == 0)) ]]; then
            continue
        fi
        local _arrindex= _key=
        for _arrindex in "${_envarrkeys[@]}"; do
            local _envs=()
            _list "_envs" "${_nodepath}_env/$_arrindex/" "1" "1"
            if (( ${#_envs[@]} > 0 )); then
                for _key in "${_envs[@]}"; do
                    # Check if it's a protected variable that's only
                    # allowed to be set on the last part of the node.
                    if (( _i < _nrparts )); then
                        case "${_key}" in
                            RUN|SPACE_REDIR|RUN_ALIAS|SPACE_ARGS)
                                continue
                                ;;
                        esac
                    fi

                    if [[ $_key =~ ^[0-9]+$ ]]; then
                        _error "${_nodepath}_env/$_arrindex/$_key is malformed, array inside object?. Syntax error in YAML."
                        return 1
                    fi

                    if [[ ${_key:0:1} == "_" ]]; then
                        _error "Environment variable ${_nodepath}_env/$_arrindex/$_key is forbidden, variable cannot begin with underscore."
                        return 1
                    fi

                    local _value=

                    local _vallist=()
                    _list "_vallist" "${_nodepath}_env/${_arrindex}/${_key}/" "1" "1"
                    if [[ ((${#_vallist[@]} == 0)) ]]; then
                        # leaf
                        _copy "_value" "${_nodepath}_env/$_arrindex/$_key"
                        if [ "${_value// /}" = "" ]; then
                            # Since there is an assign further down,
                            # we make a default assign of the variable to it self.
                            _value='${'$_key'-}'
                        fi
                    else
                        # list
                        # Add to auto completion list of env variables.
                        if [[ $_BASH_COMPLETION == "4" ]]; then
                            local _item
                            while true; do
                                for _item in RUN RUN_ALIAS SPACE_ARGS SPACE_OUTER SPACE_OUTERARGS SPACE_REDIR SPACE_DEP SPACE_ENV SPACE_WRAP SPACE_WRAPARGS; do
                                    if [ "${_item}" = "${_key}" ]; then
                                        break 2
                                    fi
                                done
                                if [ "${#_envvalues[@]}" -gt 0 ]; then
                                    for _item in "${_envvalues[@]}"; do
                                        if [ "${_item}" = "${_key}" ]; then
                                            break 2
                                        fi
                                    done
                                fi
                                _envvalues+=("${_key}")
                                break
                            done
                            unset _item
                        fi

                        local _value2=
                        _copy "_value2" "${_nodepath}_env/$_arrindex/$_key/value"
                        if (( $? == 0 )); then
                            _value="${_value2}"
                        else
                            # Since there is an assign further down,
                            # we make a default assign of the variable to it self.
                            _value='${'$_key'-}'
                        fi
                        unset _value2
                        # Add to auto completion list of env variable values.
                        if [[ ($_BASH_COMPLETION == "5" || $_BASH_COMPLETION == "6") && $_envvar == $_key ]]; then
                            if [ "${_envvar}" = "SPACE_ARGS" ]; then
                                local _completion=
                                _copy "_completion" "${_nodepath}_env/$_arrindex/$_key/arguments/${_envvarindex}/completion"
                                if (( $? == 0 )); then
                                    _envcompletion="${_completion}"
                                fi
                                local _vallistkeys=() _valkey
                                _list "_vallistkeys" "${_nodepath}_env/${_arrindex}/${_key}/arguments/${_envvarindex}/values/" "1" "1"
                                if [ "${#_vallistkeys[@]}" -gt 0 ]; then
                                    for _valkey in "${_vallistkeys[@]}"; do
                                        local _val= _item=
                                        _copy "_val" "${_nodepath}_env/${_arrindex}/${_key}/arguments/${_envvarindex}/values/${_valkey}"
                                        if [ "${#_envvalues[@]}" -gt 0 ]; then
                                            for _item in "${_envvalues[@]}"; do
                                                if [ "${_item}" = "${_val}" ]; then
                                                    continue 2
                                                fi
                                            done
                                        fi
                                        _envvalues+=("${_val}")
                                        unset _val _item
                                    done
                                fi
                                unset _vallistkeys _valkey
                            else
                                local _completion=
                                _copy "_completion" "${_nodepath}_env/$_arrindex/$_key/completion"
                                if (( $? == 0 )); then
                                    _envcompletion="${_completion}"
                                fi
                                local _vallistkeys=() _valkey
                                _list "_vallistkeys" "${_nodepath}_env/${_arrindex}/${_key}/values/" "1" "1"
                                if [ "${#_vallistkeys[@]}" -gt 0 ]; then
                                    for _valkey in "${_vallistkeys[@]}"; do
                                        local _val= _item=
                                        _copy "_val" "${_nodepath}_env/${_arrindex}/${_key}/values/${_valkey}"
                                        if [ "${#_envvalues[@]}" -gt 0 ]; then
                                            for _item in "${_envvalues[@]}"; do
                                                if [ "${_item}" = "${_val}" ]; then
                                                    continue 2
                                                fi
                                            done
                                        fi
                                        _envvalues+=("${_val}")
                                        unset _val _item
                                    done
                                fi
                                unset _vallistkeys _valkey
                            fi
                        fi
                    fi
                    unset _vallist

                    # Here we must handle the special case of always appending to the SPACE_WRAP variable.
                    if [ "${_key}" == "SPACE_WRAP" ]; then
                        if [ "${_value}" != "!unset" ]; then
                            _value='${SPACE_WRAP:+$SPACE_WRAP }'"${_value}"
                        fi
                        # TODO: possibly handle and balance SPACE_WRAPARGS here also
                    fi

                    local _value2=${_value/$_SPACEGAL_EOF_TAG}
                    if [ "${_value}" != "${_value2}" ]; then
                        _error "Value cannot contain the reserved EOF tag '$_SPACEGAL_EOF_TAG'."
                        return 1
                    fi

                    local _israw=0
                    if [[ "${_value:0:1}" == \" ]]; then
                        if [[ "${_value: -1}" == " " ]]; then
                            # Cut away trailing space(s)
                            while [[ "${_value: -1}" == " " ]]; do
                                _value="${_value:0:$((${#_value}-1))}"
                            done
                        elif [[ "${_value: -2}" == " "$'\n' ]]; then
                            # Cut away trailing space(s)
                            _value="${_value:0:$((${#_value}-1))}"
                            while [[ "${_value: -1}" == " " ]]; do
                                _value="${_value:0:$((${#_value}-1))}"
                            done
                            _value="${_value}"$'\n'
                        fi
                        if [[ "${_value: -1}" == \" ]]; then
                            _value="${_value:1:$((${#_value}-2))}"
                        elif [[ "${_value: -2}" == \"$'\n' ]]; then
                            _value="${_value:1:$((${#_value}-3))}"$'\n'
                        else
                            _error "${_nodepath}_env/$_arrindex/$_key is malformed, no closing quote?. Syntax error in YAML."
                            return 1
                        fi
                        # Descape quotes
                        _value=${_value//\\\"/\"}
                    elif [[ "${_value:0:1}" == \' ]]; then
                        if [[ "${_value: -1}" == " " ]]; then
                            # Cut away trailing space(s)
                            while [[ "${_value: -1}" == " " ]]; do
                                _value="${_value:0:$((${#_value}-1))}"
                            done
                        elif [[ "${_value: -2}" == " "$'\n' ]]; then
                            # Cut away trailing space(s)
                            _value="${_value:0:$((${#_value}-1))}"
                            while [[ "${_value: -1}" == " " ]]; do
                                _value="${_value:0:$((${#_value}-1))}"
                            done
                            _value="${_value}"$'\n'
                        fi
                        if [[ "${_value: -1}" == \' ]]; then
                            _value="${_value:1:$((${#_value}-2))}"
                        elif [[ "${_value: -2}" == \'$'\n' ]]; then
                            _value="${_value:1:$((${#_value}-3))}"$'\n'
                        else
                            _error "${_nodepath}_env/$_arrindex/$_key is malformed, no closing quote?. Syntax error in YAML."
                            return 1
                        fi
                        _israw=1
                    fi

                    if [[ $_key == "RUN" && $_strip_args == "1" ]]; then
                        # If variable is RUN, we check if to trim away the arguments
                        # after "--" already here, to avoid variables not being declared.
                        # Use case is when overriding arguments from command line with the "--" switch.
                        # NOTE: There's a small probability that the first -- encountered is not
                        # a switch. We could use _split_args instead, but it feels a bit overkill.
                        if [[ $_value =~ (.+)[\ ]--[\ ] ]]; then
                            _value=${BASH_REMATCH[1]}
                        fi
                    fi

                    if [[ "$_value" == "!unset" ]]; then
                        local _s="unset ${_key}"$'\n'
                        eval "$_output+=( \"\$_s\" )"
                    elif [[ $_israw == "1" ]]; then
                        local _s="local __spacegaltmp_=
IFS= read -d '' -r __spacegaltmp_ << \"$_SPACEGAL_EOF_TAG\"
${_value}
$_SPACEGAL_EOF_TAG
local ${_key}=\${__spacegaltmp_: 0:\$(( \${#__spacegaltmp_} > 0 ? \${#__spacegaltmp_}-1 : 0 ))}
unset __spacegaltmp_
"
                        eval "$_output+=( \"\$_s\" )"
                    else
                        _filter "_value"
                        # Escape all quoted variables to respect any quotes
                        # within the variable values.
                        while :; do
                            local _left="${_value%%\"\$*}"
                            local _intermed=${_value:$((${#_left} + 1))}
                            local _middle="${_intermed%%\"*}"
                            if [ "${_left}" = "${_value}" -o "${_middle}" = "${_intermed}" ]; then
                                break
                            fi
                            _middle="${_middle}"
                            local _right=${_value:$((${#_left} + 2 + ${#_middle}))}
                            _escape "_middle"
                            _value="${_left}\$(_escape_inline \"${_middle}\")${_right}"
                        done
                        local _s="local __spacegaltmp_=
IFS= read -d '' -r __spacegaltmp_ << $_SPACEGAL_EOF_TAG
${_value}
$_SPACEGAL_EOF_TAG
local ${_key}=\${__spacegaltmp_: 0:\$(( \${#__spacegaltmp_} > 0 ? \${#__spacegaltmp_}-1 : 0 ))}
unset __spacegaltmp_
"
                        eval "$_output+=( \"\$_s\" )"
                    fi
                done
            else
                _warning "_env item ${_nodepath}_env/$_arrindex has no children, are you sure _env is treated as an array?"
            fi
        done

    done
    return 0
}

#======================
# _balance_wrap_headers
#
# Balance SPACE_WRAPARGS towards SPACE_WRAP count.
#
#======================
_balance_wrap_headers()
{
    local _A=() _B=()
    _extract_wrap_headers "${SPACE_WRAP}" "${SPACE_WRAPARGS}" "_A" "_B"

    if [ "${#_B[@]}" -gt 0 ]; then
        printf -v SPACE_WRAPARGS "%s\n" "${_B[@]}"
    else
        SPACE_WRAPARGS=
    fi
}

#======================
# _extract_wrap_headers
#
# Extract balanced arrays of SPACE_WRAP and SPACE_WRAPARGS
#
# Parameters:
#   $1: SPACE_WRAP content
#   $2: SPACE_WRAPARGS content
#   $3: name of array to add SPACE_WRAP items to (optional)
#   $4: name of array to add SPACE_WRAPARGS lines to (optional)
#
#======================
_extract_wrap_headers()
{
    local SPACE_WRAP="$1"
    shift
    local SPACE_WRAPARGS="$1"
    shift
    local __A=() __B=()

    if [ -n "${SPACE_WRAP}" ]; then
        IFS=' ' read -r -a __A <<< "${SPACE_WRAP}"

        local __wrapargs=${SPACE_WRAPARGS}
        if [ -n "${__wrapargs}" ]; then
            # We need to remove the last \n to not get an extra line.
            __wrapargs="${__wrapargs:0:$((${#__wrapargs}-1))}"
        fi
        if [ -n "${__wrapargs}" ]; then
            while IFS=$'\n' read -r _line; do
                if [ "${#__B[@]}" -eq 0 ]; then
                    __B=("$_line")
                else
                    __B=("${__B[@]}" "$_line")
                fi
            done <<< "${__wrapargs}"
        fi

        while [ "${#__A[@]}" -gt "${#__B[@]}" ]; do
            if [ "${#__B[@]}" -eq 0 ]; then
                __B=("")
            else
                __B=("${__B[@]}" "")
            fi
        done
    fi
    if [ "${#__A[@]}" -gt 0 ]; then
        eval "$1=(\"\${__A[@]}\")"
    fi
    if [ "${#__B[@]}" -gt 0 ]; then
        eval "$2=(\"\${__B[@]}\")"
    fi
}

#==========
# _execute
#
# Process a particular node path. Starts with root and evaluates every node.
# in path.
# Note: This function expects that the YAML has been loaded.
#
# Parameters:
#   $@: arguments given after '--' on command line.
#
# Expects:
#   $_nodecombo: The printable combination of 1, 2 or 3 nodes which will be run.
#   $_currentexecuting: Which combo is currently being executed in the list.
#   $_counttoexecute: MNr of node combos to execute in total.
#
# Returns:
#   Status code of the executed command
#
#==========
_execute()
{
    # Source all sh/bash files added.
    _source_added
    (( $? > 0 )) && return 1

    # Cut potential function arguments from $RUN into $_defaultargs.
    # NOTE: possibly make it possible to have RUN: "A=1 B=2 echo something"
    # in the sense that A=1 isn't treated as the command and the rest as arguments.
    local _defaultargs=
    local _RUN="${RUN}"  # Isolate this since we are changing it. As a courtesy.
    if [[ $_RUN =~ ([^ ]+)[\ ]+(.*) ]]; then
        _RUN=${BASH_REMATCH[1]}
        _defaultargs=${BASH_REMATCH[2]}
        if [[ $_RUN =~ \= ]]; then
            _error "Sorry, but the RUN (\"$_RUN $_defaultargs\") seems to be prefixed by variable assignment(s), the RUN variable assigned from YAML or -e cannot not take such a complex form. Please use a Space module instead to set RUN."
            return 1
        fi
    fi

    # Replace _RUN arguments with SPACE_ARGS, if provided.
    if [[ -n ${SPACE_ARGS-} ]]; then
        _defaultargs=${SPACE_ARGS}
    fi

    # Split string into array of arguments.
    local _args=()
    _split_args "_args" "$_defaultargs"
    (( $? > 0 )) && return 1

    # Any arguments in _RUN after -- (including) have already been cut away by now.
    # If it was not we now remove the -- token.
    local _rowindex=
    for ((_rowindex=0; _rowindex<${#_args[@]}; _rowindex+=1 )); do
        if [[ ${_args[$_rowindex]} == "--" ]]; then
            if [ "$#" -gt 0 ]; then
                _args=("${_args[@]:0:$_rowindex}")
            else
                _args=("${_args[@]:0:$_rowindex}" "${_args[@]:(($_rowindex+1))}")
            fi
            break
        fi
    done
    unset _rowindex

    # Check if the last token is "-|", then we won't
    # append any cmd line arguments. But we do however
    # remove the token.
    local _allowappend=1
    if [ "${#_args[@]}" -gt 0 ]; then
        if [[ ${_args[((${#_args[@]}-1))]} == "-|" ]]; then
            _args=("${_args[@]:0:((${#_args[@]}-1))}")
            _allowappend=0
        fi
    fi

    # Append command line arguments to _RUN.
    if [ "${_allowappend}" -eq 1 ]; then
        for _arg in "$@"; do
            _args+=("$_arg")
        done
    fi

    local _cmd_args_count=${#_args[@]}
    local _rowindex= _cmd_args_str=""
    for ((_rowindex=0; _rowindex<_cmd_args_count; _rowindex+=1 )); do
        _arg="${_args[$_rowindex]}"
        _escape "_arg" '"'
        # Always quote arg for eval statement to avoid evaluating &&, >, etc
        _cmd_args_str="${_cmd_args_str:+${_cmd_args_str} }\""$_arg$'"'
    done
    unset _rowindex _arg _args _cmd_args_count


    # Now start looking at the _RUN.
    # All these arrays will be the same size,
    # and populated by the _cmd_extract function.
    local _cmd_names=()
    local _cmd_bodies=()
    local _cmd_args=()
    local _cmd_redirs=()
    local _cmd_wraps=()
    local _cmd_wraps_args=()
    local _cmd_deps=()
    local _cmd_envs=()

    # Check if $_RUN is a function or just a snippet.
    local _tmpname="" _tmpfunc=""
    _get_fn "${_RUN}" "_tmpname" "_tmpfunc"
    if [ -z "${_tmpname}" ]; then
        # $_RUN is not a function, it's an external executable or a shell snippet
        _debug "RUN is shell snippet or executable: $_RUN"
        # We want to create an anonymous function containing $_RUN,
        # so it then could be handled in the general way, just as any other function.
        # We create this variable, and it will be available for _get_fn to read from
        # when it ecnouters the name "_anonymous".
        local _anonymous="    $_RUN \"\$@\""
        _RUN="_anonymous"
    else
        # $RUN is a function.
        _debug "RUN is function: $_RUN"
    fi
    unset _tmpname _tmpfunc

    _debug "RUN args: $_cmd_args_str"
    _debug "RUN wrap: ${SPACE_WRAP-}"

    local SPACE_FN=$_RUN                       # Inherited value from YAML.
    local SPACE_REDIR=${SPACE_REDIR-}          # Inherited value from YAML.
    local SPACE_OUTER=${SPACE_OUTER-}          # Inherited value from YAML.
    local SPACE_OUTERARGS=${SPACE_OUTERARGS-}  # Inherited value from YAML.
    local SPACE_WRAP=${SPACE_WRAP-}            # Inherited value from YAML.
    local SPACE_WRAPARGS=${SPACE_WRAPARGS-}    # Inherited value from YAML.
    local SPACE_ENV=${SPACE_ENV-}              # Inherited value from YAML.
    local SPACE_ARGS=${_cmd_args_str}
    local SPACE_DEP=${SPACE_DEP-}

    # Balance SPACE_WRAP and SPACE_WRAPARGS
    _balance_wrap_headers

    _cmd_extract
    (( $? > 0 )) && return 1
    unset _cmd_args_str

    # Iterate over all cmds and their data to build up the export
    local _numcmds=${#_cmd_names[@]}
    if (( _numcmds == 0 )); then
        _error "No RUN's to run."
        return 1
    fi

    local _export_cmd=""
    local _cmd_options="set -u  # Will not allow for unset variables being used.

"
    local _index=0
    while (( _index < _numcmds )); do
        local _fn_name=${_cmd_names[$_index]}
        local _fn_def=${_cmd_bodies[$_index]}
        local _fn_args=${_cmd_args[$_index]}
        local _fn_redir=${_cmd_redirs[$_index]}
        local _fn_wrap=${_cmd_wraps[$_index]}
        local _fn_wraps_args=${_cmd_wraps_args[$_index]}
        local _fn_env="${_cmd_envs[$_index]}"
        local _fn_deps="${_cmd_deps[$_index]}"

        local _export_vars=""
        local _fn_call="${_fn_name} ${_fn_args}"
        unset _fn_args

        local _wrapped_fn_def=""
        local _wrappers=0
        if [[ -n ${_fn_wrap} ]]; then
            local _fn_wrap_items=() _fn_wrap_items_args=()
            _extract_wrap_headers "${_fn_wrap}" "${_fn_wraps_args}" "_fn_wrap_items" "_fn_wrap_items_args"
            _wrappers=${#_fn_wrap_items[@]}

            # We evaluate all the wrappers beginning with the outermost one.
            # In this way wrappers can manipulate environment variables for
            # innermore wrappers and also for the final function.
            local _fn_wrap_item= _i= _fn_wrap_item_args=
            for ((_i=0; _i<$((_wrappers)); _i+=1 )); do
                _fn_wrap_item="${_fn_wrap_items[${_i}]}"
                _fn_wrap_item_args="${_fn_wrap_items_args[${_i}]}"

                # Inner scope used to isolate some variables 
                _spacegal_context ()
                {
                    local _cmd_names=()
                    local _cmd_bodies=()
                    local _cmd_args=()
                    local _cmd_redirs=()
                    local _cmd_wraps=()
                    local _cmd_wraps_args=()
                    local _cmd_deps=()
                    local _cmd_envs=()
                    local SPACE_FN="${_fn_wrap_item}"
                    local SPACE_REDIR=
                    local SPACE_OUTER=
                    local SPACE_OUTERARGS=
                    local SPACE_WRAP=
                    local SPACE_WRAPARGS=
                    local SPACE_DEP=
                    local SPACE_ENV=
                    # We do NOT pass the arguments
                    # into the wrapper function.
                    local SPACE_ARGS="${_fn_wrap_item_args}"

                    _cmd_extract "2"
                    (( $? > 0 )) && return 1

                    local _fn_env="${_cmd_envs[0]}"
                    local _fn_name=${_cmd_names[0]}
                    local _fn_def=${_cmd_bodies[0]}
                    local _fn_args="${_cmd_args[0]}"
                    local _fn_call="${_fn_name} ${_fn_args}"
                    local _fn_deps="${_cmd_deps[$_index]}"

                    local _export_vars=""
                    # Add to _export_vars,
                    # there might be multiple variable declarations,
                    # but that's as expected.
                    _fn_env="${_fn_env:+$_fn_env }SPACE_LOG_LEVEL=\${SPACE_LOG_LEVEL:-$SPACE_LOG_LEVEL}"
                    _fn_env="${_fn_env} SPACE_LOG_ENABLE_COLORS=\${SPACE_LOG_ENABLE_COLORS:-$SPACE_LOG_ENABLE_COLORS}"
                    _fn_env="${_fn_env} SPACE_ASSERT_EXIT=\${SPACE_ASSERT_EXIT:-$SPACE_ASSERT_EXIT}"
                    _fn_env="${_fn_env} SPACE_MUTE_EXIT=\${SPACE_MUTE_EXIT:-$SPACE_MUTE_EXIT}"
                    _cmd_export_vars "${_fn_env}" "${_fn_name}"
                    (( $? > 0 )) && return 1

                    _push "_fn_def"
                    _push "_fn_call"
                    _push "_export_vars"
                }
                _spacegal_context
                (( $? > 0 )) && return 1
            done
            unset _fn_wrap_item _fn_wrap_items _i
        fi

        # _export_vars declared way above (no not in the context isolator).
        _fn_env="${_fn_env:+$_fn_env }SPACE_LOG_LEVEL=\${SPACE_LOG_LEVEL:-$SPACE_LOG_LEVEL}"
        _fn_env="${_fn_env} SPACE_LOG_ENABLE_COLORS=\${SPACE_LOG_ENABLE_COLORS:-$SPACE_LOG_ENABLE_COLORS}"
        _fn_env="${_fn_env} SPACE_ASSERT_EXIT=\${SPACE_ASSERT_EXIT:-$SPACE_ASSERT_EXIT}"
        _fn_env="${_fn_env} SPACE_MUTE_EXIT=\${SPACE_MUTE_EXIT:-$SPACE_MUTE_EXIT}"
        _cmd_export_vars "${_fn_env}" "${_fn_name}"
        (( $? > 0 )) && return 1

        local _i=
        for ((_i=1; _i<$((_wrappers+1)); _i+=1)); do
            _wrapped_fn_def="# BEGIN WRAP ${_i}"$'\n'"RUN=\$(cat <<\"${_i}${_SPACEGAL_EOF_TAG}\""$'\n'"set -u"$'\n'$'\n'"${_wrapped_fn_def}${_export_vars}${_fn_def}${_fn_call}"$'\n\n'"${_i}${_SPACEGAL_EOF_TAG}"$'\n'")"$'\n'"# END WRAP ${_i}"$'\n\n'
            _pop "_export_vars"
            _pop "_fn_call"
            _pop "_fn_def"
        done
        unset _i
        unset _wrappers

        local _run_='eval "${RUN}"'
        if [[ -n ${_fn_redir} ]]; then
            _run_="${_run_} ${_fn_redir}"
        fi
        local _fn_def2="${_fn_def// _RUN_$'\n'/ ${_run_}$'\n'}"
        if [ "${_fn_def2}" != "${_fn_def}" ]; then
            _fn_def="${_fn_def2}"
        else
            if [[ -n ${_fn_redir} ]]; then
                _fn_call="${_fn_call} ${_fn_redir}"
            fi
        fi

        local _runinfo_head=""
        # Run info
        if [ "${_counttoexecute}" -gt 1 ]; then
            _runinfo_head='# Space will print the node name to be run.
if [ "${SPACE_LOG_LEVEL}" -ge 2 ]; then
    [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_FG_WHITE}'" >&2
    printf "%s\n" "[RUN]   '"(${_currentexecuting}/${_counttoexecute}): ${_nodecombo}"'" >&2
    [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_DEFAULT}'" >&2
fi

'
        fi
        local _runinfo_tail=""
        # Exit info
        local _runinfo_fail=""
        if [ "${_counttoexecute}" -gt 1 ]; then
            _runinfo_fail='printf "%s\n" "[ERROR] '"(${_currentexecuting}/${_counttoexecute})"': Script exited with status $_status for node '${_nodecombo}'" >&2'
            _runinfo_success='printf "%s\n" "[OK]    '"(${_currentexecuting}/${_counttoexecute})"': Script exited with success (status $_status) for node '${_nodecombo}'" >&2'
        else
            _runinfo_fail='printf "%s\n" "[ERROR] Script exited with status $_status for node '${_nodecombo}'" >&2'
            _runinfo_success='printf "%s\n" "[OK]    Script exited with success (status $_status) for node '${_nodecombo}'" >&2'
        fi

        _runinfo_tail='# Space will print exit status.
_status=$?
if [ "${_status}" -ne "${SPACE_ASSERT_EXIT}" ]; then
    if [ "${SPACE_LOG_LEVEL}" -ge 1 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_FG_RED}'" >&2
        '$_runinfo_fail'
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_DEFAULT}'" >&2
    fi
    if [ "${SPACE_MUTE_EXIT}" != 1 ]; then
        exit $((SPACE_ASSERT_EXIT = 0 ? _status : 1))
    fi
else
    if [ "${SPACE_LOG_LEVEL}" -ge 2 ]; then
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_FG_GREEN}'" >&2
        '$_runinfo_success'
        [ "${SPACE_LOG_ENABLE_COLORS:-1}" = 1 ] && printf "'${_COLOR_DEFAULT}'" >&2
    fi
fi
: # Reset status
'

        _export_cmd="${_cmd_options}${_export_cmd}${_wrapped_fn_def}${_export_vars}${_fn_def}${_runinfo_head}${_fn_call}"$'\n'$'\n'"${_runinfo_tail}"
        (( _index += 1 ))
    done
    unset _index


    if [[ ${_dry-1} == "1" ]]; then
        if [[ -t 1 ]]; then
            _info "##################################################"
            _info "#######       DRY RUN - NOT EXECUTING      #######"
            _info "####### Redirect STDOUT to save as script. #######"
            _info "##################################################"
        fi

        local _sh="/bin/env sh"
        if [ "${_FORCE_BASH}" = "1" ]; then
            _sh="/bin/env bash"
        fi

        local _exportinfo="#!${_sh}
# Script exported by:
#   ____  ____   __    ___  ____  ___   __   __
#  / ___)(  _ \ / _\  / __)(  __)/ __) / _\ (  )
#  \___ \ ) __//    \( (__  ) _)( (_ \/    \/ (_/\\
#  (____/(__)  \_/\_/ \___)(____)\___/\_/\_/\____/
#                                         space.sh"
        printf "%s\n" "$_exportinfo"

        local _helpinfo="# Node: $_nodecombo"$'\n'
        [[ $_infotitle ]] && _helpinfo="${_helpinfo}# $_infotitle"$'\n'
        [[ $_infodesc ]] && _helpinfo="${_helpinfo}# "${_infodesc//$'\n'/$'\n'\# }$'\n'
        [[ -n $_helpinfo ]] && printf "%s\n" "$_helpinfo"

        printf "%s\n" "$_export_cmd"
        return 0
    else
        # We run the final result in a separate shell, to isolate the
        # environment to not have leaky environment.
        local _sh="env sh"
        if [ "${_FORCE_BASH}" = "1" ]; then
            _sh="env bash"
        fi
        ${_sh} -c "$_export_cmd"
    fi
}

#==========
# YIELD
#
# We export this and use it from build time functions to
# "yield" out a variable and it's value from the restricted sub shell.
# It does this by writing to FD 3, which should have been opened prior.
#
# Note that when Space is parsing back the variables the variable must already
# have been declared in YAML or using -e.
#
# Variables are not allowed to beging with an underscore, since these could be within
# Space's "protected" internal variable space.
#
# Parameters:
#   $1: variable name which will get yielded out.
#   $2: unset flag, set to 1 to have the variable unset.
#
# Expects:
#   FD 3: to be open and writable.
#
# Return:
#   1 if variable begins with underscore.
#
#==========
YIELD()
{
    if [ "${1:0:1}" = "_" ]; then
        printf "%s\n" "[ERROR] Yielded variable names cannot start with underscore." >&2
        return 1
    fi

    if [ "${2-}" = "unset" ]; then
        printf "%s unset\n" "${1}" >&3
    else
        if [ "${!1+set}" != "set" ]; then
            printf "%s\n" "[ERROR] Yielded variable ${1} is undeclared in build function." >&2
            return 1
        fi
        local _lines="${!1}"
        _lines="${_lines//[!$'\n']}"
        _lines="${#_lines}"
        (( _lines += 1 ))
        printf "%s %s\n" "${1}" "${_lines}" >&3
        printf "%s\n" "${!1}" >&3
    fi
}

# _filter
#========
#
# Filter out command substitution from input
#
# Parameters:
#   $1: input
#   $2: output (optional)
#
# Returns:
#   In case output argument is missing, results are written to input i.e. in-place substitution
#
#========
_filter()
{
    local __input=$1
    local __output=${2:-$__input}

    # Work on internal data
    local __subst_data=
    eval "__subst_data=\$$__input"

    # Replace all tokens with predetermined value
    local __subst_tokens=
    local __subst_value=
    local __token=

    # Arithmetic opening
    __subst_tokens=("\\$\(\(")
    __subst_value="\(\("
    __token=
    for __token in "${__subst_tokens[@]}" ; do
        eval "__subst_data=\${__subst_data//$__token/$__subst_value};"
    done

    # Right side parenthesis
    __subst_tokens=("\\\)" "\)\\\\\\\`" "\)\\\`")
    __subst_value="\\)"
    __token=
    for __token in "${__subst_tokens[@]}" ; do
        eval "__subst_data=\${__subst_data//$__token/$__subst_value};"
    done

    # Left side parenthesis
    __subst_tokens=("\\\\$\\\(" "\\\\$\(" "\\$\(" "\(" "\\\\\\\`\(" "\\\`\(")
    __subst_value="\\("
    __token=
    for __token in "${__subst_tokens[@]}" ; do
        eval "__subst_data=\${__subst_data//$__token/$__subst_value};"
    done

    # Back-tick
    __subst_tokens=("\\\`")
    __subst_value="\\'"
    __token=
    for __token in "${__subst_tokens[@]}" ; do
        eval "__subst_data=\${__subst_data//$__token/$__subst_value};"
    done

    #
    # Copy internal data over to output
    eval "$__output=\"\${__subst_data}\""
}

#============
# _cmd_extract
#
# Helper function to analyze and extract RUN function and headers.
# The following Space header variables could or are expected to have been set with default values:
# - SPACE_FN (required)
# - SPACE_ENV
# - SPACE_REDIR
# - SPACE_OUTER
# - SPACE_OUTERARGS
# - SPACE_ARGS
# - SPACE_WRAP
# - SPACE_WRAPARGS
#
# Parameters:
#   $1: Space header type, 0=normal,  2=wrap. Default is 0.
#
# Expects:
#   _cmd_names=()
#   _cmd_bodies=()
#   _cmd_args=()
#   _cmd_redirs=()
#   _cmd_wraps=()
#   _cmd_wraps_args=()
#   _cmd_deps=()
#   _cmd_envs=()
#
#============
_cmd_extract()
{
    local _headertype="${1:-0}"
    shift || :

    trap '_error "Problem when evaluating SPACE_ header variables or function body for: ${_fn_name}. Look for unbound variable or other syntax error."; trap - EXIT; return 1; ' EXIT
    local _space_cmds=("${SPACE_FN}")
    local _space_cmd_index=0
    while :; do
        # TODO: When we implement FORK, we have to consider
        # SPACE_ARGS, etc also.
        (( _space_cmd_index >= ${#_space_cmds[@]} )) && break
        SPACE_FN=${_space_cmds[$_space_cmd_index]}
        (( _space_cmd_index += 1))

        local _counter=0
        while :; do
            # Loop until we reach the "actual" function,
            # which is a function that does not chain to
            # another function using SPACE_FN="funcname".
            (( _counter += 1 ))
            if (( _counter > 100 )); then
                _error "Aborting! Looks like your function chaining using SPACE_FN is looping. Function: ${SPACE_FN}."
                trap - EXIT
                return 1
            fi

            local _fn_name= _fn_body=
            _get_fn "$SPACE_FN" "_fn_name" "_fn_body"
            if (( $? > 0 )); then
                _error "Function $SPACE_FN is not declared or syntax error."
                trap - EXIT
                return 1
            fi

            #local _args=()
            #_split_args "_args" "${SPACE_ARGS}"
            #(( $? > 0 )) && { trap - EXIT; return 1; }
            #unset _args

            # Declare these variables here since they are local only.
            local SPACE_BUILDDEP= SPACE_BUILDENV= SPACE_BUILDARGS=

            # Separate the SPACE_ variables header and the function body.
            local _space_cmd=$SPACE_FN
            local _fnlines=()
            _cmd_extract_space_header "${_fn_body}" "${_fn_name}" "${_headertype}" "${SPACE_ARGS}"
            (( $? > 0 )) && { trap - EXIT; return 1; }

            # Check if this function is a build time wrapper for another function,
            # if so we want to evaluate it now to let it do its variable manipulation.
            #if [[ -n ${SPACE_CMDFORK} ]]; then
                # TODO: fork many commands from this command, by adding
                # to _space_cmds.
                # Not implemented yet.
            if [[ ${SPACE_FN} != ${_space_cmd} ]]; then
                # TODO: we would want to hinder build time function from importing "protected" underscored variables.
                local _fns=
                # Not using "set -e" anymore, it got too shakey (see http://mywiki.wooledge.org/BashFAQ/105).
                # printf -v _fns "set -e;\n%s\nset +e;\n" "${_fnlines[@]-:}"
                printf -v _fns "%s\n" "${_fnlines[@]-:}"
                if [ "${_fns//\ $'\n'}" = "" ]; then
                    # Empty body
                    continue
                fi
                local _fn_env="SPACE_LOG_LEVEL SPACE_LOG_ENABLE_COLORS"
                local _fn_def=""
                _cmd_add_fn_dep "${SPACE_BUILDDEP:+${SPACE_BUILDDEP} }YIELD" "${_space_cmd}"
                (( $? > 0 )) && { trap - EXIT; return 1; }

                if [ -n "${SPACE_BUILDENV-}" ]; then
                    _fn_env="${_fn_env:+${_fn_env} }${SPACE_BUILDENV}"
                fi
                local _export_vars=""
                if [ -n "${_fn_env}" ]; then
                    _debug "Export vars for build time function ${_fn_name}: ${_fn_env}."
                    _cmd_export_vars "${_fn_env}" "${_fn_name}"
                    (( $? > 0 )) && { trap - EXIT; return 1; }
                fi
                _fns="set -u"$'\n'"${_fn_def}_wrapper() {"$'\n'"${_fns}}"$'\n'"${_export_vars}"$'\n'"_wrapper ${SPACE_BUILDARGS}"$'\n'
                # Null these.
                SPACE_BUILDDEP=
                SPACE_BUILDENV=
                SPACE_BUILDARGS=

                # EXTERNAL: mktemp, bash, rm, rmdir
                local _tmpdir=$(mktemp -d 2>/dev/null || mktemp -d -t 'sometmpdir')
                (( $? > 0 )) && { _error "Could not mktemp dir for SPACE_FN isolation."; return 1; }
                local _tmpfile="${_tmpdir}/output"
                local _restrictedcode=$_fns
                exec 3<> ${_tmpfile}  # Open FD 3 for YIELD
                ( cd $_tmpdir; PATH= ${_BASHBIN} -rc "${_restrictedcode}" )
                if (( $? > 0 )); then
                    _error "Error returned from build time function: ${_space_cmd}."
                    trap - EXIT
                    rm ${_tmpfile}
                    rmdir $_tmpdir
                    return 1
                fi
                unset _restrictedcode
                local _line=
                local _varname=
                local _linecount=0
                local _value=
                while IFS= read -r _line; do
                    if [ -z "${_varname}" ]; then
                        if [[ $_line =~ ^([a-zA-Z0-9][a-zA-Z0-9_]*)\ (.+)$ ]]; then
                            _varname=${BASH_REMATCH[1]}
                            _linecount=${BASH_REMATCH[2]}
                            _value=""
                            eval "[ \"\${${_varname}+isset}\" = \"isset\" ]"
                            if [ "$?" -gt 0 ] && [ "${_linecount}" != "unset" ]; then
                                # Variable is unset
                                 _error "Yielded variable '$_varname' in function $_fn_name must be declared prior to build function."
                                 trap - EXIT
                                 rm ${_tmpfile}
                                 rmdir $_tmpdir
                                 return 1
                            fi
                            if [ "${_linecount}" = 0 ]; then
                                eval "${_varname}="
                            elif [ "${_linecount}" = "unset" ]; then
                                eval "unset ${_varname}"
                            fi
                        else
                            _error "Could not translate yielded variables out from ${_fn_name}."
                            trap - EXIT
                            rm ${_tmpfile}
                            rmdir $_tmpdir
                            return 1
                        fi
                    else
                        (( _linecount -= 1 ))
                        _value="${_value}${_line}"
                        if [ "${_linecount}" -gt 0 ]; then
                            _value="${_value}"$'\n'
                        else
                            eval "${_varname}=\"\${_value}\""
                            _varname=
                            _value=
                        fi
                    fi
                done < ${_tmpfile}
                unset _line
                rm ${_tmpfile}
                unset _tmpfile
                rmdir $_tmpdir
                unset _tmpdir
                unset _fns
            else
                # This function is the actual function.
                local _fn_def=
                local _fn_env="${SPACE_ENV}"
                printf -v _fn_def "%s\n" "${_fnlines[@]-:}"
                _fn_def="${_fn_name}()"$'\n'"{"$'\n'"${_fn_def}""}"$'\n\n'
                _cmd_add_fn_dep "${SPACE_DEP}" "${_fn_name}"
                if (( $? > 0 )); then trap - EXIT; return 1; fi

                _balance_wrap_headers
                _add_cmd "${_fn_name}" "${_fn_def}" "${SPACE_ARGS}" "${SPACE_DEP}" "${_fn_env}" "${SPACE_REDIR}" "${SPACE_WRAP}" "${SPACE_WRAPARGS}" "${SPACE_OUTER}" "${SPACE_OUTERARGS}"
                unset _fn_def
                break
            fi
        done
    done
    trap - EXIT
}

#==========
# _cmd_extract_space_header
#
# Helper function to extract space headers from the function body.
#
# Expects:
#   _fnlines=()
#   SPACE_xyz
#
#==========
_cmd_extract_space_header ()
{
    local _fn_body="$1"
    shift

    local _fn_name="$1"
    shift

    local _headertype="${1-}"
    shift || :

    local _given_args="${1-}"
    shift || :

    # NOTE: This is a special case for now.
    # We do not want this line in the PRINT function.
    # But we do want it in all the other functions exported, for PRINT to use.
    [[ $_fn_name != "PRINT" ]] && _fnlines+=("    local _SPACE_NAME=\"${_fn_name}\"")

    local _spacelines=()
    local _line=
    local _isheader="1"
    local _addedspacewrap=0
    local _hasfn=0
    local _hasbuildenv=0
    local _hasbuilddep=0
    local _hasbuildargs=0
    while IFS= read -r _line; do
        # Disconsider comments when evaluating header line
        if [[ $_isheader == "1" ]]; then
            if [[ $_line =~ ^[\ ]*(SPACE_[^=]+)=(.+) ]]; then
                local _spacevar=${BASH_REMATCH[1]}
                # We check so it's properly wrapped in double quotes,
                # we reserve single quote wrapping for later.
                # we'll just do a lazy check, checking left side.
                local _spacevalue=${BASH_REMATCH[2]}
                if [ "${_spacevalue:0:1}" != '"' ]; then
                    _error "SPACE_ headers must always define their values inside double quotes as: $_spacevar=\"values\". In function ${_fn_name}."
                    return 1
                fi

                if [[ ${_spacevar} == "SPACE_SIGNATURE" ]]; then
                    if [[ -n ${_given_args-} ]]; then
                        # Check so that the signature matches.
                        local _signature=${BASH_REMATCH[2]}
                        local _signature2="${_signature:1:$((${#_signature}-2))}"
                        _signature2="${_signature2%%\[*\]}"
                        local _arr=()
                        _split_args "_arr" "${_signature2}"
                        (( $? > 0 )) && { return 1; }
                        local _sigcount=${#_arr[@]}
                        local _arr2=()
                        _split_args "_arr2" "${_given_args}"
                        (( $? > 0 )) && { return 1; }
                        local _cmd_args_count=${#_arr2[@]}
                        local _c=0 _s=
                        for _s in ${_signature2}; do
                            if [ "$_c" -ge "${#_arr2[@]}" ]; then
                                _error "Missing $((_sigcount-_cmd_args_count)) argument(s). Function ${_fn_name} has the signature: ${_signature}, but only these (${_cmd_args_count}) arguments where provided: ${_given_args}"
                                return 1
                            fi
                            local _minlength=0 _maxlength=
                            if [[ $_s =~ ^[^:]+:([^:]+):?(.*) ]]; then
                                _minlength=${BASH_REMATCH[1]}
                                _maxlength=${BASH_REMATCH[2]}
                            fi
                            local _arg=${_arr2[$_c]}
                            local _l=${#_arg}
                            if (( _l < _minlength )); then
                                _error "Argument $((_c+1)) is too short for function ${_fn_name}: \"$_arg\" is out of bounds of $_s."
                                return 1
                            fi
                            if [ -n "$_maxlength" ] && (( _l > _maxlength )); then
                                _error "Argument $((_c+1)) is too long for function ${_fn_name}: \"$_arg\" is out of bounds of $_s."
                                return 1
                            fi
                            ((_c+=1))
                        done
                    fi
                elif [ "${_headertype}" = "2" ]; then
                    # Wrap command
                    if [[ ${_spacevar} == "SPACE_ENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ENV=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_DEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_DEP=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_ARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ARGS=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_FN" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_FN=${BASH_REMATCH[2]}")
                        _hasfn=1
                    elif [[ ${_spacevar} == "SPACE_BUILDENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDENV=${BASH_REMATCH[2]}")
                        _hasbuildenv=1
                    elif [[ ${_spacevar} == "SPACE_BUILDDEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDDEP=${BASH_REMATCH[2]}")
                        _hasbuilddep=1
                    elif [[ ${_spacevar} == "SPACE_BUILDARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDARGS=${BASH_REMATCH[2]}")
                        _hasbuildargs=1
                    else
                        _error "Unknown SPACE HEADER variable: ${_spacevar}, in WRAP function: ${_fn_name}."
                        return 1
                    fi
                elif [ "${_headertype}" = "3" ]; then
                    # Dep command
                    if [[ ${_spacevar} == "SPACE_ENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ENV=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_DEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_DEP=${BASH_REMATCH[2]}")
                    else
                        _error "Unknown SPACE HEADER variable: ${_spacevar}, in DEP function: ${_fn_name}."
                        return 1
                    fi
                else
                    if [[ ${_spacevar} == "SPACE_ENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ENV=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_DEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_DEP=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_REDIR" ]]; then
                        # Do not overwrite.
                        if [[ -z ${SPACE_REDIR} ]]; then
                            _spacelines+=("SPACE_REDIR=${BASH_REMATCH[2]}")
                        fi
                    elif [[ ${_spacevar} == "SPACE_OUTER" ]]; then
                        # Do not overwrite.
                        if [[ -z ${SPACE_OUTER} ]]; then
                            _spacelines+=("SPACE_OUTER=${BASH_REMATCH[2]}")
                        fi
                    elif [[ ${_spacevar} == "SPACE_OUTERARGS" ]]; then
                        # Do not overwrite.
                        if [[ -z ${SPACE_OUTERARGS} ]]; then
                            _spacelines+=("SPACE_OUTERARGS=${BASH_REMATCH[2]}")
                        fi
                    elif [[ ${_spacevar} == "SPACE_ARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_ARGS=${BASH_REMATCH[2]}")
                    elif [[ ${_spacevar} == "SPACE_WRAP" ]]; then
                        # Appended to.
                        local _s="${BASH_REMATCH[2]}"
                        if [ "${_s: -1}" = ";" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        if [ "${_s:0:1}" = "\"" ] || [ "${_s:0:1}" = "'" ]; then
                            _s="${_s:1}"
                        fi
                        if [ "${_s: -1}" = "\"" ] || [ "${_s: -1}" = "'" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        _spacelines+=("SPACE_WRAP=\"${SPACE_WRAP:+${SPACE_WRAP} }${_s}"\")
                        unset _s
                        _addedspacewrap=1
                    elif [[ ${_spacevar} == "SPACE_WRAPARGS" ]]; then
                        # Appended to.
                        local _s="${BASH_REMATCH[2]}"
                        if [ "${_s: -1}" = ";" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        if [ "${_s:0:1}" = "\"" ] || [ "${_s:0:1}" = "'" ]; then
                            _s="${_s:1}"
                        fi
                        if [ "${_s: -1}" = "\"" ] || [ "${_s: -1}" = "'" ]; then
                            _s="${_s:0:$((${#_s}-1))}"
                        fi
                        _escape "_s" '"'
                        _spacelines+=("SPACE_WRAPARGS=\"\${SPACE_WRAPARGS}${_s}\"\$'\n'")
                        unset _s
                    elif [[ ${_spacevar} == "SPACE_FN" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_FN=${BASH_REMATCH[2]}")
                        _hasfn=1
                    elif [[ ${_spacevar} == "SPACE_BUILDENV" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDENV=${BASH_REMATCH[2]}")
                        _hasbuildenv=1
                    elif [[ ${_spacevar} == "SPACE_BUILDDEP" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDDEP=${BASH_REMATCH[2]}")
                        _hasbuilddep=1
                    elif [[ ${_spacevar} == "SPACE_BUILDARGS" ]]; then
                        # Always overwritten.
                        _spacelines+=("SPACE_BUILDARGS=${BASH_REMATCH[2]}")
                        _hasbuildargs=1
                    else
                        _error "Unknown SPACE HEADER variable: ${_spacevar}, in function: ${_fn_name}."
                        return 1
                    fi
                fi
            elif [[ $_line =~ ^[\ ]*#.* ]]; then
                continue
            else
                # Stop extracting header if a row is not prefixed by "SPACE_" nor "#".
                _isheader="0"
            fi
        fi
        if [[ $_isheader == "0" ]]; then
            _fnlines+=("$_line")
        fi
    done <<< "${_fn_body}"
    unset _line _isheader

    # Check some constraints.
    if [ "${_hasfn}" = 0 ]; then
        if [ "${_hasbuildenv}" = 1 ]; then
            _error "SPACE_BUILDENV is a build time only variable cannot be declared without also declaring SPACE_FN."
            return 1
        fi
        if [ "${_hasbuilddep}" = 1 ]; then
            _error "SPACE_BUILDDEP is a build time only variable cannot be declared without also declaring SPACE_FN."
            return 1
        fi
        if [ "${_hasbuildargs}" = 1 ]; then
            _error "SPACE_BUILDARGS is a build time only variable cannot be declared without also declaring SPACE_FN."
            return 1
        fi
    fi

    # If we have any SPACE_ variables we evaluate them
    # together with the function arguments.
    if (( ${#_spacelines[@]} > 0 )); then
        trap '_error "Could not evaluate SPACE_ headers for ${_fn_name}."; trap - EXIT; return 1;' EXIT
        _escape "_given_args" '$'
        # We'll evaluate one row at a time, to let definitions "sink in" before next row is evaluated.
        local _row=
        local _fns=
        for _row in "${_spacelines[@]}"; do
            _fns="_set_args() {"$'\n'"${_row}"$'\n'"}"$'\n'"_set_args ${_given_args}"$'\n'
            _filter "_fns"
            eval "$_fns"
            if (( $? > 0 )); then
                _error "Could not evaluate function header of ${_fn_name} to set SPACE_ variables."
                trap - EXIT
                return 1
            fi
        done
        unset _fns
        unset _row
        trap - EXIT
    fi
    unset _spacelines
}

#==========
# _eval_var
#
# Evaluates the variable pointed to by $1 and
# then populates the variable named by $1.
#
# Parameters:
#   $1: Variable name.
#
# Expects:
#   $1: Pointed to variable to exist.
#
#==========
_eval_var()
{
    local _varname="${1}"
    shift

    trap '_error "Variable $_varname2 is undefined but referenced."; trap - EXIT; return 1;' EXIT
    if [[ $_varname =~ ^([a-zA-Z0-9_])+$ ]]; then
        local _varname2=${!_varname}
        eval "${_varname}=\${$_varname2}"
        trap - EXIT
        return
    fi
    trap - EXIT
    return 1
}

#==========
# _cmd_export_vars
#
# Expects:
#   _export_vars
#
#==========
_cmd_export_vars()
{
    local _fn_env="${1}"
    shift

    local _fn_name="${1}"
    shift

    trap '_error "Problem when evaluating SPACE_FN ENV header variables associated with ${_fn_name}. Look for unbound variable or syntax error in named function or in its chain of functions."; trap - EXIT; return 1; ' EXIT

    if [[ -n ${_fn_env} ]]; then
        local _arr=()
        local _fn_env_item= _k1= _v=
        _split_args "_arr" "${_fn_env}"
        (( $? > 0 )) && { trap - EXIT; return 1; }
        for _fn_env_item in "${_arr[@]}"; do
            _k1=${_fn_env_item%%=*}
            if [[ ${_k1} == ${_fn_env_item} ]]; then
                # Let's evaluate the variable.
                _v="${_k1}"
                _eval_var "_v"
                if [ "$?" != "0" ]; then
                    # Exit will trigger the trap.
                    exit
                fi
            else
                _v=${_fn_env_item#*=}
            fi
            _escape "_v" '"'
            _export_vars="${_export_vars}${_k1}=\""$_v"\""$'\n'
        done
        unset _fn_env_item _k1 _v
    fi

    trap - EXIT
}

#============
# _cmd_add_fn_dep
#
# Helper function
#
# Expects:
#   _fn_def
#   _fn_env
#
#============
_cmd_add_fn_dep()
{
    local _fn_dep="${1-}"
    shift || :

    local _fn_name="${1-}"
    shift || :

    [[ -z ${_fn_dep} ]] && return 0

    local _fn_dep_name= _fn_dep_body= _fn_dep_item= _i=0 _arr=()
    IFS=' ' read -r -a _arr <<< "${_fn_dep}"
    while (( _i < ${#_arr[@]} )); do
        _fn_dep_item=${_arr[$_i]}
        (( _i += 1 ))
        # Check so that this function does not already exists in $_fn_def
        # to avoid multiple occurrences.
        if [[ ${_fn_def} =~ (.?)${_fn_dep_item}[\ ]*\(\)$'\n'\{[\ ]*$'\n' ]]; then
            if [ "${#BASH_REMATCH[1]}" -eq 0 -o "${BASH_REMATCH[1]}" = $'\n' ]; then
                continue
            fi
        fi
        _get_fn "${_fn_dep_item}" "_fn_dep_name" "_fn_dep_body"
        if (( $? > 0 )); then
            _error "Dependency function not found or syntax error: ${_fn_dep_item}. Referred from function: ${_fn_name}."
            return 1
        fi
        local _fnlines=() _line=
        # We isolate the space header variables:
        local SPACE_DEP= SPACE_ENV= SPACE_REDIR=
        local SPACE_WRAP= SPACE_FN= SPACE_OUTER=
        local SPACE_ARGS= SPACE_OUTERARGS= SPACE_WRAPARGS=
        _cmd_extract_space_header "${_fn_dep_body}" "${_fn_dep_name}" "3"
        (( $? > 0 )) && return 1
        local _fns=
        printf -v _fns "%s\n" "${_fnlines[@]-:}"
        _fn_def="${_fn_def}${_fn_dep_name}()"$'\n'"{"$'\n'"${_fns}}"$'\n\n'
        unset _fns
        if [[ -n ${SPACE_ENV} ]]; then
            _fn_env="${_fn_env:+${_fn_env} }${SPACE_ENV}"
        fi

        # Now check for further dependencies.
        if [[ -n ${SPACE_DEP} ]]; then
            local _arr2=() _item2=
            IFS=' ' read -r -a _arr2 <<< "${SPACE_DEP}"
            for _item2 in "${_arr2[@]}"; do
                if [[ ! ${_fn_dep} =~ (^|[\ ])${_item2}($|[\ ]) ]]; then
                    _arr+=("${_item2}")
                    _fn_dep="${_fn_dep} ${_item2}"
                fi
            done
            unset _arr2 _item2
        fi
        unset _fnlines _line SPACE_DEP
    done
    unset _fn_dep_name _fn_dep_body _fn_dep_item _i _arr
}

#=========
# _add_cmd
#
# Add a command to be exported to the list, together with all its data.
#
#=========
_add_cmd()
{
    _cmd_names+=("${1-}")
    shift || :

    _cmd_bodies+=("${1-}")
    shift || :

    _cmd_args+=("${1-}")
    shift || :

    _cmd_deps+=("${1-}")
    shift || :

    _cmd_envs+=("${1-}")
    shift || :

    _cmd_redirs+=("${1-}")
    shift || :

    local _cmd_wrap="${1-}"
    shift || :

    local _cmd_wraps_arg="${1-}"
    shift || :

    local _cmd_outer="${1-}"
    shift || :

    local _cmd_outerargs="${1-}"
    shift || :

    if [ -n "${_cmd_outer}" ]; then
        _cmd_wrap="${_cmd_outer}${_cmd_wrap:+ ${_cmd_wrap}}"
        _cmd_wraps_arg="${_cmd_outerargs}"$'\n'"${_cmd_wraps_arg}"
    fi

    _cmd_wraps_args+=("${_cmd_wraps_arg}")
    _cmd_wraps+=("${_cmd_wrap}")
}

#============
# _escape_inline
#
# Used when evaluating environment variables.
#
#============
_escape_inline()
{
    eval "local var=\"$*\""
    shift

    _escape "var" '"'
    echo "\"${var}\""
}

#==========
# _escape
#
# Escape a variable which name is given by $1.
# Double quotes are escaped one up.
# Dollar signs are escaped one up.
# Paranthesis are escaped one up.
#
#============
_escape()
{
    local __s=$1
    shift

    local __c=${1:-\"\$\()}
    shift || :

    if [ "${__s}" == "__s" ]; then
        _error "Variable name collision in _escape, choose other variable name than ${__s}."
        return 1
    fi

    local __s2=${!__s}

    if [[ $__c =~ \" ]]; then
        __s2=${__s2//\"/\\\"}
        __s2=${__s2//\\\\\"/\\\\\\\"} # Adjust the even ones...
    fi

    if [[ $__c =~ \$ ]]; then
        __s2=${__s2//\$/\\\$}
        __s2=${__s2//\\\\\$/\\\\\\\$} # Adjust the even ones...
    fi

    if [[ $__c =~ \| ]]; then
        __s2=${__s2//\|/\\\|}
        __s2=${__s2//\\\\\|/\\\\\\\|} # Adjust the even ones...
    fi

    if [[ $__c =~ \& ]]; then
        __s2=${__s2//\&/\\\&}
        __s2=${__s2//\\\\\&/\\\\\\\&} # Adjust the even ones...
    fi

    if [[ $__c =~ \> ]]; then
        __s2=${__s2//\>/\\\>}
        __s2=${__s2//\\\\\>/\\\\\\\>} # Adjust the even ones...
    fi

    if [[ $__c =~ \< ]]; then
        __s2=${__s2//\</\\\<}
        __s2=${__s2//\\\\\</\\\\\\\<} # Adjust the even ones...
    fi

    if [[ $__c =~ \( ]]; then
        __s2=${__s2//\(/\\\(}
        __s2=${__s2//\\\\\(/\\\\\\\(} # Adjust the even ones...
    fi

    if [[ $__c =~ \) ]]; then
        __s2=${__s2//\)/\\\)}
        __s2=${__s2//\\\\\)/\\\\\\\)} # Adjust the even ones...
    fi

    eval "$__s=\$__s2"
    return 0
}

#===========
# _to_lower
#
# Lower case a string and echo it back.
# Probably slow, but works in Bash 3.
#
#===========
_to_lower()
{
    local _s=$1
    shift

    local _trans="abcdefghijklmnopqrstuvwxyz"

    local _s2=""
    local _i=
    local _c=
    local _ascii=
    for (( _i=0; _i<${#_s}; _i++ )); do
        _c=${_s:$_i:1}
        printf -v _ascii "%d" "'$_c"
        if (( _ascii >= 65 && _ascii <= 90 )); then
            ((_ascii-=65))
            _c=${_trans:$_ascii:1}
        fi
        _s2="${_s2}${_c}"
    done
    echo "${_s2}"
}

#============
# _split_args
#
# Takes one string of arguments and splits them
# respecting quotes.
#
# Note:
#   This is not bullet proof when it comes to special characters that are quoted.
#
# Parameters:
#   $1 the variable name of the array to add extracted arguments to.
#   $2 The string to parse.
#
# Expects:
#   $1: to have the variable it points to have been
#       initialized as an empty array by the caller.
#
# Returns:
#   non-zero on error
#
#============
_split_args()
{
    function _split_args_inner()
    {
        local _item=
        for _item; do
            # Unescape escaped paranthesis.
            _item=${_item//\\\(/\(}
            _item=${_item//\\\)/\)}
            # Unescape escaped ampersands, pipes and redirections that might have been inside quotes.
            _item=${_item//\\\&/\&}
            _item=${_item//\\\|/\|}
            _item=${_item//\\\>/\>}
            _item=${_item//\\\</\<}
            eval "$_output+=(\"\$_item\")"
        done
    }
    local _output=$1
    shift
    local _s="${1-}"
    shift || :
    trap '_error "Syntax error (unmatched quote?) in parsing arguments: $_s";' ERR
    if [ "${_s//$'\n'}" != "${_s}" ]; then
        _error "Can't split arguments containing newline: ${_s}."
        trap - EXIT
        return 1
    fi
    _escape "_s" '$()&|<>'
    eval "_split_args_inner ${_s}"
    (( $? > 0 )) && { trap - ERR; return 1; }
    trap - ERR
}

#==========
# _get_fn
#
# Helper function to extract the body and name of a given function
#
# Parameters:
#   $1 Name of the function.
#   $2 Name of the variable to write to the fn name to.
#   $3 Name of the variable to write to the fn body to.
#
# Returns:
#   1 on error
#
#==========
_get_fn()
{
    local _cmdname=$1
    shift

    local _varname=$1
    shift

    local _varbody=$1
    shift

    # A special case for the dynamically defined function _anonymous.
    if [ "${_cmdname}" = "_anonymous" ]; then
        eval "${_varbody}=\${_anonymous}"
        eval "${_varname}=\${_cmdname}"
        return 0
    fi

    # Look through all loaded source files to find the declaration, in reverse order.
    local _i=$((${#_SOURCE_FILES_TOTAL[@]}-1))
    while [ "${_i}" -gt -1 ]; do
        _file="${_SOURCE_FILES_TOTAL[$_i]}"
        # EXTERNAL: cat
        local _content="$(cat ${_file})"$'\n'  # We add a '\n' so that pattern matching below works properly.
        if [[ ${_content} =~ (^|$'\n')${_cmdname}[\ ]*\(\)$'\n'\{[\ ]*$'\n'(.*$'\n') ]]; then
            if [ "${#BASH_REMATCH[1]}" -eq 0 -o "${BASH_REMATCH[1]}" = $'\n' ]; then
                _content="${BASH_REMATCH[2]}"
                _content="${_content%%$'\n'\}$'\n'*}"
                eval "${_varbody}=\${_content}"
                eval "${_varname}=\${_cmdname}"
                return 0
            fi
        fi
        _i=$(( _i-1 ))
    done
    return 1
}

#===============
# _apply_cmd_env
#
# Apply the cmd line environment variables if provided.
#
# Parameters:
#   $1: type of apply. "isolate" will set the variable to itself as local,
#       to make it isolated in it's scope.
#
# Expects:
#   _envE
#===============
_apply_cmd_env()
{
    local _type="${1-}"

    local _ev=
    for _ev in "${_envE[@]-}"; do
        if [[ $_ev =~ ([_a-zA-Z0-9]+)=(.*) ]]; then
            local _varname=${BASH_REMATCH[1]}
            if [[ ${BASH_REMATCH[2]} == "!unset" ]]; then
                printf "%s\n" "unset $_varname"
            elif [ "${_type}" = "isolate" ]; then
                printf "%s\n" "local $_varname=\"\$${_varname}\""
            else
                printf "%s\n" "local $_varname=\"${BASH_REMATCH[2]}\""
            fi
        fi
    done
}

#=============
# _push
#
# Push variable onto stack.
# Note: Only handles strings, for now.
#
# Parameters:
#   $1: variable name
#
#=============
_push()
{
    ((_STACK_POINTER+=1))

    local _stname="${_STACK_PREFIX}${_STACK_POINTER}"
    eval "${_stname}=\$${1}"
}

#=============
# _pop
#
# Pop variable from stack.
#
# Parameters:
#   $1: variable name to pop into.
#
#=============
_pop()
{
    if ((_STACK_POINTER == 0)); then
        return 1;
    fi

    local _stname="${_STACK_PREFIX}${_STACK_POINTER}"
    eval "${1}=\$${_stname}"

    ((_STACK_POINTER-=1))
}

_main "$@"
